(function () { if (typeof module === "object") { var everliveModule = module; } if (typeof define !== "undefined" && define.amd) { define(function() { return Everlive; }); } (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    var str = String(input);
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      str.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = str.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],4:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],5:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":6}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],8:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":7,"_process":6,"inherits":4}],9:[function(require,module,exports){

/**
 * Module dependencies.
 */

var ops = require('./ops');
var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = filter;
exports.ops = ops;

/**
 * Filters an `obj` by the given `query` for subdocuments.
 *
 * @return {Object|Boolean} false if no match, or matched subdocs
 * @api public
 */

function filter(obj, query){
  obj = obj || {};
  var ret = {};

  for (var key in query) {
    if (!query.hasOwnProperty(key)) continue;

    // search value
    var val = query[key];

    // split the key into prefix and suffix
    var keys = key.split('.');
    var target = obj;
    var prefix, search;
    var matches = [];

    walk_keys:
    for (var i = 0; i < keys.length; i++) {
      target = target[keys[i]];

      switch (type(target)) {
        case 'array':
          // if it's an array subdocument search we stop here
          prefix = keys.slice(0, i + 1).join('.');
          search = keys.slice(i + 1).join('.');

          debug('searching array "%s"', prefix);

          // we special case operators that don't walk the array
          if (val.$size && !search.length) {
            return compare(val, target);
          }

          // walk subdocs
          var subset = ret[prefix] || target;

          for (var ii = 0; ii < subset.length; ii++) {
            if (search.length) {
              var q = {};
              q[search] = val;
              if ('object' == type(subset[ii])) {
                debug('attempting subdoc search with query %j', q);
                if (filter(subset[ii], q)) {
                  // we ignore the ret value of filter
                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                    matches.push(subset[ii]);
                  }
                }
              }
            } else {
              debug('performing simple array item search');
              if (compare(val, subset[ii])) {
                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                  matches.push(subset[ii]);
                }
              }
            }
          }

          if (matches.length) {
            ret[prefix] = ret[prefix] || [];
            ret[prefix].push.apply(ret[prefix], matches);
          }

          // we don't continue the key search
          break walk_keys;

        case 'undefined':
          // if we can't find the key
          return false;

        case 'object':
          if (null != keys[i + 1]) {
            continue;
          } else if (!compare(val, target)) {
            return false;
          }
          break;

        default:
          if (!compare(val, target)) return false;
      }
    }
  }

  return ret;
}

/**
 * Compares the given matcher with the document value.
 *
 * @param {Mixed} matcher
 * @param {Mixed} value
 * @api private
 */

function compare(matcher, val){
  if ('object' != type(matcher)) {
    return eql(matcher, val);
  }

  var keys = object.keys(matcher);
  if ('$' == keys[0][0]) {
    for (var i = 0; i < keys.length; i++) {
      // special case for sub-object matching
      if ('$elemMatch' == keys[i]) {
        return false !== filter(val, matcher.$elemMatch);
      } else {
        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
      }
    }
    return true;
  } else {
    return eql(matcher, val);
  }
}

},{"./ops":20,"component-type":12,"debug":13,"dot-component":16,"mongo-eql":18,"object-component":19}],10:[function(require,module,exports){

/**
 * Module dependencies.
 */

var mods = require('./mods');
var filter = require('./filter');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = query;

/**
 * Export filter helper.
 */

exports.filter = filter;

/**
 * Export modifiers.
 */

exports.mods = mods;

/**
 * Execute a query.
 *
 * Options:
 *  - `strict` only modify if query matches
 *
 * @param {Object} object to alter
 * @param {Object} query to filter modifications by
 * @param {Object} update object
 * @param {Object} options
 */

function query(obj, query, update, opts){
  obj = obj || {};
  opts = opts || {};
  query = query || {};
  update = update || {};

  // strict mode
  var strict = !!opts.strict;

  var match;
  var log = [];

  if (object.length(query)) {
    match = filter(obj, query);
  }

  if (!strict || false !== match) {
    var keys = object.keys(update);
    var transactions = [];

    for (var i = 0, l = keys.length; i < l; i++) {
      if (mods[keys[i]]) {
        debug('found modifier "%s"', keys[i]);
        for (var key in update[keys[i]]) {
          var pos = key.indexOf('.$.');

          if (~pos) {
            var prefix = key.substr(0, pos);
            var suffix = key.substr(pos + 3);

            if (match[prefix]) {
              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
              if (fn) {
                // produce a key name replacing $ with the actual index
                // TODO: this is unnecessarily expensive
                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
                fn.key = prefix + '.' + index + '.' + suffix;
                fn.op = keys[i];
                transactions.push(fn);
              }
            } else {
              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
            }
          } else {
            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
            if (fn) {
              fn.key = key;
              fn.op = keys[i];
              transactions.push(fn);
            }
          }
        }
      } else {
        debug('skipping unknown modifier "%s"', keys[i]);
      }
    }

    if (transactions.length) {
      // if we got here error free we process all transactions
      for (var i = 0; i < transactions.length; i++) {
        var fn = transactions[i];
        var val = fn();
        log.push({ op: fn.op, key: fn.key, value: val });
      }
    }
  } else {
    debug('no matches for query %j', query);
  }

  return log;
}

},{"./filter":9,"./mods":11,"component-type":12,"debug":13,"dot-component":16,"object-component":19}],11:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var keys = require('object-component').keys;
var debug = require('debug')('mongo-query');

/**
 * Performs a `$set`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$set = function $set(obj, path, val){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path, true);

  switch (type(obj)) {
    case 'object':
      if (!eql(obj[key], val)) {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (numeric(key)) {
        if (!eql(obj[key], val)) {
          return function(){
            obj[key] = val;
            return val;
          };
        }
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('$set only supports object not ' + type(obj));
  }
};

/**
 * Performs an `$unset`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$unset = function $unset(obj, path){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path);

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        return function(){
          // reminder: `delete arr[1]` === `delete arr['1']` [!]
          delete obj[key];
        };
      } else {
        // we fail silently
        debug('ignoring unset of inexisting key');
      }
  }
};

/**
 * Performs a `$rename`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$rename = function $rename(obj, path, newKey){
  // target = source
  if (path == newKey) {
    throw new Error('$rename source must differ from target');
  }

  // target is parent of source
  if (0 === path.indexOf(newKey + '.')) {
    throw new Error('$rename target may not be a parent of source');
  }

  var p = dot.parent(obj, path);
  var t = type(p);

  if ('object' == t) {
    var key = path.split('.').pop();

    if (p.hasOwnProperty(key)) {
      return function(){
        var val = p[key];
        delete p[key];

        // target does initialize the path
        var newp = dot.parent(obj, newKey, true);

        // and also fails silently upon type mismatch
        if ('object' == type(newp)) {
          newp[newKey.split('.').pop()] = val;
        } else {
          debug('invalid $rename target path type');
        }

        // returns the name of the new key
        return newKey;
      };
    } else {
      debug('ignoring rename from inexisting source');
    }
  } else if ('undefined' != t) {
    throw new Error('$rename source field invalid');
  }
};

/**
 * Performs an `$inc`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$inc = function $inc(obj, path, inc){
  if ('number' != type(inc)) {
    throw new Error('Modifier $inc allowed for numbers only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('number' != type(obj[key])) {
          throw new Error('Cannot apply $inc modifier to non-number');
        }

        return function(){
          obj[key] += inc;
          return inc;
        };
      } else if('object' == type(obj) || numeric(key)){
        return function(){
          obj[key] = inc;
          return inc;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('Cannot apply $inc modifier to non-number');
  }
};

/**
 * Performs an `$pop`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$pop = function $pop(obj, path, val){
  obj = dot.parent(obj, path);
  var key = path.split('.').pop();

  // we make sure the array is not just the parent of the main key
  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        switch (type(obj[key])) {
          case 'array':
            if (obj[key].length) {
              return function(){
                if (-1 == val) {
                  return obj[key].shift();
                } else {
                  // mongodb allows any value to pop
                  return obj[key].pop();
                }
              };
            }
            break;

          case 'undefined':
            debug('ignoring pop to inexisting key');
            break;

          default:
            throw new Error('Cannot apply $pop modifier to non-array');
        }
      } else {
        debug('ignoring pop to inexisting key');
      }
      break;

    case 'undefined':
      debug('ignoring pop to inexisting key');
      break;
  }
};

/**
 * Performs a `$push`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @return {Function} transaction (unless noop)
 */

exports.$push = function $push(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pushAll`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Array} values to push
 * @return {Function} transaction (unless noop)
 */

exports.$pushAll = function $pushAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = val;
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pull`.
 */

exports.$pull = function $pull(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$pullAll`.
 */

exports.$pullAll = function $pullAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$addToSet`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @param {Boolean} internal, true if recursing
 * @return {Function} transaction (unless noop)
 */

exports.$addToSet = function $addToSet(obj, path, val, recursing){
  if (!recursing && 'array' == type(val.$each)) {
    var fns = [];
    for (var i = 0, l = val.$each.length; i < l; i++) {
      var fn = $addToSet(obj, path, val.$each[i], true);
      if (fn) fns.push(fn);
    }
    if (fns.length) {
      return function(){
        var values = [];
        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
        return values;
      };
    } else {
      return;
    }
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Helper for determining if an array has the given value.
 *
 * @param {Array} array
 * @param {Object} value to check
 * @return {Boolean}
 */

function has(array, val){
  for (var i = 0, l = array.length; i < l; i++) {
    if (eql(val, array[i])) return true;
  }
  return false;
}

/**
 * Array#filter function generator for `$pull`/`$pullAll` operations.
 *
 * @param {Array} array of values to match
 * @param {Array} array to populate with results
 * @return {Function} that splices the array
 */

function pull(arr, vals, pulled){
  var indexes = [];

  for (var a = 0; a < arr.length; a++) {
    var val = arr[a];

    for (var i = 0; i < vals.length; i++) {
      var matcher = vals[i];
      if ('object' == type(matcher)) {
        // we only are only interested in obj <-> obj comparisons
        if ('object' == type(val)) {
          var match = false;

          if (keys(matcher).length) {
            for (var i in matcher) {
              if (matcher.hasOwnProperty(i)) {
                // we need at least one matching key to pull
                if (eql(matcher[i], val[i])) {
                  match = true;
                } else {
                  // if a single key doesn't match we move on
                  match = false;
                  break;
                }
              }
            }
          } else if (!keys(val).length) {
            // pull `{}` matches [{}]
            match = true;
          }

          if (match) {
            indexes.push(a);
            pulled.push(val);
            continue;
          }
        } else {
          debug('ignoring pull match against object');
        }
      } else {
        if (eql(matcher, val)) {
          indexes.push(a);
          pulled.push(val);
          continue;
        }
      }
    }
  }

  return function(){
    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i];
      arr.splice(index - i, 1);
    }
  };
}

/**
 * Helper to determine if a value is numeric.
 *
 * @param {String|Number} value
 * @return {Boolean} true if numeric
 * @api private
 */

function numeric(val){
  return 'number' == type(val) || Number(val) == val;
}

},{"component-type":12,"debug":13,"dot-component":16,"mongo-eql":18,"object-component":19}],12:[function(require,module,exports){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val)

  return typeof val;
};

},{}],13:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":14}],14:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":15}],15:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],16:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('type-component');

/**
 * Gets a certain `path` from the `obj`.
 *
 * @param {Object} target
 * @param {String} key
 * @return {Object} found object, or `undefined
 * @api public
 */

exports.get = function(obj, path){
  if (~path.indexOf('.')) {
    var par = parent(obj, path);
    var mainKey = path.split('.').pop();
    var t = type(par);
    if ('object' == t || 'array' == t) return par[mainKey];
  } else {
    return obj[path];
  }
};

/**
 * Sets the given `path` to `val` in `obj`.
 *
 * @param {Object} target
 * @Param {String} key
 * @param {Object} value
 * @api public
 */

exports.set = function(obj, path, val){
  if (~path.indexOf('.')) {
    var par = parent(obj, path, true);
    var mainKey = path.split('.').pop();
    if (par && 'object' == type(par)) par[mainKey] = val;
  } else {
    obj[path] = val;
  }
};

/**
 * Gets the parent object for a given key (dot notation aware).
 *
 * - If a parent object doesn't exist, it's initialized.
 * - Array index lookup is supported
 *
 * @param {Object} target object
 * @param {String} key
 * @param {Boolean} true if it should initialize the path
 * @api public
 */

exports.parent = parent;

function parent(obj, key, init){
  if (~key.indexOf('.')) {
    var pieces = key.split('.');
    var ret = obj;

    for (var i = 0; i < pieces.length - 1; i++) {
      // if the key is a number string and parent is an array
      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
        ret = ret[pieces[i]];
      } else if ('object' == type(ret)) {
        if (init && !ret.hasOwnProperty(pieces[i])) {
          ret[pieces[i]] = {};
        }
        if (ret) ret = ret[pieces[i]];
      }
    }

    return ret;
  } else {
    return obj;
  }
}

},{"type-component":17}],17:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],18:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('component-type');

/**
 * Module exports.
 */

module.exports = eql;

/**
 * MongoDB style value comparisons.
 *
 * @param {Object} matcher
 * @param {Object} value
 * @return {Boolean} true if they match
 */

function eql(matcher, val){
  switch (type(matcher)) {
    case 'null':
    case 'undefined':
      // we treat null as undefined
      return null == val;

    case 'regexp':
      return matcher.test(val);

    case 'array':
      if ('array' == type(val) && matcher.length == val.length) {
        for (var i = 0; i < matcher.length; i++) {
          if (!eql(val[i], matcher[i])) return false;
        }
        return true;
      } else {
        return false;
      }
      break;

    case 'object':
      // object can match keys in any order
      var keys = {};

      // we match all values of `matcher` in `val`
      for (var i in matcher) {
        if (matcher.hasOwnProperty(i)) {
          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
            return false;
          }
        }
        keys[i] = true;
      }

      // we make sure `val` doesn't have extra keys
      for (var i in val) {
        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
          return false;
        }
      }

      return true;

    default:
      return matcher === val;
  }
}

},{"component-type":12}],19:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],20:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var type = require('component-type');

/**
 * $ne: not equal.
 */

exports.$ne = function $ne(matcher, val){
  return !eql(matcher, val);
};

/**
 * $gt: greater than.
 */

exports.$gt = function $gt(matcher, val){
  return type(matcher) === 'number' && val > matcher;
};

/**
 * $gte: greater than equal.
 */

exports.$gte = function $gte(matcher, val){
  return type(matcher) === 'number' && val >= matcher;
};

/**
 * $lt: less than.
 */

exports.$lt = function $lt(matcher, val){
  return type(matcher) === 'number' && val < matcher;
};

/**
 * $lte: less than equal.
 */

exports.$lte = function $lte(matcher, val){
  return type(matcher) === 'number' && val <= matcher;
};

/**
 * $regex: supply a regular expression as a string.
 */

exports.$regex = function $regex(matcher, val){
  // TODO: add $options support
  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
  return matcher.test(val);
};

/**
 * $exists: key exists.
 */

exports.$exists = function $exists(matcher, val){
  if (matcher) {
    return undefined !== val;
  } else {
    return undefined === val;
  }
};

/**
 * $in: value in array.
 */

exports.$in = function $in(matcher, val){
  if ('array' != type(matcher)) return false;
  for (var i = 0; i < matcher.length; i++) {
    if (eql(matcher[i], val)) return true;
  }
  return false;
};

/**
 * $nin: value not in array.
 */

exports.$nin = function $nin(matcher, val){
  return !exports.$in(matcher, val);
};

/**
 * @size: array length
 */

exports.$size = function(matcher, val){
  return Array.isArray(val) && matcher == val.length;
};

},{"component-type":12,"mongo-eql":18}],21:[function(require,module,exports){
var CryptoJS = require('./lib/core').CryptoJS;
require('./lib/enc-base64');
require('./lib/md5');
require('./lib/evpkdf');
require('./lib/cipher-core');
require('./lib/aes');
var JsonFormatter = require('./lib/jsonformatter').JsonFormatter;

exports.CryptoJS = CryptoJS;
exports.JsonFormatter = JsonFormatter;
},{"./lib/aes":22,"./lib/cipher-core":23,"./lib/core":24,"./lib/enc-base64":25,"./lib/evpkdf":26,"./lib/jsonformatter":27,"./lib/md5":28}],22:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

},{"./core":24}],23:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

},{"./core":24}],24:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

exports.CryptoJS = CryptoJS;

},{}],25:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

},{"./core":24}],26:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var MD5 = C_algo.MD5;

    /**
     * This key derivation function is meant to conform with EVP_BytesToKey.
     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
     */
    var EvpKDF = C_algo.EvpKDF = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: MD5,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.EvpKDF.create();
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Derives a key from a password.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init hasher
            var hasher = cfg.hasher.create();

            // Initial values
            var derivedKey = WordArray.create();

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                if (block) {
                    hasher.update(block);
                }
                var block = hasher.update(password).finalize(salt);
                hasher.reset();

                // Iterations
                for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                }

                derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Derives a key from a password.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.EvpKDF(password, salt);
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
    };
}());

},{"./core":24}],27:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

// create custom json serialization format
var JsonFormatter = {
	stringify: function (cipherParams) {
		// create json object with ciphertext
		var jsonObj = {
			ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
		};
		
		// optionally add iv and salt
		if (cipherParams.iv) {
			jsonObj.iv = cipherParams.iv.toString();
		}
		
		if (cipherParams.salt) {
			jsonObj.s = cipherParams.salt.toString();
		}

		// stringify json object
		return JSON.stringify(jsonObj)
	},

	parse: function (jsonStr) {
		// parse json string
		var jsonObj = JSON.parse(jsonStr);
		
		// extract ciphertext from json object, and create cipher params object
		var cipherParams = CryptoJS.lib.CipherParams.create({
			ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
		});
		
		// optionally extract iv and salt
		if (jsonObj.iv) {
			cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);
		}
            
		if (jsonObj.s) {
			cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);
		}
		
		return cipherParams;
	}
};

exports.JsonFormatter = JsonFormatter;
},{"./core":24}],28:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

},{"./core":24}],29:[function(require,module,exports){
'use strict';
var Constants = {};
Constants.DefaultTakeItemsCount = 50;
Constants.ExpandExpressionName = 'Expand';
Constants.ReturnAsFieldName = 'ReturnAs';
Constants.FieldsExpressionName = 'Fields';
Constants.SingleFieldExpressionName = 'SingleField';
Constants.SortExpressionName = 'Sort';
Constants.FilterExpressionName = 'Filter';
Constants.SkipExpressionName = 'Skip';
Constants.TakeExpressionName = 'Take';
Constants.ParentRelationFieldName = 'ParentRelationField';
Constants.IdFieldNameClient = 'Id';
Constants.TargetTypeNameFieldName = 'TargetTypeName';

module.exports = Constants;
},{}],30:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');

/**
 * A class that is used to get all required information in order to process a set of relations.
 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
 * if they can be combined for batch execution).
 * @constructor
 */
var ExecutionNode = function (parent, relationNode) {
    var parentPath = '';
    if (parent) {
        parentPath = parent.path;
    }
    this.parent = parentPath;
    this.relations = [relationNode.path];
    this.name = relationNode.path;
    this.targetTypeName = relationNode.targetTypeName;
    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.take && !relationNode.skip;
    this.children = [];
    var path = '';
    if (parentPath) {
        path += parentPath + '.';
    }
    path += relationNode.targetTypeName;
    this.path = path;
};

/**
 * Inserts a RelationNode to an ExecutionNode.
 * @param relation - A Relation instance.
 */
ExecutionNode.prototype.insertRelationNode = function (relation) {
    this.relations.push(relation.path);
};

/**
 * Inserts a child node (which relations) depends from parent node result.
 * @param child - ExecutionNode instance representing child node.
 */
ExecutionNode.prototype.insertChildrenNode = function (child) {
    this.children.push(child.name);
};

/**
 * Helper method that checks if some relations could be combined (for example have same TargetType).
 * @param relation
 * @returns {boolean}
 */
ExecutionNode.prototype.canCombineWithRelation = function (relation) {
    if (!this.canAddOtherRelations) {
        return false;
    }

    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.take && !relation.skip;
};

/** ExecutionTree
 * Class that allows the creation of an execution tree from a relationTree. Used to process all queries (master and child) in a correct order.
 * @param relationTree - An instance of relation tree.
 * @constructor
 */
var ExecutionTree = function (relationTree) {
    this._relationTree = relationTree;
    this._map = {};
};

/**
 * Adds execution node to the ExecutionTree.
 * @param executionNode
 */
ExecutionTree.prototype.addExecutionNode = function (executionNode) {
    this._map[executionNode.name] = executionNode;
};

/**
 * Finds the ExecutionNode which contains the requested relation.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
    for (var execNode in this._map) {
        if (this._map.hasOwnProperty(execNode)) {
            if (this._map[execNode].relations.indexOf(relation) > -1) {
                return this._map[execNode];
            }
        }
    }
    return null;
};

/**
 * Finds a RelationNode within the RelationTree.
 * @param relation - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
 * @returns {*}
 */
ExecutionTree.prototype.getRelationNode = function (relation) {
    if (relation) {
        return this._relationTree[relation] || null;
    } else {
        return null;
    }
};

ExecutionTree.prototype.getRootRelationNode = function () {
    return this._relationTree[this._relationTree.$root] || null;
};
/**
 * Builds the ExecutionTree from a RelationTree.
 */
ExecutionTree.prototype.build = function () {
    //build beginning from the root
    var relationRoot = this.getRelationNode(this._relationTree.$root);
    //Setup the root of the execution tree.
    var rootExecutionNode = new ExecutionNode(null, relationRoot);//no parent node
    this.addExecutionNode(rootExecutionNode);
    this.buildInternal(relationRoot);
};

/**
 * Traverse the relation tree and build the execution tree.
 * @param relationRoot - The root node of the RelationTree.
 */
ExecutionTree.prototype.buildInternal = function (relationRoot) {
    relationRoot.children.forEach(function (child) {
        var childRelationNode = this.getRelationNode(child);
        this.insertRelationNodeInExecutionTree(childRelationNode);
        this.buildInternal(childRelationNode);
    }, this);
};

/**
 * Inserts a relation node within the execution tree (based on its dependencies).
 * @param relation - The relation that will be inserted.
 */
ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parent);
    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
    if (childToCombine) {//if there is a child that we combine the relation
        childToCombine.insertRelationNode(relation);
    } else {
        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation);//create a separate execution node that will host the relation
        rootExecutionNode.insertChildrenNode(newExecutionNode);
        this.addExecutionNode(newExecutionNode);
    }
};

/**
 * Tries to find an ExecutionNode which could be combined with a relation.
 * @param rootExecutionNode - The root node of the ExecutionTree.
 * @param relation - Relation that will be added to the ExecutionTree.
 * @returns {*}
 */
ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
    if (rootExecutionNode.canCombineWithRelation(relation)) {
        return rootExecutionNode;
    }
    var children = rootExecutionNode.children;
    for (var i = 0; i < children.length; i++) {
        var child = this._map[children[i]];
        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
        if (childToCombine) {
            return childToCombine;
        }
    }
    return null;
};

/**
 * Gets the filter expression from all relations inside an ExecutionNode.
 * @param executionNode - The ExecutionNode instance.
 * @returns {{}}
 */
ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
    var filter = {};
    var subRelationsFilter = [];
    for (var i = 0; i < executionNode.relations.length; i++) {
        var innerFilter = this.getFilterFromSingleRelation(this._relationTree[executionNode.relations[i]], includeArrays);
        if (innerFilter) {
            subRelationsFilter.push(innerFilter);
        }
    }

    if (subRelationsFilter.length > 1) {
        filter.$or = subRelationsFilter;
    } else if (subRelationsFilter.length > 0) {
        filter = subRelationsFilter[0];
    } else {
        filter = null;
    }
    return filter;
};

/**
 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
 * along with user defined filters.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
    var userDefinedFilter = relation.filterExpression;
    var parentRelationFilter = {};
    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
    var parentRelationFieldName = (relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient);

    if (parentRelationIds.length > 0) {
        parentRelationFilter[parentRelationFieldName] = {'$in': parentRelationIds};
    } else {
        return null;
    }

    if (userDefinedFilter !== undefined) {
        var filters = [];
        filters.push(parentRelationFilter);
        filters.push(userDefinedFilter);
        return {'$and': filters};
    } else {
        return parentRelationFilter;
    }
};

/**
 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
 * @param relation - A relation instance which will get the filter.
 * @param includeArrays - Whether to include array valus of the parent items when calculating the items that will be expanded on the current level.
 * @returns {Array} - An array of relation field values.
 */
ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
    var parentRelationIds = [];
    var parentRelation = this._relationTree[relation.parent];
    // parentRelationResult actually is an Activity or Array of Activities
    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
    if (relation.isInvertedRelation) {
        for (var p = 0; p < parentRelationResult.length; p++) {
            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
        }
    } else {
        // all comments are related to expand of type content type Activities expand: {"Likes": true}
        if (parentRelation && parentRelation.result) {
            relation.parentRelationIds = relation.parentRelationIds || {};
            for (var i = 0; i < parentRelationResult.length; i++) {
                // itemFromParentRelation is single Activity
                var itemFromParentRelation = parentRelationResult[i];

                // parentRelationFieldValue is Activity.Likes
                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
                if (Array.isArray(parentRelationFieldValue)) {
                    relation.hasArrayValues = true;
                    if (includeArrays) {
                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
                            var itemToExpandId = parentRelationFieldValue[j];
                            if(itemToExpandId !== undefined && itemToExpandId !== null) {
                                parentRelationIds.push(itemToExpandId);
                                // we set any value just to create a map of Ids
                                relation.parentRelationIds[itemToExpandId] = 1;
                            }
                        }
                    }
                } else {
                    if(parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
                        parentRelationIds.push(parentRelationFieldValue);
                        relation.parentRelationIds[parentRelationFieldValue] = 1;
                    }
                }
            }
        }
    }

    return parentRelationIds;
};

module.exports = ExecutionTree;

},{"./Constants":29}],31:[function(require,module,exports){
'use strict';
function ExpandError(message) {
    this.name = 'ExpandError';
    this.message = message;
    this.stack = (new Error()).stack;
}
ExpandError.prototype = new Error;
module.exports = ExpandError;
},{}],32:[function(require,module,exports){
'use strict';
var async = require('async');
var RelationTreeBuilder = require('./RelationTreeBuilder');
var ExecutionTree = require('./ExecutionTree');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

function Processor(options) {
    this._executionNodeFunction = options.executionNodeFunction;
    this._metadataProviderFunction = options.metadataProviderFunction;
}

Processor.prototype._getExecutionTreeRoot = function (executionTree) {
    var executionTreeRoot = null;
    for (var exNode in executionTree) {
        if (executionTree.hasOwnProperty(exNode)) {
            if (executionTree[exNode].parent === '') {
                executionTreeRoot = executionTree[exNode];
                break;
            }
        }
    }
    return executionTreeRoot;
};

Processor.prototype._createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
    var self = this;
    var relationsTreeMap = relationsTree.map;
    return function (done) {
        var relationNode = executionTree.getRelationNode(executionNode.relations[0]);//get the relation node for the only relation of the execution node.
        var parentRelationNode = executionTree.getRelationNode(relationNode.parent);
        var includeArrays = !(parentRelationNode.parent && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
        var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);

        var errorMessage = relationsTree.validateSingleRelation(relationNode);
        if (errorMessage) {
            return done(new ExpandError(errorMessage));
        }

        // if we have such options executionNode should have only one relation.
        var node = {};
        node.select = relationNode.fieldsExpression;
        node.sort = relationNode.sortExpression;
        node.skip = relationNode.skip;
        node.take = relationNode.take;
        node.filter = filter;
        node.targetTypeName = relationNode.targetTypeName;

        self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
            if (err) {
                return done(err);
            }

            for (var i = 0; i < executionNode.relations.length; i++) {
                var childRelation = relationsTreeMap[executionNode.relations[i]];
                childRelation.result = self._extractResultForRelation(relationsTreeMap[executionNode.relations[i]], result);
            }
            executionNode.result = childRelation.result;
            var arr = [];
            for (var j = 0; j < executionNode.children.length; j++) {
                var executionTreeMap = executionTree._map;
                arr.push(self._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
            }
            async.parallel(arr, done);
        });
    };
};

Processor.prototype._getSingleResult = function (relationsTree, relation, singleObject) {
    if (!singleObject) {
        return null;
    }

    var childRelation;
    var childItem;

    // if relation has singleFieldName option we just replace the parent id with a single value
    if (relation.singleFieldName) {
        if (relation.children && relation.children.length > 0) {
            childRelation = relationsTree[relation.children[0]];
            childItem = this._getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
            return this._getSingleResult(relationsTree, childRelation, childItem);
        }
        return singleObject[relation.singleFieldName];
    }

    var result = {};
    var passedProperties = {};

    if (relation.children && relation.children.length > 0) {
        for (var j = 0; j < relation.children.length; j++) {
            childRelation = relationsTree[relation.children[j]];
            var childRelationField = childRelation.relationField;
            var userDefinedRelName = childRelation.userDefinedName;
            if (!childRelation.isInvertedRelation) {
                passedProperties[childRelationField] = 1;
            }

            var innerRelationResult = childRelation.result;

            if (childRelation.isInvertedRelation) {
                for (var k = 0; k < innerRelationResult.length; k++) {
                    this._addSingleResultToParentArray(relationsTree, childRelation, innerRelationResult[k], result, userDefinedRelName);
                }
            } else {
                result[userDefinedRelName] = childRelation.isArray() ? [] : null;

                if (singleObject[childRelationField]) {
                    if (Array.isArray(singleObject[childRelationField])) {
                        if (childRelation.sortExpression) {
                            // if there is a sorting we replace items using order of the query result
                            for (var p = 0; p < innerRelationResult.length; p++) {
                                if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
                                    childItem = innerRelationResult[p];
                                    this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                                }
                            }
                        } else {
                            // we just replace items getting them by id which we have
                            for (var i = 0; i < singleObject[childRelationField].length; i++) {
                                childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
                                this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                            }
                        }
                    } else {
                        childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
                        result[userDefinedRelName] = this._getSingleResult(relationsTree, childRelation, childItem);
                    }
                }
            }
        }
    }

    // add all other fields to the result (except the relation fields which we have already replaced).
    for (var prop in singleObject) {
        var propertyShouldBeAddedToResult = singleObject.hasOwnProperty(prop) && !passedProperties[prop] &&
            this._fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
        if (propertyShouldBeAddedToResult) {
            result[prop] = singleObject[prop];
        }
    }

    return result;
};

Processor.prototype._addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
    var singleResult = this._getSingleResult(relationsTree, childRelation, childItem);
    result[userDefinedRelName] = result[userDefinedRelName] || [];
    if (singleResult) {
        result[userDefinedRelName].push(singleResult);
    }
};

/**
 * Checks if a field will be returned via given fields expression.
 * @param field - The name of the field.
 * @param fieldsExpression - The Fields expression which is checked.
 * @returns {*}
 */
Processor.prototype._fieldExistInFieldsExpression = function (field, fieldsExpression) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return true;
    }

    if (field === Constants.IdFieldNameClient) {
        if (fieldsExpression[field] === undefined) {
            return true;
        }
        return fieldsExpression[field];
    }

    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return true;
    }

    if (isExclusive) {
        return !fieldsExpression.hasOwnProperty(field);
    } else {
        return fieldsExpression.hasOwnProperty(field);
    }
};

/**
 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
 * @param relation - The relation object.
 * @param queryResult - Result of the combined query.
 * @returns {Array}
 */
Processor.prototype._extractResultForRelation = function (relation, queryResult) {
    var result = [];
    for (var i = 0; i < queryResult.length; i++) {
        if (relation.parentRelationIds) {
            if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
                result.push(queryResult[i]);
            }
        }
        if (relation.isInvertedRelation) {
            result.push(queryResult[i]);
        }
    }
    return result;
};

/**
 * Gets an object with a given Id from Array.
 * @param array
 * @param id
 * @returns {*}
 */
Processor.prototype._getObjectByIdFromArray = function (array, id) {
    if (array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].Id === id) {
                return array[i];
            }
        }
    }
    return null;
};

/**
 * @public
 * @param expandExpression
 * @param mainTypeName
 * @param isArray
 * @param fieldsExpression
 * @param maxTakeValue
 * @param prepareContext
 * @param done
 */
Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
    var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
    rtb.build(function (err, map) {
        var mainQueryFieldsExpression;
        if (map) {
            mainQueryFieldsExpression = map[map.$root].fieldsExpression;
            var prepareResult = {
                relationsTree: rtb,
                mainQueryFieldsExpression: mainQueryFieldsExpression
            }
        }
        done(err, prepareResult);
    });
};

/**
 * @public
 * @param relationsTree
 * @param mainQueryResult
 * @param expandContext
 * @param done
 */
Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
    var relationsTreeMap = relationsTree.map;
    var self = this;
    var executionTree = new ExecutionTree(relationsTreeMap);
    executionTree.build();
    relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;
    var executionTreeMap = executionTree._map;

    var executionTreeRoot = this._getExecutionTreeRoot(executionTreeMap);

    var maxQueriesCount = 20;
    if (Object.keys(executionTreeMap).length > maxQueriesCount) {
        done(new ExpandError('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
    }

    if (executionTreeRoot) {
        var execFuncs = [];
        for (var i = 0; i < executionTreeRoot.children.length; i++) {
            execFuncs.push(this._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionTreeRoot.children[i]], expandContext));
        }
        // execFuncs are functions created for every single execution note
        // we execute them in async, since the result of the parent relation is used to get correct filter.
        async.series(execFuncs, function onProcessExecutionTree(err) {
            if (err) {
                done(err);
            } else {
                var output;
                var rootRelation = relationsTreeMap[relationsTreeMap.$root];
                if (Array.isArray(mainQueryResult)) {
                    output = [];
                    for (var i = 0; i < mainQueryResult.length; i++) {
                        var singleResult = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i]);
                        if (singleResult) {
                            output.push(singleResult);
                        }
                    }
                } else {
                    output = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult);
                }
                done(null, output);
            }
        });
    }
};

Processor.Constants = Constants;

module.exports = Processor;

},{"./Constants":29,"./ExecutionTree":30,"./ExpandError":31,"./RelationTreeBuilder":34,"async":35}],33:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');
var _ = require('underscore');
var ExpandError = require('./ExpandError');

function RelationNode(options) {
    this.parent = options.parent;
    this.relationField = options.relationField;
    this.path = options.path || options.parent + '.' + options.relationField;
    this.fieldsExpression = options.fieldsExpression || {};
    this.targetTypeName = options.targetTypeName;
    this.children = [];
    this.isInvertedRelation = options.isInvertedRelation;
    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
    this.hasArrayValues = false;//set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.

    var expandExpression = options.expandExpression || {};

    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
    this.originalFieldsExpression = {};
    _.extend(this.originalFieldsExpression, this.fieldsExpression);
    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
    this.filterExpression = expandExpression[Constants.FilterExpressionName];
    this.sortExpression = expandExpression[Constants.SortExpressionName];
    this.skip = expandExpression[Constants.SkipExpressionName];
    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
}


/**
 * Gets the take limit depending on the application and the take value that the user has provided.
 * @param clientTakeValue
 * @param maxTakeValue
 * @returns {number}
 */
RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
    if (clientTakeValue) {
        if (clientTakeValue > maxTakeValue) {
            throw new ExpandError('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
        }
        return clientTakeValue;
    } else {
        return maxTakeValue;
    }
};

/**
 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
 */
RelationNode.prototype.setIsArrayFromMetadata = function () {
    this.isArrayFromMetadata = true;
};

RelationNode.prototype.isArray = function () {
    // We can find out if a relation is an array in the following cases:
    // From metadata in the API Server.
    // All inverted relations are array.
    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues;
};

module.exports = RelationNode;

},{"./Constants":29,"./ExpandError":31,"underscore":2}],34:[function(require,module,exports){
'use strict';
var RelationNode = require('./RelationNode');
var _ = require('underscore');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

//var relationFieldPropertyName = Constants.RelationExpressionName;

var possibleExpandOptions = [
    Constants.ExpandExpressionName,
    Constants.ReturnAsFieldName,
    Constants.FieldsExpressionName,
    Constants.SingleFieldExpressionName,
    Constants.SortExpressionName,
    Constants.FilterExpressionName,
    Constants.SkipExpressionName,
    Constants.TakeExpressionName,
    Constants.ParentRelationFieldName,
    Constants.TargetTypeNameFieldName
];


/**
 * A class used to parse Expand expression and build a corresponding relation tree.
 * In a process of creating the relation tree are performed several checks in order to force some limitations -
 * 50 items both for master and child queries and entire amount of all queries limited to 20.
 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
 * Checks for possible expand options.
 * @constructor
 */
var RelationTreeBuilder = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
    this.maxTakeValue = maxTakeValue;
    this._metadataProviderFunction = metadataProviderFunction;
    this.context = context;
    this.expandExpression = this.processExpandExpression(expandExpression);
    // mark the main query in order to avoid some duplication issues.
    this.map = {};
    this.map[mainTypeName] = new RelationNode({
        targetTypeName: mainTypeName,
        isArrayRoot: isArray,
        fieldsExpression: fieldsExpression,
        validated: true,
        path: mainTypeName,
        maxTakeValue: maxTakeValue
    });
    this.map[mainTypeName].originalFieldsExpression = {};
    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
    this.map.$root = mainTypeName;
};

/**
 * Creates fully qualified expand expression from shorthand usages:
 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
 * @param expandExpression
 * @returns {*}
 */
RelationTreeBuilder.prototype.processExpandExpression = function (expandExpression) {
    for (var property in expandExpression) {
        if (expandExpression.hasOwnProperty(property)) {
            if (typeof expandExpression[property] === 'boolean') {
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = property;
            }
            if (typeof expandExpression[property] === 'string') {
                var relationField = expandExpression[property];
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
            }
        }
    }
    return expandExpression;
};

/**
 * Builds the relation tree.
 * @param done
 */
RelationTreeBuilder.prototype.build = function (done) {
    try {
        this.buildMapInternal(this.expandExpression, this.map.$root);
    } catch (e) {
        return done(e);
    }
    var self = this;
    require('async').series([
        this.configureRelationTree.bind(this),
        this.validateRelationTree.bind(this)
    ], function (err) {
        done(err, self.map);
    });
};

/**
 *
 * @param relationName - A path to the external relation collection (Comments.ActivityId)
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param rootName - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationTreeBuilder.prototype.createInvertedRelation = function (relationName, expandExpression, rootName) {
    var options = {};
    var relationNameParts = relationName.split('.');
    options.parent = rootName;
    options.relationField = relationNameParts[1];
    options.isInvertedRelation = true;
    options.targetTypeName = relationNameParts[0];
    options.expandExpression = expandExpression;
    options.path = relationName;
    options.maxTakeValue = this.maxTakeValue;
    options.validated = false;

    return new RelationNode(options);
};

/**
 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
 * @param expandExpression - The expand expression which will be processed.
 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
 */
RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
    for (var relationName in expandExpression) {
        if (expandExpression.hasOwnProperty(relationName)) {
            var currentExpression = expandExpression[relationName];

            for (var option in currentExpression) {
                if (currentExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
                    throw new ExpandError('\"' + option + '\"' + ' is not a valid option for Expand expression');
                }
            }

            if (relationName.indexOf('.') > -1) {
                var invertedRelation = this.createInvertedRelation(relationName, currentExpression, rootName);
                this.map[invertedRelation.path] = invertedRelation;
                this.map[invertedRelation.parent].children.push(invertedRelation.path);
                // adds a field expression in the original fields expression in order to get the result for that field
                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parent].originalFieldsExpression, invertedRelation.userDefinedName);

                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
                    var processedExpandExpression = this.processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
                }
            } else {
                var options = {};
                options.relationField = relationName;
                options.parent = rootName;
                options.expandExpression = currentExpression;
                options.maxTakeValue = this.maxTakeValue;
                options.targetTypeName = currentExpression[Constants.TargetTypeNameFieldName];
                var relationNode = new RelationNode(options);
                var parentNode = this.map[options.parent];
                parentNode.children.push(relationNode.path);
                this.map[relationNode.path] = relationNode;

                if (currentExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
                    if (typeof(currentExpression[Constants.ExpandExpressionName]) === 'object') {
                        this.buildMapInternal(this.processExpandExpression(currentExpression.Expand), relationNode.path);
                    } else {
                        throw new ExpandError(relationNode.path + '.Expand must be a valid expand expression!');
                    }
                }
            }
        }
    }
};

/**
 * Adds additional metadata which is necessary to execute a query.
 * Name of the content type of the child relation get via relation field.
 * @param done
 */
RelationTreeBuilder.prototype.configureRelationTree = function (done) {
    if (this._metadataProviderFunction) {
        var relationNames = [];
        var self = this;

        for (var rel in this.map) {
            if (this.map.hasOwnProperty(rel)) {
                if (this.map[rel].parent !== null) {
                    relationNames.push(this.map[rel].relationField);
                }
            }
        }

        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
            done(err);
        });
    } else {
        return done();
    }
};

/**
 * Performs several checks like:
 * Validity of the relation field.
 * To not use filter or sorting expression within a "GetByFilter" scenario.
 * Does not allow to nest (expand multiple relation field) after a multiple relation.
 * Does not allow to use both "Fields" and "SingleField" options.
 * @param done
 * @returns {*}
 */
RelationTreeBuilder.prototype.validateRelationTree = function (done) {
    var errorMessage = '';
    var EOL = '\r\n';
    for (var relationPath in this.map) {
        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
            var relation = this.map[relationPath];
            errorMessage += this.validateSingleRelation(relation);
            this.configureFieldsExpressionsForRelation(relation);
        }
    }
    if (errorMessage !== '') {
        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
        var error = new ExpandError(finalErrorMessage);
        return done(error);
    } else {
        done();
    }
};

/**
 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
 * @param relation - A relation which will be configured.
 */
RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
    if (relation.parent) {
        var parentRelationFieldsExpression = this.map[relation.parent].fieldsExpression;
        if (relation.isInvertedRelation) {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
        } else {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
        }
    }
    if (relation.isInvertedRelation) {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
    } else {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
    }
    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parent], relation);
};

/**
 * Validates a single relation for all build-in limitations.
 * @param relation - A relation which will be validated.
 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
 */
RelationTreeBuilder.prototype.validateSingleRelation = function (relation) {
    var errorMessage = '';
    var EOL = '\r\n';
    var isGetByFilterQuery = this.map[this.map.$root].isArrayRoot;

    if (relation.path === relation.parent) {
        errorMessage += relation.path + ' has same parent which will cause an infinite loop.' + EOL;
        return errorMessage;
    }

    if (relation.isArray()) {
        var multipleQueriesCount = this.getParentMultipleRelationsCount(relation);
        if (multipleQueriesCount > 0) {
            errorMessage += 'Expand expression has multiple relation \"' + relation.path + '\" inside a multiple relation.';
            errorMessage += EOL;
        }

        if (this.map[relation.parent] === this.map[this.map.$root] &&
            isGetByFilterQuery &&
            (relation.filterExpression || relation.sortExpression)) {
            errorMessage += 'Filter and Sort expressions are not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }

        if (isGetByFilterQuery && relation.isInvertedRelation) {
            errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }
    }
    if (!relation.targetTypeName) {
        errorMessage += 'Expanding relation \"' + relation.relationField + '\" has no target type name specified. You should use \"TargetTypeName\" to specify it.';
        errorMessage += EOL;
    }
    if (relation.fieldsExpression && Object.keys(relation.fieldsExpression).length && relation.singleFieldName) {
        errorMessage += relation.path + ' ';
        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
        errorMessage += EOL;
    }
    if (relation.singleFieldName) {
        if (relation.children) {
            if (relation.children.length > 1) {
                errorMessage += relation.path + ' has multiple expand expressions with a single field option.' + EOL;
            }
            if (relation.children.length === 1 && this.map[relation.children[0]].relationField !== relation.singleFieldName) {
                errorMessage += 'Expand expression ' + relation.path;
                errorMessage += ' single field \"' + relation.singleFieldName + '\"';
                errorMessage += ' does not match child relation field \"' + this.map[relation.children[0]].relationField + '\".';
                errorMessage += EOL;
            }
        }
    }

    return errorMessage;
};

/**
 * Gets the count of parent multiple relations.
 * @param relation - Starting relation.
 * @returns {number} - count of all parent multiple relations
 */
RelationTreeBuilder.prototype.getParentMultipleRelationsCount = function (relation) {
    var result = 0;
    var relationForLoop = relation;
    while (relationForLoop.parent) {
        var parentRelation = this.map[relationForLoop.parent];
        if (parentRelation.isArray() && parentRelation.parent) {
            result += 1;
        }
        relationForLoop = parentRelation;
    }
    return result;
};


/**
 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
 * In that case we put a "$slice" option within the parent relation fields expression.
 * @param parentRelation
 * @param relation
 */
RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
        if (shouldTransferPagingToParentRelation) {
            if (parentRelation.fieldsExpression === undefined) {
                parentRelation.fieldsExpression = {};
            }

            if (relation.skip && typeof relation.skip === 'number') {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': [relation.skip, relation.take]
                };
            } else {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': relation.take
                };
            }
            relation.take = null;
            relation.skip = null;
            relation.movedSkipTakeAsSlice = true;
        }
    }
};

/**
 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
 * @param fieldsExpression - Fields expression of the parent relation.
 * @param relationField - Name of the field which should be returned.
 */
RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return;
    }
    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return;
    }

    if (isExclusive) {
        delete fieldsExpression[relationField];
    } else {
        fieldsExpression[relationField] = 1;
    }
};

/**
 * Gets if the fields expression is exclusive ("FieldName" : 0)
 * @param fieldsExpression - Fields expression to check.
 * @returns {*}
 */
RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
    var isExclusive;
    for (var fieldName in fieldsExpression) {
        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
            if (isExclusive === undefined) {
                if (fieldsExpression[fieldName] === 0) {
                    isExclusive = true;
                    break;
                } else {
                    if (typeof fieldsExpression[fieldName] === 'object') {
                        continue;
                    } else {
                        // fieldsExpression[fieldName] === 1
                        isExclusive = false;
                        break;
                    }
                }
            }
        }
    }
    return isExclusive;
};

module.exports = RelationTreeBuilder;

},{"./Constants":29,"./ExpandError":31,"./RelationNode":33,"async":35,"underscore":2}],35:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":6}],36:[function(require,module,exports){
var buildPromise = require('./utils').buildPromise;
var EverliveError = require('./EverliveError').EverliveError;
var Platform = require('./constants').Platform;
var common = require('./common');
var jstz = common.jstz;
var _ = common._;

module.exports = (function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function (pushHandler) {
        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function (pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return buildPromise(_.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function (success, error) {
            var self = this;

            return this.unregister().then(
                function () {
                    return buildPromise(
                        function (success, error) {
                            if (self.emulatorMode) {
                                success();
                            } else {
                                var pushNotification = window.plugins.pushNotification;
                                var unregisterOptions;
                                var platformType = self._getPlatformType(device.platform);
                                if (platformType === Platform.WindowsPhone) {
                                    unregisterOptions = {'channelName': self.pushSettings.wp8.channelName};
                                }
                                pushNotification.unregister(
                                    function () {
                                        self.isInitialized = false;
                                        success();
                                    },
                                    error,
                                    unregisterOptions
                                );
                            }
                        },
                        success,
                        error
                    );
                },
                error
            );
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    return self._pushHandler.devices.create(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function (success, error) {
            var deviceId = encodeURIComponent(device.uuid);
            return this._pushHandler.devices.destroySingle({Id: 'HardwareId/' + deviceId}, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                    return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
                },
                error
            );
        },

        _initializeInteractivePush: function (iOSSettings, success, error) {
            var pushPlugin = window.plugins.pushNotification;

            var interactiveSettings = iOSSettings.interactiveSettings;
            var notificationTypes = [];
            if (iOSSettings.alert) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
            }
            if (iOSSettings.badge) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
            }
            if (iOSSettings.sound) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
            }

            var getAction = function (actionIdentifier) {
                var action = _.find(interactiveSettings.actions, function (action) {
                    return action.identifier === actionIdentifier;
                });

                return action;
            };
            var categories = _.map(interactiveSettings.categories, function (category) {
                return {
                    identifier: category.identifier,
                    actionsForDefaultContext: _.map(category.actionsForDefaultContext, getAction),
                    actionsForMinimalContext: _.map(category.actionsForMinimalContext, getAction)
                }
            });

            pushPlugin.registerUserNotificationSettings(
                // the success callback which will immediately return (APNs is not contacted for this)
                success,
                // called in case the configuration is incorrect
                error, {
                    // asking permission for these features
                    types: notificationTypes,
                    // register these categories
                    categories: categories
                }
            );
        },

        //Initializes the push functionality on the device.
        _initialize: function (success, error) {
            var self = this;

            if (this.isInitializing) {
                error(new EverliveError('Push notifications are currently initializing.'));
                return;
            }

            if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
                error(new EverliveError('The globalization plugin is not initialized.'));
                return;
            }

            if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
                error(new EverliveError('The push notifications plugin is not initialized.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            if (this.emulatorMode) {
                setTimeout(
                    function () {
                        self._deviceRegistrationSuccess('fake_push_token');
                    },
                    1000
                );
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var pushNotification = window.plugins.pushNotification;

            var platformType = this._getPlatformType(device.platform);
            if (platformType === Platform.iOS) {
                //Initialize global APN callback
                var apnCallbackName = 'apnCallback_' + suffix;
                Everlive.PushCallbacks[apnCallbackName] = _.bind(this._onNotificationAPN, this);

                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;
                this._validateIOSSettings(apnRegistrationOptions);
                apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;

                //Register for APN
                pushNotification.register(
                    _.bind(this._successfulRegistrationAPN, this),
                    _.bind(this._failedRegistrationAPN, this),
                    apnRegistrationOptions
                );
            } else if (platformType === Platform.Android) {
                //Initialize global GCM callback
                var gcmCallbackName = 'gcmCallback_' + suffix;
                Everlive.PushCallbacks[gcmCallbackName] = _.bind(this._onNotificationGCM, this);

                //Construct registration options object and validate the Android settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);
                gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;

                //Register for GCM
                pushNotification.register(
                    _.bind(this._successSentRegistrationGCM, this),
                    _.bind(this._errorSentRegistrationGCM, this),
                    gcmRegistrationOptions
                );
            } else if (platformType === Platform.WindowsPhone) {
                //Initialize global WP8 callbacks.
                var wp8CallbackName = 'wp8Callback_' + suffix;
                var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
                var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;

                Everlive.PushCallbacks[wp8CallbackName] = _.bind(this._onNotificationWP8, this);
                Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _.bind(this._deviceRegistrationSuccessWP, this);
                Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _.bind(this._deviceRegistrationFailed, this);

                //Construct registration options object and validate the WP8  settings
                var wp8RegistrationOptions = this.pushSettings.wp8;
                this._validateWP8Settings(wp8RegistrationOptions);
                wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
                wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
                wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;


                pushNotification.register(
                    _.bind(this._successSentRegistrationWP8, this),
                    _.bind(this._errorSentRegistrationWP8, this),
                    wp8RegistrationOptions
                );

            } else {
                throw new EverliveError('The current platform is not supported: ' + device.platform);
            }
        },

        _deviceRegistrationSuccessWP: function (result) {
            this._deviceRegistrationSuccess(result.uri);
        },

        _validateAndroidSettings: function (androidSettings) {
            if (!androidSettings.senderID) {
                throw new EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },
        _validateWP8Settings: function (settings) {
            if (!settings.channelName) {
                throw new EverliveError('channelName is not set in the WP8 settings.');
            }
        },

        _validateIOSSettings: function (iOSSettings) {

        },

        _cleanPlatformsPushSettings: function (pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
            addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
            _.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function (deviceRegistration, success, error) {
            var self = this;

            return buildPromise(
                function (success, error) {
                    if (!self.pushToken) {
                        throw new EverliveError('Push token is not available.');
                    }

                    self._getLocaleName(
                        function (locale) {
                            var deviceId = self._getDeviceId();
                            var hardwareModel = device.model;
                            var platformType = self._getPlatformType(device.platform);
                            var timeZone = jstz.determine().name();
                            var pushToken = self.pushToken;
                            var language = locale.value;
                            var platformVersion = device.version;

                            deviceRegistration.HardwareId = deviceId;
                            deviceRegistration.HardwareModel = hardwareModel;
                            deviceRegistration.PlatformType = platformType;
                            deviceRegistration.PlatformVersion = platformVersion;
                            deviceRegistration.TimeZone = timeZone;
                            deviceRegistration.PushToken = pushToken;
                            deviceRegistration.Locale = language;

                            success();
                        },
                        error
                    );
                },
                success,
                error
            );
        },

        _getLocaleName: function (success, error) {
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }
        },

        _getDeviceId: function () {
            return device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function (platformString) {
            var psLower = platformString.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return Platform.iOS;
                case 'android':
                    return Platform.Android;
                case 'wince':
                    return Platform.WindowsPhone;
                case 'win32nt': // real wp8 devices return this string as platform identifier.
                    return Platform.WindowsPhone;
                default:
                    return Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function (error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({error: error});
            }
        },

        _deviceRegistrationSuccess: function (token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({token: token});
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function (token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(
                    this.pushSettings.iOS,
                    function () {
                        self._deviceRegistrationSuccess(token);
                    },
                    function (err) {
                        throw new EverliveError('The interactive push configuration is incorrect: ' + err);
                    }
                );
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function (id) {
            //console.log("Successfully sent request for registering with GCM.");
        },
        //Occurs when device registration has been successfully sent for WP8
        _successSentRegistrationWP8: function (id) {
            //console.log("Successfully sent request for registering WP8 .");
        },
        //Occurs when an error occured when sending registration request for WP8
        _errorSentRegistrationWP8: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function (e) {
            this._raiseNotificationEventIOS(e);
        },
        //This function receives all notification events for WP8
        _onNotificationWP8: function (e) {
            this._raiseNotificationEventWP8(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function (e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function (e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        },
        _raiseNotificationEventWP8: function (e) {
            if (this.pushSettings.notificationCallbackWP8) {
                this.pushSettings.notificationCallbackWP8(e);
            }
        }
    };

    return CurrentDevice;
}());
},{"./EverliveError":39,"./common":48,"./constants":49,"./utils":82}],37:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;

var apply = function apply(obj) {
    obj._emitter = new EventEmitter();

    obj._emitterProxy = function (event, args) {
        obj._emitter[event].apply(obj._emitter, args);
    };

    obj.addListener = function () {
        obj._emitterProxy('addListener', arguments);
    };

    obj.on = obj.addListener;

    obj.removeListener = function () {
        obj._emitterProxy('removeListener', arguments);
    };

    obj.off = obj.removeListener;

    obj.once = function () {
        obj._emitterProxy('once', arguments);
    };

    obj.removeAllListeners = function () {
        obj._emitterProxy('removeAllListeners', arguments);
    };
};

module.exports = {
    apply: apply
};
},{"events":3}],38:[function(require,module,exports){
var Setup = require('./Setup');
var Data = require('./types/Data');
var usersModule = require('./types/Users');
var filesModule = require('./types/Files');
var constants = require('./constants');
var utils = require('./utils');
var buildAuthHeader = utils.buildAuthHeader;
var Push = require('./Push');
var Authentication = require('./auth/Authentication');
var offlineModule = require('./offline/offline');
var Request = require('./Request');
var common = require('./common');
var rsvp = common.rsvp;
var _ = common._;
var EverliveError = require('./EverliveError').EverliveError;
var EverliveErrors = require('./EverliveError').EverliveErrors;
var helpers = require('./helpers/helpers');
var EventEmitterProxy = require('./EventEmitterProxy');

module.exports = (function () {

    // The constructor of Everlive instances.
    // The entry point for the SDK.

    /**
     * @class Everlive
     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your API key.
     * @param {string} options.apiKey - Your API key.
     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
     * @param {object|boolean} [options.offlineStorage] - Set this option to true to use the default offline settings.
     * @param {boolean} [options.offlineStorage.isOnline=true] - Whether the storage is in online mode initially.
     * @param {ConflictResolutionStrategy|function} [options.offlineStorage.conflicts.strategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
     * @param {StorageProvider|object} [options.offlineStorage.storage.provider=StorageProvider.LocalStorage] - An object specifying settings for the offline storage provider.
     * @param {string} [options.offlineStorage.storage.storagePath=el_store] - A relative path specifying where the files will be saved if file system is used for persistence for item metadata.
     * @param {number} [options.offlineStorage.storage.requestedQuota=10485760] - How much memory (in bytes) to be requested when using the file system for persistence. This option is only valid for Chrome as the other platforms use all the available space.
     * @param {string} [options.offlineStorage.encryption.key] - A key that will be used to encrypt the data stored offline.
     * @param {string} [options.offlineStorage.files.storagePath=el_file_store] - A relative path specifying where the files will be saved if file system is used for persistence of files in offline mode.
     * @param {string} [options.offlineStorage.files.metaPath=el_file_mapping] - A relative path specifying where the metadata file will be saved if file system is used for persistence of files in offline mode.
     * @param {object|boolean} [options.offlineStorage.files] - Set this option to true to enable support for files in offline mode.
     * @param {boolean} [options.authentication.persist=false] - Indicates whether the current user's authentication will be persisted.
     * @param {Function} [options.authentication.onAuthenticationRequired] - Invoked when the user's credentials have expired. Allowing you to perform custom logic.
     * @param {object} [options.helpers] - An object holding options for all Everlive helper components.
     * @param {object} [options.helpers.html] - HTML Helper configuration objects.
     * @param {boolean} [options.helpers.html.processOnLoad=false] - Whether to process all HTML elements when the window loads.
     * @param {boolean} [options.helpers.html.processOnResize=false] - Whether to process all HTML elements when the window resizes.
     * @param {string} [options.helpers.html.loadingImageUrl] - The image to be displayed while the original image is being processed.
     * @param {string} [options.helpers.html.errorImageUrl] - The image to be displayed when the original image processing fails.
     * @param {object} [options.helpers.html.attributes] - HTML Helper attributes configuration object.
     * @param {object} [options.helpers.html.attributes.loadingImage=data-loading-image] - A custom name for the attribute to be used to set a loading image.
     * @param {object} [options.helpers.html.attributes.errorImage=data-error-image] - A custom name for the attribute to be used to set an error image.
     * @param {object} [options.helpers.html.attributes.dpi=data-dpi] - A custom name for the attribute to be used to specify DPI settings.
     * @param {object} [options.helpers.html.attributes.imageSource=data-src] - A custom name for the attribute to be used to set the image source.
     * @param {object} [options.helpers.html.attributes.fileSource=data-href] - A custom name for the attribute to be used to set the anchor source.
     * @param {object} [options.helpers.html.attributes.enableOffline=data-offline] - A custom name for the attribute to be used to control offline processing.
     * @param {object} [options.helpers.html.attributes.enableResponsive=data-responsive] - A custom name for the attribute to be used to control Responsive Images processing.
     */
    function Everlive(options) {
        var self = this;
        this.setup = new Setup(options);
        _.each(initializations, function (init) {
            init.func.call(self, options);
        });

        if (Everlive.$ === null) {
            Everlive.$ = self;
        }

        EventEmitterProxy.apply(this);
    }

    /**
     * Adds an event listener to the SDK.
     * @method addListener
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Adds an event listener to the SDK.
     * @method on
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes an SDK event listener.
     * @method removeListener
     * @param {String} eventName The name of the event for which to stop listening.
     * @param {Function} eventListener The event listener to remove.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes an SDK event listener.
     * @method off
     * @param {Function} eventListener
     * @memberOf Everlive.prototype
     */

    /**
     * Adds an event listener to the SDK which will be called only the first time the event is emitted.
     * @method once
     * @param {String} eventName The name of the event to which to subscribe.
     * @param {Function} eventListener An event listener which will be called once the event is raised.
     * @memberOf Everlive.prototype
     */

    /**
     * Removes all SDK event listeners.
     * @memberOf Everlive.prototype
     * @method removeAllListeners
     */

    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Everlive}
     * @static
     */
    Everlive.$ = null;
    Everlive.idField = constants.idField;


    // An array keeping initialization functions called by the Everlive constructor.
    // These functions will be used to extend the functionality of an Everlive instance.
    var initializations = [];

    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Function[]}
     * @static
     * @private
     */
    Everlive.initializations = initializations;

    Everlive.init = function (options) {
        Everlive.$ = null;
        return new Everlive(options);
    };

    /**
     * Creates a new {@link Data} class.
     * @memberOf Everlive.prototype
     * @instance
     * @param {String} collectionName The name of the collection to be used.
     * @returns {Data}
     */
    Everlive.prototype.data = function (collectionName) {
        return new Data(this.setup, collectionName, this.offlineStorage, this);
    };

    /**
     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
     * @memberOf Everlive.prototype
     * @method buildUrl
     * @returns {string} The generated URL.
     */
    Everlive.prototype.buildUrl = function () {
        return utils.buildUrl(this.setup);
    };

    /**
     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
     * @memberOf Everlive
     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
     */
    Everlive.prototype.buildAuthHeader = function () {
        return buildAuthHeader(this.setup);
    };

    Everlive.disableRequestCache = utils.disableRequestCache;

    Everlive.AuthStatus = constants.AuthStatus;

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @deprecated
     * @see {@link Authentication.getAuthenticationStatus}
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @deprecated
     * @see {@link Authentication.getAuthenticationStatus}
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Everlive.prototype.authInfo = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self.setup;
            if (setup.masterKey) {
                return success({status: Everlive.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: Everlive.AuthStatus.unauthenticated});
            }

            if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                return success({status: Everlive.AuthStatus.authenticating});
            }

            self.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: Everlive.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                        return success({status: Everlive.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.expiredToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: Everlive.AuthStatus.invalidAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /**
     * Make a request to the current {{site.bs}} JavaScript SDK instance.
     * @method request
     * @memberOf Everlive.prototype
     * @param {object} options Object used to configure the request.
     * @param {object} [options.endpoint] The endpoint of the {{site.bs}} JavaScript API relative to the API key section. (For example, options.endpoint = MyType will make a request to the MyType type.)
     * @param {HttpMethod} [options.method] HTTP request method.
     * @param {object} [options.data] Data to be sent with the request.
     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
     * @param {Function} [options.error] Error callback to be called in case of an error.
     * @param {object} [options.headers] Additional headers to be included in the request.
     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter]({% slug rest-api-querying-filtering %}) expression.
     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
     * @returns {function} The request configuration object containing the `send` function that sends the request.
     */
    Everlive.prototype.request = function (options) {
        return new Request(this.setup, options);
    };

    function protectOfflineEnabled() {
        if (!this._isOfflineStorageEnabled()) {
            throw new EverliveError('You have instantiated the SDK without support for offline storage');
        }
    }

    Everlive.prototype._isOfflineStorageEnabled = function () {
        return !!this.setup.offlineStorage;
    };

    /**
     * Sets the SDK to work in offline mode.
     * @method offline
     * @memberOf Everlive.prototype
     * @param {boolean} [isOffline = true] Boolean parameter for setting the SDK to online or offline mode.
     */
    Everlive.prototype.offline = function () {
        protectOfflineEnabled.call(this);

        var isOffline;
        if (arguments.length === 0) {
            isOffline = true;
        } else {
            isOffline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(isOffline);
    };

    /**
     * Sets the SDK to work in online mode.
     * @method online
     * @memberOf Everlive.prototype
     * @param {boolean} [isOnline = true] Boolean parameter for setting the SDK to online or offline mode.
     */
    Everlive.prototype.online = function () {
        protectOfflineEnabled.call(this);

        var isOnline;
        if (arguments.length === 0) {
            isOnline = true;
        } else {
            isOnline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(!isOnline);
    };

    /**
     * Check if the SDK is in offline mode.
     * @method isOffline
     * @memberOf Everlive.prototype
     * @returns {boolean} Returns true if the SDK is in offline mode.
     */
    Everlive.prototype.isOffline = function () {
        protectOfflineEnabled.call(this);
        return !this.isOnline();
    };

    /**
     * Check if the SDK is in online mode.
     * @method isOnline
     * @memberOf Everlive.prototype
     * @returns {boolean} Returns true if the SDK is in online mode.
     */
    Everlive.prototype.isOnline = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.isOnline();
    };

    /**
     * Starts the synchronization procedure. Emits the 'syncStart' event when started and the 'syncEnd' event when the procedure finishes. 'syncEnd' contains information about the completed sync operation that you can use to find out how many items were synchronized.
     * @method sync
     * @memberOf Everlive.prototype
     */
    Everlive.prototype.sync = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.sync.apply(this.offlineStorage, arguments);
    };

    var initDefault = function initDefault() {
        var users = this.data('Users');
        usersModule.addUsersFunctions(users, this);

        /**
         * @memberOf Everlive
         * @instance
         * @deprecated
         * @see {@link Everlive.users}
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} Users
         */
        this.Users = users;

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} users
         */
        this.users = users;

        var files = this.data('Files');
        filesModule.addFilesFunctions(files);

        /**
         * @memberOf Everlive
         * @instance
         * @deprecated Use everlive.files instead
         * @see {@link Everlive.files}
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} Files
         */
        this.Files = files;

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} files
         */
        this.files = files;

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Push]{@link Push} class for working with push notifications.
         * @member {Push} push
         */
        this.push = new Push(this);
    };

    var initAuthentication = function initAuthentication() {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
         * @member {Authentication} authentication
         */
        this.authentication = new Authentication(this, this.setup.authentication);
    };

    var initializeHelpers = function initializeHelpers(options) {
        var self = this;
        self.helpers = {};

        _.each(helpers, function (helper) {
            var helperOptions = options.helpers ? options.helpers[helper.name] : null;
            self.helpers[helper.name] = new helper.ctor(self, helperOptions);
        });
    };

    initializations.push({name: 'offlineStorage', func: offlineModule.initOfflineStorage});
    initializations.push({name: 'default', func: initDefault});
    initializations.push({name: 'authentication', func: initAuthentication});
    initializations.push({name: 'helpers', func: initializeHelpers});


    return Everlive;
}());

},{"./EventEmitterProxy":37,"./EverliveError":39,"./Push":43,"./Request":44,"./Setup":45,"./auth/Authentication":46,"./common":48,"./constants":49,"./helpers/helpers":52,"./offline/offline":62,"./types/Data":79,"./types/Files":80,"./types/Users":81,"./utils":82}],39:[function(require,module,exports){
var EverliveErrors = {
    itemNotFound: {
        code: 801,
        message: 'Item not found.'
    },
    syncConflict: {
        code: 10001,
        message: 'A conflict occurred while syncing data.'
    },
    syncError: {
        code: 10002,
        message: 'Synchronization failed for item.'
    },
    syncInProgress: {
        code: 10003,
        message: 'Cannot perform operation while synchronization is in progress'
    },
    syncCancelledByUser: {
        code: 10004,
        message: 'Synchronization cancelled by user'
    },
    generalDatabaseError: {
        code: 107,
        message: 'General database error'
    },
    invalidToken: {
        code: 301,
        message: 'Invalid access token'
    },
    expiredToken: {
        code: 302,
        message: 'Expired access token'
    },
    invalidExpandExpression: {
        code: 618,
        message: 'Invalid expand expression.'
    },
    invalidRequest: {
        code: 601,
        message: 'Invalid request.'
    },
    missingContentType: {
        code: 701,
        message: 'ContentType not specified.'
    },
    missingOrInvalidFileContent: {
        code: 702,
        message: 'Missing or invalid file content.'
    },
    customFileSyncNotSupported: {
        code: 703,
        message: 'Custom ConflictResolution for files is not allowed'
    },
    cannotDownloadOffline: {
        code: 704,
        message: 'Cannot download a file while offline'
    }
};

var EverliveError = (function () {
    function EverliveError(message, code) {
        var tmpError = Error.apply(this);

        tmpError.message = message;
        tmpError.code = code || 0;
        tmpError.name = this.name = 'EverliveError';

        this.message = tmpError.message;
        this.code = code;

        Object.defineProperty(this, 'stack', {
            get: function () {
                return tmpError.stack
            }
        });

        return this;
    }

    EverliveError.prototype = Object.create(Error.prototype);
    EverliveError.prototype.toJSON = function () {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            stack: this.stack
        };
    };

    return EverliveError;
}());

var DeviceRegistrationError = (function () {
    var DeviceRegistrationError = function (errorType, message, additionalInformation) {
        EverliveError.call(this, message);
        this.errorType = errorType;
        this.message = message;
        if (additionalInformation !== undefined) {
            this.additionalInformation = additionalInformation;
        }
    };

    DeviceRegistrationError.prototype = Object.create(EverliveError.prototype);

    DeviceRegistrationError.fromEverliveError = function (everliveError) {
        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.EverliveError, everliveError.message, everliveError);
        return deviceRegistrationError;
    };

    DeviceRegistrationError.fromPluginError = function (errorObj) {
        var message = 'A plugin error occurred';
        if (errorObj) {
            if (typeof errorObj.error === 'string') {
                message = errorObj.error;
            } else if (typeof errorObj.message === 'string') {
                message = errorObj.message;
            }
        }

        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.PluginError, message, errorObj);
        return deviceRegistrationError;
    };

    var DeviceRegistrationErrorTypes = {
        EverliveError: 1,
        PluginError: 2
    };

    return DeviceRegistrationError;
}());

module.exports = {
    EverliveError: EverliveError,
    EverliveErrors: EverliveErrors,
    DeviceRegistrationError: DeviceRegistrationError
};
},{}],40:[function(require,module,exports){
var Processor = require('./common').Processor;
var DataQuery = require('./query/DataQuery');
var Query = require('./query/Query');
var EverliveError = require('./EverliveError').EverliveError;

module.exports = (function () {
    return new Processor({
        executionNodeFunction: function (node, expandContext, done) {
            var query = new DataQuery({
                operation: DataQuery.operations.read,
                collectionName: node.targetTypeName,
                filter: new Query(node.filter, node.select, node.sort, node.skip, node.take)
            });

            expandContext.offlineModule.processQuery(query).then(function (data) {
                done(null, data.result);
            }, done);
        }
    });
}());

},{"./EverliveError":39,"./common":48,"./query/DataQuery":68,"./query/Query":69}],41:[function(require,module,exports){
module.exports = (function () {
    function Expression(operator, operands) {
        this.operator = operator;
        this.operands = operands || [];
    }

    Expression.prototype = {
        addOperand: function (operand) {
            this.operands.push(operand);
        }
    };

    return Expression;
}());
},{}],42:[function(require,module,exports){
module.exports = (function () {
    //TODO add a function for calculating the distances in geospatial queries

    /**
     * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
     * @class GeoPoint
     * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
     * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
     */
    function GeoPoint(longitude, latitude) {
        this.longitude = longitude || 0;
        this.latitude = latitude || 0;
    }

    return GeoPoint;
}());
},{}],43:[function(require,module,exports){
var utils = require('./utils');
var buildPromise = utils.buildPromise;
var DeviceRegistrationResult = utils.DeviceRegistrationResult;
var everliveErrorModule = require('./EverliveError');
var DeviceRegistrationError = everliveErrorModule.DeviceRegistrationError;
var EverliveError = everliveErrorModule.EverliveError;
var CurrentDevice = require('./CurrentDevice');
var Platform = require('./constants').Platform;

module.exports = (function () {
    /**
     * @class Push
     * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
     * @protected
     * @param el {Everlive} Everlive Object
     */
    function Push(el) {
        this._el = el;
        this.notifications = el.data('Push/Notifications');
        this.devices = el.data('Push/Devices');
    }

    Push.prototype = {

        /**
         * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
         * @method ensurePushIsAvailable
         * @memberOf Push.prototype
         */
        ensurePushIsAvailable: function () {
            var isPushNotificationPluginAvailable = (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification);

            if (!isPushNotificationPluginAvailable) {
                throw new EverliveError("The push notification plugin is not available. Ensure that the pushNotification plugin is included " +
                "and use after `deviceready` event has been fired.");
            }
        },
        /**
         * Returns the current device for sending push notifications
         * @deprecated since version 1.2.7
         * @see [Push.register]{@link push.register}
         * @memberOf Push.prototype
         * @method currentDevice
         * @name currentDevice
         * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
         * @returns {CurrentDevice} Returns an instance of CurrentDevice.
         */
        currentDevice: function (emulatorMode) {
            this.ensurePushIsAvailable();

            if (arguments.length === 0) {
                emulatorMode = this._el.setup._emulatorMode;
            }

            if (!window.cordova) {
                throw new EverliveError('Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.');
            }

            if (!this._currentDevice) {
                this._currentDevice = new CurrentDevice(this);
            }

            this._currentDevice.emulatorMode = emulatorMode;

            return this._currentDevice;
        },

        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
         * @param {Object} settings.iOS=null iOS-specific settings.
         * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
         * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
         * @param {Object} settings.android=null Android-specific settings.
         * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings.
         * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
         * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
         * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
         * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
         * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * Telerik Backend Services if it hasn't already been registered.
         * If it was registered the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
         * @param {Object} settings.iOS=null iOS specific settings
         * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
         * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
         * @param {Object} settings.android=null Android specific settings
         * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings
         * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
         * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
         * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
         * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
         * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (settings, success, error) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            var self = this;
            settings = settings || {};

            if (settings.android) {
                settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
            }

            var successCallback = function (token, callback) {
                var result = new DeviceRegistrationResult(token);
                callback(result);
            };

            var errorCallback = function (err, callback) {
                var registrationError = DeviceRegistrationError.fromEverliveError(err);
                callback(registrationError);
            };

            var clearBadgeIfNeeded = function (token, successCb, errorCb) {
                var platformType = currentDevice._getPlatformType(device.platform);
                var clearBadge = platformType === Platform.iOS;

                if (clearBadge && settings.iOS) {
                    clearBadge = settings.iOS.clearBadge !== false;
                }

                if (clearBadge) {
                    self.clearBadgeNumber().then(function () {
                        successCallback(token, successCb);
                    }, function (err) {
                        errorCallback(err, errorCb);
                    });
                } else {
                    successCallback(token, successCb);
                }
            };

            return buildPromise(function (successCb, errorCb) {
                currentDevice.enableNotifications(settings, function (response) {
                    var token = response.token;
                    var customParameters = settings.customParameters;
                    currentDevice.getRegistration()
                        .then(function () {
                            currentDevice.updateRegistration(customParameters, function () {
                                clearBadgeIfNeeded(token, successCb, errorCb);
                            }, function (err) {
                                errorCallback(err, errorCb);
                            });
                        }, function (err) {
                            if (err.code === 801) { //Not registered
                                currentDevice.register(customParameters, function () {
                                    clearBadgeIfNeeded(token, successCb, errorCb);
                                }, errorCb);
                            } else {
                                errorCallback(err, errorCb);
                            }
                        });
                }, function (err) {
                    var deviceRegistrationError = DeviceRegistrationError.fromPluginError(err);
                    errorCb(deviceRegistrationError);
                });
            }, success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * This method invalidates any push tokens that were obtained for the device from the current application.
         * The device will also be unregistered from Telerik Backend Services.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        unregister: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.disableNotifications.apply(currentDevice, arguments);
        },

        /**
         * Updates the registration of the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.updateRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sets the badge number on the {{site.TelerikBackendServices}} server.
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the badge number on the server
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        setBadgeNumber: function (badge, onSuccess, onError) {
            this.ensurePushIsAvailable();

            badge = parseInt(badge);
            if (isNaN(badge)) {
                return buildPromise(function (success, error) {
                    error(new EverliveError('The badge must have a numeric value'));
                }, onSuccess, onError);
            }

            var deviceRegistration = {};
            var currentDevice = this.currentDevice();
            var deviceId = currentDevice._getDeviceId();
            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
            deviceRegistration.BadgeCounter = badge;
            return buildPromise(function (successCb, errorCb) {
                currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(
                    function () {
                        if (window.plugins && window.plugins.pushNotification) {
                            return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
                        } else {
                            return successCb();
                        }
                    }, errorCb)
            }, onSuccess, onError);
        },

        /**
         * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Clears the badge number on the server by setting it to 0
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        clearBadgeNumber: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.setBadgeNumber(0, onSuccess, onError);
        },

        /**
         * Returns the push notifications registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        getRegistration: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.getRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sends a push notification.
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @returns {Promise} The promise for request.
         */
        /**
         * Sends a push message
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        send: function (notification, onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.notifications.create.apply(this.notifications, arguments);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            this.ensurePushIsAvailable();

            options = options || {};
            var pushNotification = window.plugins.pushNotification;

            return buildPromise(function (successCb, errorCb) {
                pushNotification.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        }
    };

    return Push;
}());
},{"./CurrentDevice":36,"./EverliveError":39,"./constants":49,"./utils":82}],44:[function(require,module,exports){
var utils = require('./utils');
var rsvp = require('./common').rsvp;
var buildAuthHeader = utils.buildAuthHeader;
var parseUtilities = utils.parseUtilities;
var guardUnset = utils.guardUnset;
var common = require('./common');
var reqwest = common.reqwest;
var _ = common._;
var Headers = require('./constants').Headers;
var isNodejs = require('./everlive.platform').isNodejs;
var Query = require('./query/Query');

module.exports = (function () {
    var _self;

    // The Request type is an abstraction over Ajax libraries
    // A Request object needs information about the Everlive connection and initialization options

    function Request(setup, options) {
        guardUnset(setup, 'setup');
        guardUnset(options, 'options');
        this.setup = setup;
        this.method = null;
        this.endpoint = null;
        this.data = null;
        this.headers = {};
        // TODO success and error callbacks should be uniformed for all ajax libs
        this.success = null;
        this.error = null;
        this.parse = Request.parsers.simple;

        _.extend(this, options);
        _self = this;
        this._init(options);
    }

    Request.prototype = {
        // Calls the underlying Ajax library
        send: function () {
            Request.sendRequest(this);
        },
        // Returns an authorization header used by the request.
        // If there is a logged in user for the Everlive instance then her/his authentication will be used.
        buildAuthHeader: buildAuthHeader,
        // Builds the URL of the target Everlive service
        buildUrl: function buildUrl(setup) {
            return utils.buildUrl(setup);
        },
        // Processes the given query to return appropriate headers to be used by the request
        buildQueryHeaders: function buildQueryHeaders(query) {
            if (query) {
                if (query instanceof Query) {
                    return Request.prototype._buildQueryHeaders(query);
                }
                else {
                    return Request.prototype._buildFilterHeader(query);
                }
            }
            else {
                return {};
            }
        },
        // Initialize the Request object by using the passed options
        _init: function (options) {
            _.extend(this.headers, this.buildAuthHeader(this.setup, options), this.buildQueryHeaders(options.filter), options.headers);
        },
        // Translates an Everlive.Query to request headers
        _buildQueryHeaders: function (query) {
            query = query.build();
            var headers = {};
            if (query.$where !== null) {
                headers[Headers.filter] = JSON.stringify(query.$where);
            }
            if (query.$select !== null) {
                headers[Headers.select] = JSON.stringify(query.$select);
            }
            if (query.$sort !== null) {
                headers[Headers.sort] = JSON.stringify(query.$sort);
            }
            if (query.$skip !== null) {
                headers[Headers.skip] = query.$skip;
            }
            if (query.$take !== null) {
                headers[Headers.take] = query.$take;
            }
            if (query.$expand !== null) {
                headers[Headers.expand] = JSON.stringify(query.$expand);
            }
            return headers;
        },
        // Creates a header from a simple filter
        _buildFilterHeader: function (filter) {
            var headers = {};
            headers[Headers.filter] = JSON.stringify(filter);
            return headers;
        }
    };

    var parseOnlyCompleteDateTimeString = _self && _self.setup && _self.setup.parseOnlyCompleteDateTimeObjects;

    var reviver = parseUtilities.getReviver(parseOnlyCompleteDateTimeString);

    Request.parsers = {
        simple: {
            result: parseUtilities.parseResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        single: {
            result: parseUtilities.parseSingleResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        update: {
            result: parseUtilities.parseUpdateResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        }
    };

    // TODO built for request
    if (typeof Request.sendRequest === 'undefined') {
        Request.sendRequest = function (request) {
            var url = request.buildUrl(request.setup) + request.endpoint;
            url = utils.disableRequestCache(url, request.method);
            request.method = request.method || 'GET';
            var data = request.method === 'GET' ? request.data : JSON.stringify(request.data);

            var requestParams = {
                url: url,
                method: request.method,
                data: data,
                headers: request.headers,
                contentType: 'application/json'
            };

            if (isNodejs) {
                requestParams.success = function (data, response) {
                    request.success.call(request, request.parse.result(data), response);
                };

                requestParams.error = function (jqXHR) {
                    request.error.call(request, request.parse.error(jqXHR.responseText || jqXHR.statusText));
                };
            } else {
                requestParams.type = 'json';
                requestParams.crossOrigin = true;
                requestParams.success = function (data, textStatus, jqXHR) {
                    var result = request.parse.result(data);
                    request.success.call(request, result);
                };

                requestParams.error = function (jqXHR, textStatus, errorThrown) {
                    var error = request.parse.error(jqXHR.responseText || jqXHR.statusText);
                    request.error.call(request, error);
                };
            }

            reqwest(requestParams);
        };
    }

    return Request;
}());
},{"./common":48,"./constants":49,"./everlive.platform":51,"./query/Query":69,"./utils":82}],45:[function(require,module,exports){
var _ = require('./common')._;
var constants = require('./constants');
var AuthenticationSetup = require('./auth/AuthenticationSetup');

module.exports = (function () {
    var everliveUrl = constants.everliveUrl;

    // An object that keeps information about an Everlive connection
    function Setup(options) {
        this.url = everliveUrl;
        this.apiKey = null;
        this.masterKey = null;
        this.token = null;
        this.tokenType = null;
        this.principalId = null;
        this.scheme = 'http'; // http or https
        this.parseOnlyCompleteDateTimeObjects = false;
        if (typeof options === 'string') {
            this.apiKey = options;
        } else {
            this._emulatorMode = options.emulatorMode;
            _.extend(this, options);
        }

        this.authentication = new AuthenticationSetup(this, options.authentication);
    }

    Setup.prototype.setAuthorizationProperties = function (token, tokenType, principalId) {
        this.token = token;
        this.tokenType = tokenType;
        this.principalId = principalId;
    };

    Setup.prototype.getAuthorizationProperties = function () {
        return {
            token: this.token,
            tokenType: this.tokenType,
            principalId: this.principalId
        };
    };

    return Setup;

}());
},{"./auth/AuthenticationSetup":47,"./common":48,"./constants":49}],46:[function(require,module,exports){
'use strict';
var utils = require('../utils');
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var Everlive = require('../Everlive');
var constants = require('../constants');
var usersCollectionName = 'Users';
var buildPromise = utils.buildPromise;
var LocalStore = require('../storages/LocalStore');
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports = (function () {
    /**
     * @class Authentication
     * @classdesc A class for managing authentication of a user in your application.
     * @protected
     * @param el {Everlive} Everlive Object
     * @param setup {AuthSetup} the authentication setup object
     */
    var Authentication = function (el, setup) {
        this.authSetup = setup || {};
        this._el = el;
        this._authenticationCallbacks = null;
        if (this.authSetup.persist) {
            this._localStore = new LocalStore(el);
            var localStoreKey = this._getLocalStoreKey();
            var authOptions = this._localStore.getItem(localStoreKey);
            var authInfo;
            if (authOptions) {
                authInfo = JSON.parse(this._localStore.getItem(localStoreKey));
            }
            if (authInfo) {
                this._el.setup.setAuthorizationProperties(authInfo.token, authInfo.tokenType, authInfo.principalId);
            }
        }
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.login = function (username, password, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogin,
                collectionName: usersCollectionName,
                data: {
                    username: username,
                    password: password,
                    grant_type: 'password'
                },
                skipAuth: true,
                onSuccess: successFunc,
                onError: error
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.logout = function (success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._logoutSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var errorFunc = function (err) {
                if (err.code === 301) { //invalid token
                    self.clearAuthorization();
                }

                error.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogout,
                collectionName: usersCollectionName,
                skipAuth: true,
                onSuccess: successFunc,
                onError: errorFunc
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    Authentication.prototype._getLocalStoreKey = function () {
        return constants.AuthStoreKey + this._el.setup.apiKey + '$authentication';
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithFacebook = function (accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithADFS = function (accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithLiveID = function (accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithGoogle = function (accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithTwitter = function (token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Authentication.prototype
     * @method setAuthorization
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    Authentication.prototype.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        this._el.setup.setAuthorizationProperties(token, tokenType, principalId);

        if (this.authSetup.persist) {
            var localStoreKey = this._getLocalStoreKey();
            var authorizationProperties = this._el.setup.getAuthorizationProperties();
            this._localStore.setItem(localStoreKey, JSON.stringify(authorizationProperties));
        }

        if (this._authenticationCallbacks) {
            this._authenticationCallbacks.success();
            this._authenticationCallbacks = null;
        }
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the authorization token that was used, will not be invalidated.
     * @method clearAuthorization
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearAuthorization = function clearAuthorization() {
        this.setAuthorization(null, null, null);
        this.clearPersistedAuthentication();
    };

    /**
     * Clears the current persisted authentication from the local store for the current {{site.bs}} JavaScript SDK instance. Will not logout or modify the current authentication of the Javascript SDK.
     * @method clearPersistedAuthentication
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearPersistedAuthentication = function () {
        if (this._localStore) {
            var localStoreKey = this._getLocalStoreKey();
            this._localStore.removeItem(localStoreKey);
            this._el.setup.setAuthorizationProperties(null, null, null);
        }
    };

    /**
     * @memberOf Authentication.prototype
     * Returns whether authentication requirement is enabled for the current instance of the {{site.bs}} JavaScript SDK.
     * @returns {boolean} whether an onAuthenticationRequired function is provided
     */
    Authentication.prototype.isAuthenticationInProgress = function () {
        return typeof this.authSetup.onAuthenticationRequired === 'function';
    };

    /** Ensures that authentication is completed before continuing.
     * @memberOf Authentication.prototype
     * @private
     * @returns {Promise} A promise that will be resolved when the authentication is complete. See {{@link Everlive.prototype.completeAuthentication}}.
     * @throws throws an error if no onAuthenticationRequired handler is provided to the setup.
     */
    Authentication.prototype._ensureAuthentication = function () {
        if (!this.isAuthenticationInProgress()) {
            throw new Error('onAuthenticationRequired option of Everlive.Setup.Authentication is required.');
        }
        if (this.isAuthenticating()) {
            return this._authenticationCallbacks.promise;
        }

        this.clearAuthorization();
        this.authSetup.onAuthenticationRequired.call(this);
        this._authenticationCallbacks = utils.getCallbacks();
        return this._authenticationCallbacks.promise;
    };

    /**
     * A method that should be called with the authentication result.
     * @memberOf Authentication.prototype
     * @param authentication authentication object containing information about the
     * @param authentication.access_token
     * @param authentication.token_type
     * @param authentication.principal_id
     */
    Authentication.prototype.completeAuthentication = function (authentication) {
        this._el.setAuthorization(authentication.access_token, authentication.token_type, authentication.principal_id);
    };
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @param {Everlive.Callbacks.authenticationStatusSuccess} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.getAuthenticationStatus = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self._el.setup;
            if (setup.masterKey) {
                return success({status: constants.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: constants.AuthStatus.unauthenticated});
            }

            if (self.isAuthenticationInProgress()) {
                return success({status: constants.AuthStatus.authenticating});
            }

            self._el.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: constants.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.isAuthenticationInProgress()) {
                        return success({status: constants.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.invalidToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: constants.AuthStatus.invalidAuthentication});
                    } else if (err.code === EverliveErrors.expiredToken.code) {
                        return success({status: constants.AuthStatus.expiredAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /** Returns whether the {{site.TelerikBackendServices}} is currently waiting for authentication to be completed. See {{@link Everlive.prototype.completeAuthentication}}.
     * @memberOf Everlive.prototype
     * @returns {boolean}
     */
    Authentication.prototype.isAuthenticating = function () {
        return !!this._authenticationCallbacks;
    };

    Authentication.prototype._loginSuccess = function (data) {
        var result = data.result;
        this.setAuthorization(result.access_token, result.token_type, result.principal_id);
    };

    Authentication.prototype._logoutSuccess = function () {
        this.clearAuthorization();
    };

    Authentication.prototype._loginWithProvider = function (identity, success, error) {
        var user = {
            Identity: identity
        };
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLoginWithProvider,
                collectionName: usersCollectionName,
                data: user,
                authHeaders: false,
                skipAuth: true,
                parse: Request.parsers.single,
                onSuccess: successFunc,
                onError: error
            });

            self._el.Users.processDataQuery(query);
        }, success, error);
    };

    return Authentication;
}());

},{"../Everlive":38,"../EverliveError":39,"../Request":44,"../constants":49,"../query/DataQuery":68,"../storages/LocalStore":76,"../utils":82}],47:[function(require,module,exports){
'use strict';
module.exports = (function () {
    var AuthenticationSetup = function (everlive, options) {
        options = options || {};
        this.onAuthenticationRequired = options.onAuthenticationRequired;
        this.persist = options.persist;
    };

    return AuthenticationSetup;
}());
},{}],48:[function(require,module,exports){
(function (global){
module.exports = (function () {
    var common = {};
    var dependencyStore = {};

    var platform = require('./everlive.platform');
    var isNativeScript = platform.isNativeScript;
    var isNodejs = platform.isNodejs;

    if (!isNodejs && !isNativeScript) {
        dependencyStore.reqwest = require('reqwest');
    } else if (isNativeScript) {
        common.root = global;
        dependencyStore.reqwest = require('./reqwest.nativescript');
    } else if (isNodejs) {
        common.root = global;
        dependencyStore.reqwest = require('./reqwest.nodejs');
    }

    if (!common.root) {
        //browser/requirejs/cordova
        common.root = window;
    }

    var exportDependency = function exportDependency(globalName, localName) {
        if (!localName) {
            localName = globalName;
        }

        //for the everlive bundle without dependencies included, browserify replaces them with empty objects
        //we need to make sure that these dependencies are marked as undefined
        if (dependencyStore[localName] &&
            typeof dependencyStore[localName] === 'object' &&
            !Object.keys(dependencyStore[localName]).length) {

            dependencyStore[localName] = undefined;
        }

        Object.defineProperty(common, localName, {
            get: function () {
                return dependencyStore[localName] || this.root[globalName];
            }
        });
    };

    dependencyStore._ = require('underscore');
    exportDependency('_');

    dependencyStore.jstz = require('jstimezonedetect').jstz;
    exportDependency('jstz');

    dependencyStore.mongoQuery = require('mongo-query');
    exportDependency('mongoQuery');

    dependencyStore.Mingo = require('mingo');
    exportDependency('Mingo');

    dependencyStore.Processor = require('../scripts/bs-expand-processor');
    exportDependency('Processor');

    dependencyStore.Base64 = require('Base64');
    exportDependency('Base64');

    dependencyStore.rsvp = require('rsvp');
    exportDependency('RSVP', 'rsvp');

    exportDependency('reqwest');

    return common;
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../scripts/bs-expand-processor":32,"./everlive.platform":51,"./reqwest.nativescript":73,"./reqwest.nodejs":74,"Base64":1,"jstimezonedetect":2,"mingo":2,"mongo-query":10,"reqwest":2,"rsvp":2,"underscore":2}],49:[function(require,module,exports){
/**
 * Constants used by the SDK
 * @typedef {Object} Everlive.Constants
 */

var constants = {
    idField: 'Id',
    guidEmpty: '00000000-0000-0000-0000-000000000000',
    everliveUrl: '//api.everlive.com/v1/',
    /**
     * A class used to represent the conflict resolution strategies.
     * @property {string} ClientWins
     * @property {string} ServerWins
     * @property {string} Custom
     * @typedef {string} Everlive.Constants.ConflictResolutionStrategy
     */
    ConflictResolutionStrategy: {
        ClientWins: 'clientWins',
        ServerWins: 'serverWins',
        Custom: 'custom'
    },
    ConflictResolution: {
        KeepServer: 'keepServer',
        KeepClient: 'keepClient',
        Custom: 'custom',
        Skip: 'skip'
    },
    /**
     * A class used to represent the available storage providers.
     * @property {string} LocalStorage
     * @property {string} FileSystem
     * @property {string} Custom
     * @typedef {string} Everlive.Constants.StorageProvider
     */
    StorageProvider: {
        LocalStorage: 'localStorage',
        FileSystem: 'fileSystem',
        Custom: 'custom'
    },

    DefaultStoragePath: 'el_store',

    // the default location for storing files offline
    DefaultFilesStoragePath: 'el_file_store/',

    // the default location for storing offline to online location map
    DefaultFilesMetadataPath: 'el_file_mapping/',

    EncryptionProvider: {
        Default: 'default',
        Custom: 'custom'
    },

    // The headers used by the Everlive services
    Headers: {
        filter: 'X-Everlive-Filter',
        select: 'X-Everlive-Fields',
        sort: 'X-Everlive-Sort',
        skip: 'X-Everlive-Skip',
        take: 'X-Everlive-Take',
        expand: 'X-Everlive-Expand',
        singleField: 'X-Everlive-Single-Field',
        includeCount: 'X-Everlive-Include-Count',
        powerFields: 'X-Everlive-Power-Fields',
        debug: 'X-Everlive-Debug',
        overrideSystemFields: 'X-Everlive-Override-System-Fields'
    },
    //Constants for different platforms in Everlive
    Platform: {
        WindowsPhone: 1,
        Windows: 2,
        Android: 3,
        iOS: 4,
        OSX: 5,
        Blackberry: 6,
        Nokia: 7,
        Unknown: 100
    },
    OperatorType: {
        query: 1,

        where: 100,
        filter: 101,

        and: 110,
        or: 111,
        not: 112,

        equal: 120,
        not_equal: 121,
        lt: 122,
        lte: 123,
        gt: 124,
        gte: 125,
        isin: 126,
        notin: 127,
        all: 128,
        size: 129,
        regex: 130,
        contains: 131,
        startsWith: 132,
        endsWith: 133,

        nearShpere: 140,
        withinBox: 141,
        withinPolygon: 142,
        withinShpere: 143,

        select: 200,
        exclude: 201,

        order: 300,
        order_desc: 301,

        skip: 400,
        take: 401,
        expand: 402
    },

    /**
     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @property {string} unauthenticated Indicates that no user is authenticated.
     * @property {string} masterKey Indicates that a master key authentication is used.
     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
     * @property {string} authenticated Indicates that a user is authenticated.
     * @property {string} authenticating Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @property {string} expiredAuthentication Indicates that a user's authentication has expired and that the user must log back in.
     * @typedef {string} Everlive.AuthStatus
     */
    AuthStatus: {
        unauthenticated: 'unauthenticated',
        masterKey: 'masterKey',
        invalidAuthentication: 'invalidAuthentication',
        authenticated: 'authenticated',
        expiredAuthentication: 'expiredAuthentication',
        authenticating: 'authenticating'
    },
    offlineItemStates: {
        created: 'create',
        modified: 'update',
        deleted: 'delete'
    },

    /**
     * HTTP Methods
     * @enum {string}
     */
    HttpMethod: {
        GET: 'GET',
        POST: 'POST',
        PUT: 'PUT',
        DELETE: 'DELETE'
    },
    maxDistanceConsts: {
        radians: '$maxDistance',
        km: '$maxDistanceInKilometers',
        miles: '$maxDistanceInMiles'
    },
    radiusConsts: {
        radians: 'radius',
        km: 'radiusInKilometers',
        miles: 'radiusInMiles'
    }
};

// using an invalid field name in the context of Everlive
// to ensure no naming collisions can occur
constants.offlineItemsStateMarker = '__everlive_offline_state';

constants.SyncErrors = {
    generalError: 'generalError',
    itemSyncError: 'itemSyncError'
};

constants.syncBatchSize = 10;

constants.AuthStoreKey = '__everlive_auth_key';

// the minimum interval between sync requests
constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes
constants.fileUploadKey = 'fileUpload';
constants.fileUploadDelimiter = '_';

module.exports = constants;

},{}],50:[function(require,module,exports){
var CryptoJS = require('node-cryptojs-aes').CryptoJS;
var AES = CryptoJS.AES;

module.exports = (function () {

    function CryptographicProvider(options) {
        this.options = options;
    }

    CryptographicProvider.prototype = {
        _getKey: function () {
            return this.options.encryption.key;
        },

        _canEncryptDecrypt: function (content) {
            return this._getKey() && content !== null && content !== undefined;
        },

        encrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.encrypt(content, this._getKey()).toString();
        },

        decrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.decrypt(content, this._getKey()).toString(CryptoJS.enc.Utf8);
        }
    };

    return CryptographicProvider;
}());
},{"node-cryptojs-aes":21}],51:[function(require,module,exports){
(function (global){
var isNativeScript = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
    || (typeof UIButton !== 'undefined' && UIButton)));

if (isNativeScript) {
    global.window = {
            localStorage: {
                removeItem: function () { } //shim for mongo-query under nativescript
            }
        };
} else if (typeof window !== 'undefined') {
    var isCordova = /^file:\/{3}[^\/]|x-wmapp/i.test(window.location.href) && /ios|iphone|ipod|ipad|android|iemobile/i.test(navigator.userAgent);
    var isWindowsPhone = isCordova && /iemobile/i.test(navigator.userAgent);
    var isAndroid = isCordova && cordova.platformId === 'android';
}

var isNodejs = typeof exports === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;
var isDesktop = !isNativeScript && !isCordova && !isNodejs;

module.exports = {
    isCordova: isCordova,
    isNativeScript: isNativeScript,
    isDesktop: isDesktop,
    isWindowsPhone: isWindowsPhone,
    isAndroid: isAndroid,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],52:[function(require,module,exports){
'use strict';

/**
 * @class Helpers
 * @classdesc Everlive helper classes
 */

var platform = require('../everlive.platform');

var helpers = [];

var htmlHelper = require('./html/htmlHelper');

if (platform.isCordova || platform.isDesktop) {
    helpers.push({
        name: 'html',
        ctor: htmlHelper
    });
}

module.exports = helpers;
},{"../everlive.platform":51,"./html/htmlHelper":53}],53:[function(require,module,exports){
'use strict';

var platform = require('../../everlive.platform');
var common = require('../../common');
var _ = common._;
var utils = require('../../utils');
var rsvp = common.rsvp;
var HtmlHelperResponsiveModule = require('./htmlHelperResponsiveModule');
var HtmlHelperOfflineModule = require('./htmlHelperOfflineModule');
var constants = require('../../constants');
var EverliveError = require('../../EverliveError').EverliveError;
var EventEmitterProxy = require('../../EventEmitterProxy');

module.exports = (function () {
    var defaults = {
        processOnLoad: false,
        processOnResize: false,
        loadingImageUrl: '',
        errorImageUrl: '',
        attributes: {
            loadingImage: 'data-loading-image',
            errorImage: 'data-error-image',
            dpi: 'data-dpi',
            imageSource: 'data-src',
            fileSource: 'data-href',
            enableOffline: 'data-offline',
            enableResponsive: 'data-responsive'
        }
    };

    /**
     * @typedef Helpers.html
     * @description Everlive helper for html related operations, such as processing html elements with specific tags.
     */

    function HtmlHelper(everlive, config) {
        EventEmitterProxy.apply(this);

        this._everlive = everlive;
        this._settings = {
            urlTemplate: '[protocol][hostname][apikey]/[operations][url]',
            server: 'bs1.cdn.telerik.com/image/v1/'
        };

        config = config || {};

        this.options = _.extend({}, defaults, config);
        this.options.attributes = _.extend({}, defaults.attributes, config.attributes);

        this._responsive = new HtmlHelperResponsiveModule(this);
        this._offline = new HtmlHelperOfflineModule(this);

        this._init();
    }

    HtmlHelper.prototype = {
        _init: function _init() {
            var self = this;
            if (self.options.processOnLoad) {
                window.addEventListener('load', this.processAll.bind(this), false);
            }

            if (this.options.processOnResize) {
                window.addEventListener('resize', _.debounce(this.processAll.bind(this), 300), false);
            }
        },

        _triggerOnProcessed: function _triggerOnProcessed(args) {
            this._emitter.emit('processed', args);
        },

        _defaultProcessSettings: function _defaultProcessSettings(settings) {
            return _.defaults({}, settings, {
                responsive: true,
                offline: true
            });
        },

        _setLoadingUrl: function _setLoadingUrl(element) {
            var loadingImageUri = element.getAttribute(this.options.attributes.loadingImage) || this.options.loadingImageUrl;
            if (!loadingImageUri || utils.isElement.anchor(element)) {
                return utils.successfulPromise();
            }

            return this._setUrl(element, loadingImageUri, true);
        },

        _getBackgroundSrc: function _getBackgroundSrc(el) {
            var elStyle = window.getComputedStyle(el, null);
            var backgrImage = elStyle.getPropertyValue('background-image');

            var img = backgrImage !== 'none' ? backgrImage : false;
            if (img) {
                img = img.replace(/url\(('?"?)(.*?)\1\)/gi, '$2');
            }

            return img;
        },

        _setErrorUrl: function (element) {
            var errorImageUrl = element.getAttribute(this.options.attributes.errorImage) || this.options.errorImageUrl;
            if (!errorImageUrl || utils.isElement.anchor(element)) {
                return utils.successfulPromise();
            }

            return this._setUrl(element, errorImageUrl, true);
        },

        _setUrl: function _setUrl(element, url, apply) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                var elAttr = self._getAttr(element);
                if (utils.isElement.image(element) && elAttr === self.options.attributes.imageSource) {
                    if (apply) {
                        element.src = url;
                        element.style.visibility = 'visible';
                    } else {
                        var img = new Image();

                        img.onerror = function () {
                            img = null;
                            reject(new EverliveError('Can\'t be loaded: ' + url));
                        };

                        img.onload = function () {
                            img = null;
                            self._setUrl(element, url, true)
                                .then(resolve)
                                .catch(reject);
                        };

                        img.src = url;
                    }
                } else {
                    apply = true;
                    if (elAttr) {
                        var attr;
                        if (elAttr === self.options.attributes.imageSource) {
                            attr = 'src';
                        } else if (elAttr === self.options.attributes.fileSource) {
                            attr = 'href';
                        } else {
                            attr = _.last(elAttr.split('-'));
                        }

                        element.setAttribute(attr, url);
                    } else {
                        element.style.backgroundImage = 'url(' + url + ')';
                    }
                }

                if (apply) {
                    resolve();
                }
            });
        },

        _getAttr: function _getAttr(element) {
            if (element.getAttribute(this.options.attributes.imageSource)) {
                return this.options.attributes.imageSource;
            }

            if (element.getAttribute(this.options.attributes.fileSource)) {
                return this.options.attributes.fileSource;
            }
        },

        _getUrl: function _getUrl(element) {
            var url = element.getAttribute(this.options.attributes.imageSource)
                || element.getAttribute(this.options.attributes.fileSource)
                || this._getBackgroundSrc(element);

            return url;
        },

        _wrapElements: function _wrapElements(elements) {
            var self = this;

            var results = _.map(elements, function (element) {
                var tag = element.tagName.toLowerCase();

                var evaluateDataAttr = function evaluateDataAttr(attr) {
                    // data-a - true
                    // data-a="" - true
                    // data-a="true" - true
                    // data-a="anything" - true
                    // data-a="false" - false
                    // missing - false
                    var val;
                    var dataVal = (element.attributes[attr] || {value: null}).value;
                    if (dataVal === '') {
                        val = true;
                    } else if (!dataVal) {
                        val = false;
                    } else {
                        try {
                            val = JSON.parse(dataVal);
                        } catch (e) {
                            val = true;
                        }
                    }

                    return val;
                };

                var canResponsive = evaluateDataAttr(self.options.attributes.enableResponsive);
                var canOffline = evaluateDataAttr(self.options.attributes.enableOffline);

                return {
                    item: element,
                    tag: tag,
                    operations: {
                        responsive: canResponsive,
                        offline: canOffline
                    }
                };
            });

            return results;
        },

        /**
         * @method process
         * @memberOf Helpers.html
         * @param {HtmlElement|HtmlElement[]} elements
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */

        /**
         * @method process
         * @memberOf Helpers.html
         * @param {HtmlElement|HtmlElement[]} elements
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @returns {Promise} A promise to the process state.
         */
        process: function process(elements, settings, success, error) {
            var self = this;

            return utils.buildPromise(function (resolve) {
                settings = self._defaultProcessSettings(settings);
                if (_.isArray(elements) || elements instanceof NodeList || elements.length) {
                    elements = _.flatten(elements);
                } else {
                    elements = [elements];
                }

                var wrappedElements = self._wrapElements(elements);
                var promises = [];
                _.each(wrappedElements, function (element) {
                    var result = {
                        element: element.item,
                        responsive: false,
                        offline: false
                    };

                    var dataUrl = self._getUrl(result.element);

                    if (!dataUrl) {
                        return promises.push(utils.successfulPromise(result));
                    }

                    var canResponsive = settings.responsive ? element.operations.responsive : false;
                    var canOffline = settings.offline ? element.operations.offline : false;

                    if (!canResponsive && !canOffline) {
                        return promises.push(self._setUrl(result.element, dataUrl, true)
                            .then(function () {
                                return result;
                            }));
                    }

                    var promise = self._setLoadingUrl(result.element);
                    var handleOperation = function handleOperation(operation, url) {
                        if (url) {
                            result[operation] = true;
                            return url;
                        }
                    };

                    if (canResponsive) {
                        promise = promise.then(function () {
                            return self._responsive.responsiveImage(element, dataUrl)
                                .then(handleOperation.bind(this, 'responsive'));
                        });
                    }

                    if (canOffline) {
                        promise = promise.then(function (responsiveSrc) {
                            return self._offline.processOffline(responsiveSrc || dataUrl)
                                .then(handleOperation.bind(this, 'offline'));
                        });
                    }

                    promise = promise.then(function (finalUrl) {
                        return self._setUrl(result.element, finalUrl)
                            .then(function () {
                                return result;
                            });
                    }).catch(function (err) {
                        return self._setErrorUrl(result.element)
                            .then(function () {
                                throw {
                                    element: result.element,
                                    error: err
                                }
                            });
                    });

                    promises.push(promise);
                });

                rsvp.allSettled(promises)
                    .then(function (results) {
                        var processed = [];
                        var failed = [];

                        _.each(results, function (result) {
                            if (result.state === 'fulfilled') {
                                processed.push(result.value);
                            } else {
                                failed.push(result.reason);
                            }
                        });

                        var result = {
                            processed: processed,
                            failed: failed
                        };

                        self._triggerOnProcessed(result);
                        resolve(result);
                    });
            }, success, error);
        },

        /**
         * @method processAll
         * @memberOf Helpers.html
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */

        /**
         * @method processAll
         * @memberOf Helpers.html
         * @param {Object} settings A settings specifying custom behavior.
         * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
         * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
         * @returns {Promise} A promise to the process state.
         */
        processAll: function processAll(settings, success, error) {
            settings = this._defaultProcessSettings(settings);
            var responsiveSelector = '[' + this.options.attributes.enableResponsive + ']';
            var offlineSelector = '[' + this.options.attributes.enableOffline + ']';

            var responsiveElements = [];
            if (settings.responsive) {
                responsiveElements = document.querySelectorAll(responsiveSelector);
            }

            var offlineElements = [];
            if (settings.offline) {
                offlineElements = document.querySelectorAll(offlineSelector);
            }

            var slice = [].slice;
            var elements = _.unique(slice.call(responsiveElements).concat(slice.call(offlineElements)));


            return this.process(elements, settings, success, error);
        }
    };

    return HtmlHelper;
}());

},{"../../EventEmitterProxy":37,"../../EverliveError":39,"../../common":48,"../../constants":49,"../../everlive.platform":51,"../../utils":82,"./htmlHelperOfflineModule":54,"./htmlHelperResponsiveModule":55}],54:[function(require,module,exports){
'use strict';

var utils = require('../../utils');
var EverliveErrorModule = require('../../EverliveError');
var EverliveErrors = EverliveErrorModule.EverliveErrors;
var EverliveError = EverliveErrorModule.EverliveError;
var constants = require('../../constants');
var path = require('path');
var common = require('../../common');
var _ = common._;

module.exports = (function () {
    function HtmlHelperOfflineModule(htmlHelper) {
        this.htmlHelper = htmlHelper;
    }

    HtmlHelperOfflineModule.prototype = {
        processOffline: function (url) {
            var self = this;

            if (!self.htmlHelper._everlive.offlineStorage.files) {
                return utils.rejectedPromise(new EverliveError('Offline storage must be enabled in order to use the offline features of the images component.'));
            }

            return self.htmlHelper._everlive.offlineStorage.files.downloadOffline(url)
                .then(function (localUrl) {
                    return localUrl;
                })
                .catch(function (err) {
                    if (err !== EverliveErrors.cannotDownloadOffline) {
                        throw err;
                    }

                    return self.htmlHelper._everlive.offlineStorage._offlineFilesProcessor
                        .getOfflineFilesData()
                        .then(function (offlineFilesData) {
                            var basename = path.basename(url);
                            var oldFile = _.find(offlineFilesData, function (entry) {
                                if (entry.onlineLocation && entry.offlineLocation) {
                                    var onlineLocation = entry.onlineLocation;
                                    var basenameIndex = onlineLocation.lastIndexOf(basename);
                                    return basenameIndex !== -1;
                                }
                            });

                            if (oldFile) {
                                return oldFile.offlineLocation;
                            }

                            throw new EverliveError('Cannot find offline image ' + url, EverliveErrors.missingOrInvalidFileContent.code);
                        });
                });
        }
    };

    return HtmlHelperOfflineModule;
}());
},{"../../EverliveError":39,"../../common":48,"../../constants":49,"../../utils":82,"path":5}],55:[function(require,module,exports){
'use strict';

var common = require('../../common');
var _ = common._;
var rsvp = common.rsvp;
var EverliveError = require('../../EverliveError').EverliveError;
var constants = require('../../constants');
var utils = require('../../utils');

module.exports = (function () {
    function HtmlHelperResponsiveModule(htmlHelper) {
        this.htmlHelper = htmlHelper;
    }

    HtmlHelperResponsiveModule.prototype = {
        getBackgroundWidth: function getBackgroundWidth(el) {
            return Math.ceil(el.offsetWidth);
        },

        parseParamsString: function parseParamsString(str) {
            if (!str || typeof str === 'undefined' || str.length <= 1) {
                return false;
            }

            var isUserResize = false;
            var params = [];
            var tmp = str.split('/');
            var ii = tmp.length;

            for (var i = 0; i < ii; i++) {
                var item = tmp[i].split('='),
                    tmpObj = {};
                if (typeof item[1] === 'undefined') {
                    item[1] = false;
                } else {
                    item[1] = unescape(item[1].replace(/\+/g, ' '));
                }

                tmpObj[item[0]] = item[1];
                params.push(tmpObj);
                if (item[0] === 'resize') {
                    isUserResize = true;
                }
            }
            return {
                params: params,
                isUserResize: isUserResize
            };
        },

        getImgParams: function getImgParams(src) {
            var operations;
            var imgUrl = src.replace(/.*?resize=[^//]*\//gi, '');
            var protocolRe = new RegExp('https?://', 'gi');
            var serverRe = new RegExp(this.htmlHelper._settings.server, 'gi');
            var apiKeyRe = new RegExp(this.htmlHelper._everlive.apiKey + '/', 'gi');

            operations = src.replace(imgUrl, '').replace(protocolRe, '').replace(serverRe, '').replace(apiKeyRe, '').toLowerCase();
            if (operations !== '') {
                operations = operations.indexOf('/') ? operations.substring(0, operations.length - 1) : operations;
            } else {
                operations = false;
            }

            operations = this.parseParamsString(operations);
            // If it's a user resize operation, use the passed url in the data-src property
            if (operations.isUserResize) {
                imgUrl = src;
            }

            return {
                imgUrl: imgUrl,
                operations: operations.params,
                isUserResize: operations.isUserResize
            };
        },

        hasClass: function hasClass(el, cl) {
            var regex = new RegExp('(?:\\s|^)' + cl + '(?:\\s|$)');
            return !!el.className.match(regex);
        },

        getImageWidth: function getImageWidth(el) {
            var parentEl = el.parentNode;
            var parentWidth = parentEl.offsetWidth;
            var itemStyle = window.getComputedStyle(parentEl, null);
            var pl = parseFloat(itemStyle.getPropertyValue('padding-left'));
            var pr = parseFloat(itemStyle.getPropertyValue('padding-right'));
            var bl = parseFloat(itemStyle.getPropertyValue('border-left-width'));
            var br = parseFloat(itemStyle.getPropertyValue('border-right-width'));

            return Math.abs(parentWidth - Math.ceil(pl + pr + bl + br));
        },

        getDevicePixelRatio: function getDevicePixelRatio() {
            return window.devicePixelRatio ? window.devicePixelRatio : 1;
        },

        getPixelRatio:function getPixelRatio(el) {
            var pixelDensity = el.getAttribute(this.htmlHelper.options.attributes.dpi) || '';
            return pixelDensity !== '' ? _.isNumber(pixelDensity) ? parseFloat(pixelDensity) : false : this.getDevicePixelRatio();
        },

        getImgParamsString: function getImgParamsString(image, params) {
            var paramsStr = '';
            var i = 0;
            var ii = params.length;
            for (; i < ii; i++) {
                var item = params[i];
                var key = _.keys(item)[0];
                var value;

                if (!utils.isElement.image(image) && key === 'resize') {
                    continue;
                }

                var pixelDensity = this.getPixelRatio(image.item);
                pixelDensity = (pixelDensity) ? ',pd:' + pixelDensity : '';
                for (var k in item) {
                    value = (key === 'resize') ? item[k] + pixelDensity : item[k];
                }

                paramsStr += key + '=' + value + '/';
            }

            return paramsStr;
        },

        responsiveImage: function responsiveImage(item, dataSrc) {
            var self = this;
            var image = _.extend({}, item);
            var element = image.item;
            var tag = image.tag;

            var isImage = utils.isElement.image(tag);
            var imgWidth;

            image = _.extend({}, image, self.getImgParams(dataSrc));

            if (!image.isUserResize) {
                imgWidth = (!isImage) ? self.getBackgroundWidth(element) : self.getImageWidth(element);
            }

            imgWidth = imgWidth ? imgWidth : false;
            var src = image.isUserResize ? image.imgUrl : self.getImgSrc(image, imgWidth);

            return new rsvp.Promise(function (resolve) {
                if (!imgWidth && !image.isUserResize) { // we don't have the width of the user image either.
                    // if this element is not visible, we don't have to process it.

                    return resolve();
                }

                return resolve(src);
            });
        },

        getImgSrc: function getImgSrc(image, imgWidth) {
            var protocol = this.htmlHelper._everlive.setup.scheme + '://';
            var apiKey = this.htmlHelper._everlive.setup.apiKey;
            var server = this.htmlHelper._settings.server;
            var url = this.htmlHelper._settings.urlTemplate;
            var pixelDensity = this.getPixelRatio(image.item);

            pixelDensity = pixelDensity ? ',pd:' + pixelDensity : '';

            url = url.replace('[protocol]', protocol);
            url = url.replace('[apikey]', apiKey ? apiKey : '');
            url = url.replace('[hostname]', server);

            var params = image.operations || false;
            if (params) {
                var operations = '';
                params = this.getImgParamsString(image, params);
                if (utils.isElement.image(image.tag)) {
                    operations = imgWidth ? 'resize=w:' + imgWidth + pixelDensity + '/' + params : params;
                } else {
                    operations = 'resize=w:' + imgWidth + pixelDensity + '/' + params;
                }
                url = url.replace('[operations]', operations);
            } else {
                url = url.replace('[operations]', 'resize=w:' + imgWidth + pixelDensity + '/');
            }

            url = url.replace('[url]', image.imgUrl);
            return url;
        }
    };

    return HtmlHelperResponsiveModule;
}());
},{"../../EverliveError":39,"../../common":48,"../../constants":49,"../../utils":82}],56:[function(require,module,exports){
/*!
 The MIT License (MIT)
 Copyright (c) 2013 Telerik AD
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.y distributed under the MIT license.
 */
/*!
 Everlive SDK
 Version 1.4.1
 */
(function () {
    var Everlive = require('./Everlive');
    var platform = require('./everlive.platform');
    var common = require('./common');

    if (!platform.isNativeScript && !platform.isNodejs) {
        var kendo = require('./kendo/kendo.everlive');
        Everlive.createDataSource = kendo.createDataSource;
        Everlive.createHierarchicalDataSource = kendo.createHierarchicalDataSource;
    }

    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
    Everlive.PushCallbacks = {};
    Everlive.Offline = {};

    Everlive.Query = require('./query/Query');
    Everlive.QueryBuilder = require('./query/QueryBuilder');
    Everlive.GeoPoint = require('./GeoPoint');
    Everlive.Constants = require('./constants');
    Everlive.Request = require('./Request');
    Everlive.Data = require('./types/Data');
    Everlive._utils = require('./utils');
    Everlive._traverseAndRevive = Everlive._utils.parseUtilities.traverseAndRevive;
    Everlive._common = require('./common');

    var persistersModule = require('./offline/offlinePersisters');
    Everlive.persister = {
        LocalStorage: persistersModule.LocalStoragePersister,
        FileSystem: persistersModule.FileSystemPersister
    };

    //everliveModule is provided by a closure generated during build
    if (platform.isNodejs || platform.isNativeScript) {
        if (typeof everliveModule !== 'undefined') {
            everliveModule.exports = Everlive;
        }

        if (typeof module !== 'undefined') {
            module.exports = Everlive;
        }
    } else {
        //in requirejs Everlive is defined in the same closure
        //browser
        common.root.Everlive = Everlive;
    }
}());
},{"./Everlive":38,"./GeoPoint":42,"./Request":44,"./common":48,"./constants":49,"./everlive.platform":51,"./kendo/kendo.everlive":57,"./offline/offlinePersisters":63,"./query/Query":69,"./query/QueryBuilder":70,"./types/Data":79,"./utils":82}],57:[function(require,module,exports){
var QueryBuilder = require('../query/QueryBuilder');
var Query = require('../query/Query');
var Request = require('../Request');
var constants = require('../constants');
var _ = require('../common')._;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;

(function () {
    'use strict';

    if (typeof window !== 'undefined' && typeof window.jQuery === 'undefined' || typeof window.kendo === 'undefined' || _.isEmpty(window.kendo.data)) {
        return;
    }

    var $ = window.jQuery;
    var kendo = window.kendo;

    var extend = $.extend;

    var everliveTransport = kendo.data.RemoteTransport.extend({
        init: function (options) {
            this.everlive$ = options.dataProvider || Everlive.$;
            if (!this.everlive$) {
                throw new Error('An instance of the Backend services sdk must be provided.');
            }

            if (!options.typeName) {
                throw new Error('A type name must be provided.');
            }

            this.headers = options.headers;

            this.dataCollection = this.everlive$.data(options.typeName);
            kendo.data.RemoteTransport.fn.init.call(this, options);
        },

        read: function (options) {
            var methodOption = this.options['read'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var query = translateKendoQuery(options.data);
            var everliveQuery = new Query(query.$where, null, query.$sort, query.$skip, query.$take);
            var id = options.data.Id;

            if (id) {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).getById(id).then(options.success, options.error).catch(options.error);
            } else {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).get(everliveQuery).then(options.success, options.error).catch(options.error);
            }
        },

        update: function (options) {
            var methodOption = this.options['update'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch update is not supported.');
            } else {
                var itemForUpdate = options.data;
                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).updateSingle(itemForUpdate)
                    .then(options.success.bind(this, itemForUpdate), options.error).catch(options.error);
            }
        },

        create: function (options) {
            var methodOption = this.options['create'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            var createData = isMultiple ? options.data.models : options.data;

            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).create(createData)
                .then(options.success.bind(this, createData), options.error).catch(options.error);
        },

        destroy: function (options) {
            var methodOption = this.options['destroy'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch destroy is not supported.');
            }
            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).destroy(options.data)
                .then(options.success, options.error).catch(options.error);
        }
    });

    $.extend(true, kendo.data, {
        transports: {
            everlive: everliveTransport
        },
        schemas: {
            everlive: {
                type: 'json',
                total: function (data) {
                    return data.hasOwnProperty('count') ? data.count : data.Count;
                },
                data: function (data) {
                    return data.result || Everlive._traverseAndRevive(data.Result) || data;
                },
                model: {
                    id: constants.idField
                }
            }
        }
    });

    function translateKendoQuery(data) {
        var result = {};
        if (data) {
            if (data.skip) {
                result.$skip = data.skip;
                delete data.skip;
            }
            if (data.take) {
                result.$take = data.take;
                delete data.take;
            }
            if (data.sort) {
                var sortExpressions = data.sort;
                var sort = {};
                if (!$.isArray(sortExpressions)) {
                    sortExpressions = [sortExpressions];
                }
                $.each(sortExpressions, function (idx, value) {
                    sort[value.field] = value.dir === 'asc' ? 1 : -1;
                });
                result.$sort = sort;
                delete data.sort;
            }
            if (data.filter) {
                var filter = filterBuilder.build(data.filter);
                result.$where = filter;
                delete data.filter;
            }
        }
        return result;
    }

    var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];

    var filterBuilder = {
        build: function (filter) {
            return filterBuilder._build(filter);
        },
        _build: function (filter) {
            if (filterBuilder._isRaw(filter)) {
                return filterBuilder._raw(filter);
            }
            else if (filterBuilder._isSimple(filter)) {
                return filterBuilder._simple(filter);
            }
            else if (filterBuilder._isRegex(filter)) {
                return filterBuilder._regex(filter);
            }
            else if (filterBuilder._isAnd(filter)) {
                return filterBuilder._and(filter);
            }
            else if (filterBuilder._isOr(filter)) {
                return filterBuilder._or(filter);
            }
        },
        _isRaw: function (filter) {
            return filter.operator === '_raw';
        },
        _raw: function (filter) {
            var fieldTerm = {};
            fieldTerm[filter.field] = filter.value;
            return fieldTerm;
        },
        _isSimple: function (filter) {
            return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
        },
        _simple: function (filter) {
            var term = {}, fieldTerm = {};
            var operator = filterBuilder._translateoperator(filter.operator);
            if (operator) {
                term[operator] = filter.value;
            }
            else {
                term = filter.value;
            }
            fieldTerm[filter.field] = term;
            return fieldTerm;
        },
        _isRegex: function (filter) {
            return $.inArray(filter.operator, regexOperations) !== -1;
        },
        _regex: function (filter) {
            var fieldTerm = {};
            var regex = filterBuilder._getRegex(filter);
            fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
            return fieldTerm;
        },
        _getRegex: function (filter) {
            var pattern = filter.value;
            var filterOperator = filter.operator;
            switch (filterOperator) {
                case 'contains':
                    return new RegExp(".*" + pattern + ".*", "i");
                case 'startsWith': // removing the camel case operators will be a breaking change
                case 'startswith': // the Kendo UI operators are in lower case
                    return new RegExp("^" + pattern, "i");
                case 'endsWith':
                case 'endswith':
                    return new RegExp(pattern + "$", "i");
            }
            throw new Error("Unknown operator type.");
        },
        _getRegexValue: function (regex) {
            return QueryBuilder.prototype._getRegexValue.call(this, regex);
        },
        _isAnd: function (filter) {
            return filter.logic === 'and';
        },
        _and: function (filter) {
            var i, l, term, result = {};
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result = filterBuilder._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            return QueryBuilder.prototype._andAppend.call(this, andObj, newObj);
        },
        _isOr: function (filter) {
            return filter.logic === 'or';
        },
        _or: function (filter) {
            var i, l, term, result = [];
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case 'eq':
                    return null;
                case 'neq':
                    return "$ne";
                case 'gt':
                    return "$gt";
                case 'lt':
                    return "$lt";
                case 'gte':
                    return "$gte";
                case 'lte':
                    return "$lte";
            }
            throw new Error("Unknown operator type.");
        }
    };

    /**
     * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
     * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
     * *including Kendo UI scripts is required*.
     * @param options data source options. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
     * @param options.transport.typeName The content type name in Backend Services that will be managed.
     * @returns {DataSource} A new instance of Kendo UI DataSource. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
     * @example ```js
     * var booksDataSource = Everlive.createDataSource({
     *   transport: {
     *     typeName: 'Books'
     *   }
     * });
     * ```
     */
    var createDataSource = function (options) {
        options = options || {};
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.");
        }

        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
        }

        return everlive$.getKendoDataSource(typeName, options);
    };

    /**
     * Creates a new Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
     * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo UI widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
     * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
     * *including Kendo UI scripts is required*.
     * @param options data source Options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @param options.typeName Name of the main content type for the data source.
     * @param {ExpandDefinition[]} options.expand An array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
     * @param {string} ExpandDefinition - The field name of the relation that will be expanded. Only supported in online mode.
     * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
     * @param {string} ExpandDefinition.typeName - *Required in offline mode*. The type name of the relation that will be expanded.
     * @param {object} ExpandDefinition.filter - An object specifying the filter expression.
     * @param {object} ExpandDefinition.sort - An object specifying the sort expression.
     * @param {object} ExpandDefinition.skip - A number specifying the skip value.
     * @param {object} ExpandDefinition.take - A number specifying the take value.
     * @param {object} ExpandDefinition.fields - An object specifying the fields expression.
     * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See the Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @example ```js
     * var el = new Everlive('your-api-key-here');
     * var continents = Everlive.createHierarchicalDataSource({
     *   "typeName": "Continents",
     *   "expand": ["Countries", "Towns"]
     * });
     *
     * ...
     * ("#treeview").kendoTreeView({
     *   dataSource: continents,
     *   dataTextField: ["ContinentName", "CountryName", "TownName"]
     * });
     * ```
     */
    var createHierarchicalDataSource = function (options) {
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.");
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
        }
        return everlive$.getHierarchicalDataSource(typeName, options);

    };

    /**
     * Get a Kendo UI DataSource that is attached to the current instance of the SDK with default options.
     * @method getKendoDataSource
     * @memberOf Everlive.prototype
     * @param {String} typeName The corresponding type name for the DataSource.
     * @param {Object} [datasourceOptions] Additional DataSource options.
     * @returns {DataSource}
     */
    Everlive.prototype.getKendoDataSource = function (typeName, datasourceOptions) {
        datasourceOptions = _.extend({}, datasourceOptions);
        if (datasourceOptions.hasOwnProperty('serverGrouping') && datasourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }

        var defaultEverliveOptions = {
            type: 'everlive',
            transport: {
                typeName: typeName,
                dataProvider: this
            }
        };

        var options = _.defaults(defaultEverliveOptions, datasourceOptions);
        return new kendo.data.DataSource(options);
    };


    var getUrlGeneratorForNode = function (baseUrl, expandArray) {
        var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
        var pathArray = expandArray.slice(0, expandArray.length - 1);
        var pathUrl = '/_expand';
        for (var i = 0; i < pathArray.length; i++) {
            pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
        }
        return (function (pathUrl, expandField) {
            return function (options) {
                var url = baseUrl + '';
                if (options.Id && expandField) {//if we are expanding
                    url += pathUrl + '/' + options.Id + '/' + expandField;
                }
                return url;
            }
        }(pathUrl, expandField));
    };

    var getHeadersForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return {};
        } else {
            return {
                'X-Everlive-Filter': JSON.stringify(expandNode.filter),
                'X-Everlive-Sort': JSON.stringify(expandNode.sort),
                'X-Everlive-Single-Field': expandNode.singleField,
                'X-Everlive-Skip': expandNode.skip,
                'X-Everlive-Take': expandNode.take,
                'X-Everlive-Fields': JSON.stringify(expandNode.fields)
            }
        }
    };

    var getRelationFieldForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return expandNode;
        } else {
            if (expandNode.relation) {
                return expandNode.relation;
            } else {
                throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
            }
        }
    };

    /**
     * Get a Kendo UI HierarchicalDataSource that is attached to the current instance of the SDK with default options.
     * @method getHierarchicalDataSource
     * @memberOf Everlive.prototype
     * @param {String} typeName The corresponding type name for the DataSource.
     * @param {Object} dataSourceOptions Additional DataSource options that describe the hierarchical structure.
     * @returns {HierarchicalDataSource}
     */
    Everlive.prototype.getHierarchicalDataSource = function (typeName, dataSourceOptions) {
        dataSourceOptions = dataSourceOptions || {};
        if (dataSourceOptions.hasOwnProperty('serverGrouping') && dataSourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }
        var expand = dataSourceOptions.expand || dataSourceOptions;
        delete dataSourceOptions.expand;
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI HierarchicalDataSource.");
        }
        if (!$.isArray(expand)) {
            throw new Error("You need to set 'expand' array option in order to create a Kendo UI HierarchicalDataSource");
        }
        var baseUrl = this.buildUrl() + typeName;

        var expandSchema;
        var isOfflineStorageEnabled = this._isOfflineStorageEnabled();
        for (var i = expand.length - 1; i >= 0; i--) { //recursively build the hierarchical data source
            var expandNode = expand[i];
            if (isOfflineStorageEnabled) {
                if (!$.isPlainObject(expandNode)) {
                    throw new Error("When offline is enabled, each member of the expand array option must be an object. (Expand node index: " + i + ")");
                }
                if (!expandNode.relation) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `relation` option set.  (Expand node index: " + i + ")");
                }
                if (!expandNode.typeName) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `typeName` option set.  (Expand node index: " + i + ")");
                }

                var headers;
                var expandExpression = {};
                expandExpression[expandNode.relation] = {
                    TargetTypeName: expandNode.typeName,
                    Filter: expandNode.filter,
                    Sort: expandNode.sort,
                    Take: expandNode.take,
                    Skip: expandNode.skip,
                    Fields: expandNode.fields,
                    SingleField: expandNode.singleField
                };
                headers = {
                    'X-Everlive-Expand': JSON.stringify(expandExpression),
                    'X-Everlive-Single-Field': expandNode.relation
                };
                var parentType;
                if (i === 0) {
                    parentType = typeName;
                } else {
                    parentType = expand[i - 1].typeName;
                }
                expandSchema = {
                    model: {
                        hasChildren: expandNode.relation,
                        children: {
                            type: "everlive",
                            transport: {
                                typeName: parentType,
                                read: {
                                    headers: headers
                                }
                            },
                            schema: expandSchema
                        }
                    }
                };
            } else {
                expandSchema = {
                    model: {
                        hasChildren: getRelationFieldForExpandNode(expandNode),
                        children: {
                            type: "everlive",
                            transport: {
                                read: {
                                    url: getUrlGeneratorForNode(baseUrl, expand.slice(0, i + 1)),
                                    headers: getHeadersForExpandNode(expandNode)
                                }
                            },
                            schema: expandSchema
                        }
                    }
                }
            }
        }
        var options = {};
        options.type = 'everlive';
        options.transport = {
            typeName: typeName,
            dataProvider: this
        };
        options.schema = expandSchema;
        if ($.isPlainObject(dataSourceOptions)) {
            extend(true, options, dataSourceOptions);
        }
        return new kendo.data.HierarchicalDataSource(options);
    };


    module.exports = {
        createDataSource: createDataSource,
        createHierarchicalDataSource: createHierarchicalDataSource
    };
}());
},{"../Everlive":38,"../EverliveError":39,"../Request":44,"../common":48,"../constants":49,"../query/Query":69,"../query/QueryBuilder":70}],58:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var Request = require('../Request');
var common = require('../common');
var rsvp = common.rsvp;
var _ = common._;
var reqwest = common.reqwest;
var uuid = common.uuid;
var path = require('path');
var CryptoJS = require('node-cryptojs-aes').CryptoJS;
var errors = require('../EverliveError');
var EverliveErrors = errors.EverliveErrors;
var EverliveError = errors.EverliveError;

var OfflineFilesModule = function (offlineFilesProcessor, everlive) {
    this._offlineFilesProcessor = offlineFilesProcessor;
    this._everlive = everlive;
};

/**
 * @class OfflineFilesModule
 * @classdesc A class that provides the means to operate with files in offline mode.
 * @protected
 */
OfflineFilesModule.prototype = {
    _getFilenameMetadata: function (location, offlineFileInfo) {
        return new rsvp.Promise(function (resolve) {
            reqwest({
                url: location,
                method: 'HEAD',
                async: true,
                crossDomain: true
            }).then(function (xmlResponse) {
                var contentDispositionHeader = xmlResponse.getResponseHeader('Content-Disposition');
                if (contentDispositionHeader) {
                    var matches = /filename="([^"\\]*(?:\\.[^"\\]*)*)"/i.exec(contentDispositionHeader);
                    if (_.isArray(matches)) {
                        offlineFileInfo.filename = matches[1];
                    }
                } else {
                    offlineFileInfo.filename = path.basename(xmlResponse.responseURL);
                }

                resolve();
            }).catch(function () {
                resolve();
            });

        });
    },

    /**
     * Updates a file's content.
     * @memberof OfflineFilesModule.prototype
     * @method downloadOffline
     * @param {string} location A file location or the id of a file stored in Backend Services.
     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
     * @returns {Promise} The promise for the request
     */
    /**
     * Updates a file's content.
     * @memberof OfflineFilesModule.prototype
     * @method downloadOffline
     * @param {string} location A file location or the id of a file stored in Backend Services.
     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    downloadOffline: function (location, overwrite, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var offlineFileInfo;
            return self._getOfflineFileInfo(location)
                .then(function (_offlineFileInfo) {
                    offlineFileInfo = _offlineFileInfo;
                    if (overwrite) {
                        return false;
                    }

                    return self.existsOffline(location);
                })
                .then(function (exists) {
                    if (!exists) {
                        if (self._everlive.isOnline()) {
                            return utils.successfulPromise()
                                .then(function () {
                                    if (!offlineFileInfo.filename) {
                                        return self._getFilenameMetadata(location, offlineFileInfo);
                                    }
                                })
                                .then(function () {
                                    return self._saveFile(offlineFileInfo.location, offlineFileInfo.filename);
                                });
                        }

                        error(EverliveErrors.cannotDownloadOffline);
                    } else {
                        return self._getOfflineFileInfo(location)
                            .then(function (fileInfo) {
                                return self._getOfflineLocation(fileInfo);
                            });
                    }
                })
                .then(success)
                .catch(error);
        }, success, error);
    },

    _saveFile: function (location, filename) {
        var self = this;
        var actualLocation;

        return self._downloadFile(location , filename)
            .then(function (_actualLocation) {
                actualLocation = _actualLocation;
                return self._offlineFilesProcessor.getOfflineFilesData();
            })
            .then(function (offlineFilesData) {
                offlineFilesData.push({
                    offlineLocation: actualLocation,
                    onlineLocation: location
                });

                return self._offlineFilesProcessor.saveOfflineFilesData();
            })
            .then(function () {
                return actualLocation;
            });
    },

    /**
     * Physically deletes the offline copies of all files.
     * @memberof OfflineFilesModule.prototype
     * @method purgeAll
     * @returns {Promise} The promise for the request.
     */
    /**
     * Physically deletes the offline copies of all files.
     * @memberof OfflineFilesModule.prototype
     * @method purgeAll
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    purgeAll: function (success, error) {
        var self = this;

        return utils.buildPromise(function (success, error) {
            self._offlineFilesProcessor.fileStore.removeFilesDirectory()
                .then(function () {
                    return self._offlineFilesProcessor.filesMetaStore.removeFilesDirectory();
                })
                .then(function () {
                    self._offlineFilesProcessor._offlineFilesData = null;
                })
                .then(success)
                .catch(error);
        }, success, error);
    },

    _getOfflineLocation: function (fileInfo) {
        var self = this;
        var url = fileInfo.location;
        var filename = fileInfo.filename;
        var id = fileInfo.Id;

        return self._offlineFilesProcessor.getOfflineLocation(url, filename)
            .then(function (offlineUrl) {
                if (offlineUrl) {
                    return offlineUrl;
                }

                // if no url is provided this means that the file exists only offline
                // the Uri field has not been populated by the server
                if (id && !url) {
                    return self._getFileUrlForId(id, filename);
                }

                return null;
            });
    },

    _downloadFile: function (url, name) {
        var self = this;

        // TODO: [offline] this will not work in NativeScript at the moment
        return new rsvp.Promise(function (resolve, reject) {
            var fileTransfer = new FileTransfer();
            var sanitizedUrl = self._sanitizeUrl(url);
            var fileId = path.basename(sanitizedUrl);
            var extension = path.extname(name);
            var filename = fileId;
            if (path.extname(sanitizedUrl) !== extension) {
                 filename += extension;
            }

            var fileParentDirectory = '';
            if (!utils.isGuid(url)) {
                var fileIdIndex = url.lastIndexOf(fileId);
                var baseUrl = url.substr(0, fileIdIndex);
                fileParentDirectory = CryptoJS.MD5(baseUrl).toString();
            }

            return self._offlineFilesProcessor.fileStore.getDataDirectory()
                .then(function (dataDir) {
                    return utils.joinPath(dataDir.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath,
                        fileParentDirectory, filename);
                })
                .then(function (location) {
                    fileTransfer.download(url, location, function () {
                        resolve(location);
                    }, reject, true, {
                        headers: self._everlive.buildAuthHeader()
                    });
                })
                .catch(reject);
        });
    },

    _sanitizeUrl: function (url) {
        if (!url) {
            return url;
        }

        var sanitizedUrl = encodeURI(url);
        var questionMarkIndex = sanitizedUrl.lastIndexOf('?');
        if (questionMarkIndex !== -1) {
            sanitizedUrl = sanitizedUrl.substr(0, questionMarkIndex); //linux does not allow question marks in its filenames
        }

        return sanitizedUrl;
    },

    _getFileUrlForId: function (fileId, filename) {
        var self = this;

        return this._offlineFilesProcessor.fileStore.getDataDirectory()
            .then(function (dataDirectory) {
                var fileExtension = path.extname(filename);
                return utils.joinPath(dataDirectory.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath, fileId + fileExtension);
            });
    },

    /**
     * Checks if a file exists offline.
     * @memberof OfflineFilesModule.prototype
     * @method exists
     * @param {String} location The location or file id to check.
     * @returns {Promise} The promise for the request
     */
    /**
     * Checks if a file exists offline.
     * @memberof OfflineFilesModule.prototype
     * @method exists
     * @param {String} location The location or file id to check.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    existsOffline: function (location, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._getOfflineFileInfo(location)
                .then(function (fileInfo) {
                    return self._getOfflineLocation(fileInfo);
                })
                .then(function (offlineUrl) {
                    if (offlineUrl) {
                        return self._offlineFilesProcessor.fileStore.getFileByAbsolutePath(offlineUrl);
                    }
                })
                .then(function (offlineFile) {
                    return !!offlineFile;
                })
                .then(success)
                .catch(function (err) {
                    if (err.code === EverliveErrors.itemNotFound.code) {
                        return success(false);
                    }

                    return error.apply(this, arguments);
                });
        }, success, error);
    },


    /**
     * Physically deletes the offline copy of a file.
     * @memberof OfflineFilesModule.prototype
     * @method purge
     * @param {String} location The location or file id to remove.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Physically deletes the offline copy of a file.
     * @memberof OfflineFilesModule.prototype
     * @method purge
     * @param {String} location The location or file id to check.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    purge: function (location, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._getOfflineFileInfo(location)
                .then(function (fileInfo) {
                    return self._getOfflineLocation(fileInfo);
                })
                .then(function (location) {
                    if (location) {
                        return self._offlineFilesProcessor.purge(location);
                    }
                })
                .then(success)
                .catch(error);
        }, success, error);
    },

    /**
     * Gets the native URL for a file that is stored offline.
     * @memberof OfflineFilesModule.prototype
     * @method getOfflineLocation
     * @param {String} location The location or file id to process.
     * @returns {Promise} The promise for the request
     */
    /**
     * Gets the native URL for a file that is stored offline.
     * @memberof OfflineFilesModule.prototype
     * @method getOfflineLocation
     * @param {String} location The location or file id to process.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    getOfflineLocation: function (location, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            self._getOfflineFileInfo(location)
                .then(self._getOfflineLocation.bind(self))
                .then(success)
                .catch(error);
        }, success, error);
    },

    _getOfflineFileInfo: function (location) {
        var self = this;
        var sanitizedUrl = this._sanitizeUrl(location);

        return new rsvp.Promise(function (resolve, reject) {
            self._everlive.Files
                .isSync(true)
                .useOffline(true)
                .getById(sanitizedUrl)
                .then(function (response) {
                    var file = response.result;
                    resolve({
                        location: file.Uri,
                        filename: file.Filename,
                        Id: sanitizedUrl
                    });
                })
                .catch(function (err) {
                    if (err && err.code === EverliveErrors.itemNotFound.code) {
                        resolve({
                            location: location
                        });
                    } else {
                        reject(err);
                    }
                });
        });
    },

    changeFileExtensionById: function (id, extension) {
        var self = this;

        if (typeof extension !== 'string') {
            return new rsvp.Promise(function (resolve) {
                resolve();
            });
        }

        return self._changeExtension(id, extension);
    },

    _changeExtension: function (id, newExtension) {
        var self = this;

        var dataDir;

        var fileStore = self._offlineFilesProcessor.fileStore;
        var fileName = id + newExtension;
        return fileStore.getFilesDirectory()
            .then(function (directoryEntry) {
                dataDir = directoryEntry;
                return self.getOfflineLocation(id);
            })
            .then(function (localPath) {

                var existingFileName = path.basename(localPath);
                if (existingFileName !== fileName) {
                    return fileStore.getFileByAbsolutePath(localPath)
                        .then(function (fileEntry) {
                            return fileStore.renameFile(dataDir, fileEntry, fileName);
                        })
                        .then(function () {
                            return self._offlineFilesProcessor.getOfflineFilesData();
                        })
                        .then(function (offlineFilesData) {
                            var mappedEntry = _.findWhere(offlineFilesData, {offlineLocation: localPath});
                            if (!mappedEntry) {
                                throw new EverliveError('Could not find a cached location for the specified file.');
                            }

                            var previousLocation = mappedEntry.offlineLocation;
                            var previousExtension = path.extname(previousLocation);
                            var actualLocation = previousLocation.slice(0, previousLocation.length - previousExtension.length) + newExtension;
                            mappedEntry.offlineLocation = actualLocation;

                            return self._offlineFilesProcessor.saveOfflineFilesData();
                        });
                }
            });
    }
};

module.exports = OfflineFilesModule;
},{"../EverliveError":39,"../Request":44,"../common":48,"../utils":82,"node-cryptojs-aes":21,"path":5}],59:[function(require,module,exports){
'use strict';

var EverliveErrorModule = require('../EverliveError');
var EverliveError = EverliveErrorModule.EverliveError;
var EverliveErrors = EverliveErrorModule.EverliveErrors;
var FileStore = require('../storages/FileStore');
var platform = require('../everlive.platform');
var constants = require('../constants');
var common = require('../common');
var rsvp = common.rsvp;
var utils = require('../utils');
var _ = common._;
var path = require('path');

var FILES_METADATA_FILE_NAME = 'filesMetadataMap';

var OfflineFilesProcessor = function (setup, everlive) {
    this.fileStore = new FileStore(setup.files.storagePath, setup);
    this.filesMetaStore = new FileStore(setup.files.metaPath, setup);
    this._everlive = everlive;
};

OfflineFilesProcessor.prototype = {
    validateFileCreateObject: function (obj, isSync) {
        return new rsvp.Promise(function (resolve, reject) {
            if (!obj.base64 && !isSync) {
                return reject(EverliveErrors.missingOrInvalidFileContent);
            } else if (!obj.ContentType) {
                return reject(EverliveErrors.missingContentType);
            } else if (!obj.Filename) {
                //TODO: [offline] add an appropriate error
                return reject(EverliveErrors.invalidRequest);
            }

            resolve();
        });
    },

    getOfflineFilesData: function () {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            if (!self._offlineFilesData) {
                return self.filesMetaStore.getFile(FILES_METADATA_FILE_NAME)
                    .then(function (metadataFileHandle) {
                        return self.filesMetaStore.readFileAsText(metadataFileHandle);
                    })
                    .then(function (metadataText) {
                        if (!metadataText) {
                            metadataText = '[]';
                        }

                        self._offlineFilesData = JSON.parse(metadataText);
                        resolve(self._offlineFilesData);
                    }).catch(reject);
            } else {
                resolve(self._offlineFilesData);
            }
        });
    },

    saveOfflineFilesData: function () {
        var self = this;

        return self.getOfflineFilesData()
            .then(function (offlineFilesData) {
                return self.filesMetaStore.writeText(FILES_METADATA_FILE_NAME, JSON.stringify(offlineFilesData));
            });
    },

    upsertFileFromObject: function (obj, isCreate, isSync) {
        var self = this;

        if (!isSync) {
            if (isCreate) {
                if (!obj.base64) {
                    return utils.rejectedPromise(EverliveErrors.missingOrInvalidFileContent);
                }

                if (!obj.ContentType) {
                    return utils.rejectedPromise(EverliveErrors.missingContentType);
                }
            } else {
                if (!obj.base64) {
                    return utils.successfulPromise();
                }
            }
        }

        if (!obj.base64) {
            var id = utils.getId(obj);
            var uri;
            var downloadFilePromise = obj.Uri ? utils.successfulPromise(obj.Uri) :
                self._everlive.files
                    .isSync(isSync)
                    .applyOffline(false)
                    .getDownloadUrlById(id);

            return downloadFilePromise.then(function (_uri) {
                uri = _uri;
                return self._everlive.offlineStorage.files.existsOffline(id);
            }).then(function (exists) {
                if (!exists) {
                    return self._everlive.offlineStorage.files._saveFile(uri, obj.Filename);
                }
            });
        }

        obj.Storage = 'internal';
        return utils.successfulPromise().then(function () {
            if (!isSync) {
                return self.validateFileCreateObject(obj, isSync);
            }
        }).then(function () {
            var onlineLocation = obj.Uri;
            var filename = self.getFilenameForObject(obj);

            var offlineFileInfo;
            var base64Contents = obj.base64;
            delete obj.base64;

            var contents = utils.b64toBlob(base64Contents, obj.ContentType);

            return self.writeFile(filename, contents)
                .then(function (fileInfo) {
                    offlineFileInfo = fileInfo;
                    return self.getOfflineFilesData();
                })
                .then(function (offlineFilesData) {
                    offlineFilesData.push({
                        offlineLocation: offlineFileInfo.offlineLocation,
                        onlineLocation: onlineLocation
                    });

                    //TODO: maybe save the filesdata?

                    obj.Length = offlineFileInfo.size;
                });
        });
    },

    purge: function (localLocation) {
        var self = this;

        return this.getOfflineFilesData()
            .then(function (offlineFilesData) {
                var offlineFile = _.where(offlineFilesData, {offlineLocation: localLocation});

                // TODO: [offline] check if the length of offlineFile === 0
                var offlineInfoIndex = offlineFilesData.indexOf(offlineFile[0]);
                if (offlineInfoIndex !== -1) {
                    offlineFilesData.splice(offlineInfoIndex, 1);
                }

                return self.saveOfflineFilesData();
            })
            .then(function () {
                return self.fileStore.getFileByAbsolutePath(localLocation);
            }).then(function (file) {
                if (file) {
                    return self.fileStore.removeFile(file);
                }
            });
    },

    writeFile: function (filename, contents, folder) {
        var self = this;
        var offlineLocation;

        return self.fileStore.writeText(filename, contents, folder)
            .then(function (locationOnDisk) {
                offlineLocation = locationOnDisk;
                return self.saveOfflineFilesData();
            })
            .then(function () {
                return self.fileStore.getFileSize(filename, folder);
            })
            .then(function (size) {
                return {
                    size: size,
                    offlineLocation: offlineLocation
                };
            });
    },

    getFilenameForObject: function (obj) {
        var extension = path.extname(obj.Filename);
        return obj._id + extension;
    },

    getOfflineLocation: function (url) {
        return this.getOfflineFilesData()
            .then(function (offlineFilesData) {
                if (!url) {
                    return;
                }

                var isOfflineUrl = !!_.findWhere(offlineFilesData, {
                    offlineLocation: url
                });

                if (isOfflineUrl) {
                    return url;
                }

                var offlineFileData = _.findWhere(offlineFilesData, {
                    onlineLocation: url
                });

                if (offlineFileData) {
                    return offlineFileData.offlineLocation;
                }
            });
    }
};

module.exports = OfflineFilesProcessor;
},{"../EverliveError":39,"../common":48,"../constants":49,"../everlive.platform":51,"../storages/FileStore":75,"../utils":82,"path":5}],60:[function(require,module,exports){
'use strict';

var DataQuery = require('../query/DataQuery');
var utils = require('../utils');
var offlineTransformations = require('./offlineTransformations');
var expandProcessor = require('../ExpandProcessor');

var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;

var buildPromise = require('../utils').buildPromise;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var mingo = common.Mingo;
var mongoQuery = common.mongoQuery;
var Query = require('../query/Query');

var path = require('path');

var constants = require('../constants');
var Headers = constants.Headers;
var offlineItemStates = constants.offlineItemStates;

var unsupportedOfflineHeaders = [Headers.powerFields];

var unsupportedUsersOperations = {};
unsupportedUsersOperations[DataQuery.operations.create] = true;
unsupportedUsersOperations[DataQuery.operations.update] = true;
unsupportedUsersOperations[DataQuery.operations.remove] = true;
unsupportedUsersOperations[DataQuery.operations.removeSingle] = true;
unsupportedUsersOperations[DataQuery.operations.rawUpdate] = true;
unsupportedUsersOperations[DataQuery.operations.setAcl] = true;
unsupportedUsersOperations[DataQuery.operations.setOwner] = true;
unsupportedUsersOperations[DataQuery.operations.userLoginWithProvider] = true;
unsupportedUsersOperations[DataQuery.operations.userLinkWithProvider] = true;
unsupportedUsersOperations[DataQuery.operations.userUnlinkFromProvider] = true;
unsupportedUsersOperations[DataQuery.operations.userLogin] = true;
unsupportedUsersOperations[DataQuery.operations.userLogout] = true;
unsupportedUsersOperations[DataQuery.operations.userChangePassword] = true;
unsupportedUsersOperations[DataQuery.operations.userResetPassword] = true;

function buildUsersErrorMessage(dataQuery) {
    var unsupportedUserSocialProviderOperations = [
        DataQuery.operations.userLoginWithProvider,
        DataQuery.operations.userLinkWithProvider,
        DataQuery.operations.userUnlinkFromProvider
    ];

    var operation = dataQuery.operation;
    if (unsupportedUserSocialProviderOperations.indexOf(operation) !== -1) {
        operation += dataQuery.data.Provider || dataQuery.data.Identity.Provider;
    }

    return 'The Users operation ' + operation + ' is not supported in offline mode';
}

function buildFilesErrorMessage(dataQuery) {
    return 'The Files operation ' + dataQuery.operation + ' is not supported in offline mode';
}

function OfflineQueryProcessor(persister, encryptionProvider, offlineFilesProcessor, everlive, setup) {
    this._collectionCache = {};
    this.offlineFilesProcessor = offlineFilesProcessor;
    this._persister = persister;
    this._encryptionProvider = encryptionProvider;
    this.everlive = everlive;
    this.setup = setup;
}

OfflineQueryProcessor.prototype = {
    processQuery: function (dataQuery) {
        var unsupportedClientOpMessage = this.getUnsupportedClientOpMessage(dataQuery);
        if (unsupportedClientOpMessage && !dataQuery.isSync) {
            return new rsvp.Promise(function (resolve, reject) {
                reject(new EverliveError(unsupportedClientOpMessage));
            });
        }

        var sort = dataQuery.getHeaderAsJSON(Headers.sort);
        var limit = dataQuery.getHeaderAsJSON(Headers.take);
        var skip = dataQuery.getHeaderAsJSON(Headers.skip);
        var select = dataQuery.getHeaderAsJSON(Headers.select);
        var filter = dataQuery.getHeaderAsJSON(Headers.filter);
        var expand = dataQuery.getHeaderAsJSON(Headers.expand);

        if (dataQuery.filter instanceof Query) {
            var filterObj = dataQuery.filter.build();
            filter = filterObj.$where || filter || {};
            sort = filterObj.$sort || sort;
            limit = filterObj.$take || limit;
            skip = filterObj.$skip || skip;
            select = filterObj.$select || select;
            expand = filterObj.$expand || expand;
        } else {
            filter = (dataQuery.filter || filter) || {};
        }

        var unsupportedOperators = utils.getUnsupportedOperators(filter);
        var unsupportedOperatorCount = unsupportedOperators.length;
        if (unsupportedOperatorCount) {
            return new rsvp.Promise(function (resolve, reject) {
                var errorMessage;
                if (unsupportedOperatorCount === 1) {
                    errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
                } else {
                    errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
                }

                reject(new EverliveError(errorMessage));
            });
        }

        offlineTransformations.traverseAndTransformFilterId(filter);

        switch (dataQuery.operation) {
            case DataQuery.operations.read:
                return this.read(dataQuery, filter, sort, skip, limit, select, expand);
            case DataQuery.operations.readById:
                return this.readById(dataQuery, expand);
            case DataQuery.operations.filesGetDownloadUrlById:
                return this.getDownloadUrlById(dataQuery);
            case DataQuery.operations.count:
                return this.count(dataQuery, filter);
            case DataQuery.operations.create:
                return this.create(dataQuery);
            case DataQuery.operations.rawUpdate:
            case DataQuery.operations.update:
                return this.update(dataQuery, filter);
            case DataQuery.operations.filesUpdateContent:
                return this.updateFileContent(dataQuery, filter);
            case DataQuery.operations.remove:
                return this.remove(dataQuery, filter);
            case DataQuery.operations.removeSingle:
                filter._id = dataQuery.additionalOptions.id;
                return this.remove(dataQuery, filter);
            default:
                return new rsvp.Promise(function (resolve, reject) {
                    if (dataQuery.isSync) {
                        resolve();
                    } else {
                        reject(new EverliveError(dataQuery.operation + ' is not supported in offline mode'));
                    }
                });
        }
    },

    getDownloadUrlById: function (dataQuery) {
        var self = this;
        var id = dataQuery.additionalOptions.id;
        var offlineFilePath;

        return self.everlive
            .files
            .useOffline(true)
            .isSync(dataQuery.isSync)
            .getById(id)
            .then(function (res) {
                var file = res.result;
                return self.everlive.offlineStorage.files._getFileUrlForId(file.Id, file.Filename);
            })
            .then(function (filePath) {
                offlineFilePath = filePath;
                return self.everlive.offlineStorage._offlineFilesProcessor.fileStore.getFileByAbsolutePath(filePath);
            })
            .then(function (fileEntry) {
                if (fileEntry) {
                    return {
                        result: {
                            Uri: offlineFilePath
                        }
                    }
                }

                return {
                    result: {}
                }
            });
    },

    getUnsupportedClientOpMessage: function (dataQuery) {
        for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
            var header = unsupportedOfflineHeaders[i];
            if (dataQuery.getHeader(header)) {
                return 'The header ' + header + ' is not supported in offline mode';
            }
        }

        if (utils.isContentType.users(dataQuery.collectionName) && unsupportedUsersOperations[dataQuery.operation]) {
            return buildUsersErrorMessage(dataQuery);
        }

        var isSingle = dataQuery.additionalOptions && dataQuery.additionalOptions.id;
        var isUpdateByFilter = dataQuery.operation === DataQuery.operations.update && !isSingle;
        var isRawUpdate = dataQuery.operation === DataQuery.operations.rawUpdate;
        if (utils.isContentType.files(dataQuery.collectionName) && (isRawUpdate || isUpdateByFilter)) {
            return buildFilesErrorMessage(dataQuery);
        }
    },

    _getCreateResult: function (createdItems, returnFullItem) {
        if (createdItems.length === 1) {
            var result;
            if (returnFullItem) {
                var item = _.extend({}, createdItems[0]);
                result = offlineTransformations.idTransform(item);
            } else {
                result = {
                    CreatedAt: utils.cloneDate(createdItems[0].CreatedAt),
                    Id: createdItems[0]._id
                }
            }

            return {
                result: result
            };
        } else {
            var multipleCreateResult = [];
            _.each(createdItems, function (createdItem) {
                var item;
                if (returnFullItem) {
                    var itemCopy = _.extend({}, createdItem);
                    item = offlineTransformations.idTransform(itemCopy);
                } else {
                    item = {
                        CreatedAt: utils.cloneDate(createdItem.CreatedAt),
                        Id: createdItem._id
                    };
                }
                multipleCreateResult.push(item);
            });

            return {
                result: multipleCreateResult
            };
        }
    },

    create: function (dataQuery) {
        var self = this;

        return self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, dataQuery.preserveState)
            .then(function (createdItems) {
                var isFilesQuery = utils.isContentType.files(dataQuery.collectionName);
                return self._getCreateResult(createdItems, isFilesQuery);
            });
    },

    read: function (dataQuery, filter, sort, skip, limit, select, expand) {
        var self = this;
        var expandResult;

        return new rsvp.Promise(function (resolve, reject) {
            var collectionLength;

            self._prepareExpand(expand, dataQuery, true)
                .then(function (prepareExpandResult) {
                    expandResult = prepareExpandResult;
                    if (prepareExpandResult) {
                        select = prepareExpandResult.mainQueryFieldsExpression;
                    }

                    return self._getCollection(dataQuery.collectionName);
                })
                .then(function (collection) {
                    var result = self._readInternal(collection, filter, sort, skip, limit, select);

                    if (skip || limit) {
                        var all = self._readInternal(collection);
                        collectionLength = all.length;
                    }

                    if (!self._shouldAutogenerateIdForContentType(dataQuery.collectionName)) {
                        result = offlineTransformations.removeIdTransform(result, true);
                    } else {
                        result = offlineTransformations.idTransform(result);
                    }

                    return self._expandResult(expandResult, result);
                })
                .then(function (result) {
                    var response = self._transformOfflineResult(result, collectionLength, dataQuery);
                    resolve(response);
                })
                .catch(reject);
        });
    },

    _readInternal: function (collection, filter, sort, skip, limit, select) {
        var filterCopy = _.extend({}, filter);
        var actualFilter = this._getWithoutDeletedFilter(filterCopy);
        offlineTransformations.traverseAndTransformFilterId(actualFilter);
        var query = mingo.Query(actualFilter);
        var cursor = mingo.Cursor(collection, query, select);
        if (sort) {
            cursor = cursor.sort(sort);
        }

        if (skip) {
            cursor.skip(skip);
        }

        if (limit) {
            cursor.limit(limit);
        }

        return _.map(cursor.all(), function (item) {
            return _.extend({}, item);
        });
    },

    readById: function (dataQuery, expand) {
        var self = this;
        var expandResult;
        return self._prepareExpand(expand, dataQuery, false)
            .then(function (prepareExpandResult) {
                expandResult = prepareExpandResult;
                return self._getCollection(dataQuery.collectionName);
            })
            .then(function (collection) {
                return new rsvp.Promise(function (resolve, reject) {
                    var item = self._getById(collection, dataQuery.additionalOptions.id);

                    if (!item) {
                        return reject(EverliveErrors.itemNotFound);
                    }

                    item = offlineTransformations.idTransform(item);
                    return self._expandResult(expandResult, item).then(resolve).catch(reject);
                });
            })
            .then(function (result) {
                return self._transformOfflineResult(result, null, dataQuery);
            });
    },

    _getById: function (collection, id) {
        if (!id) {
            throw new EverliveError('Id field is mandatory when using offline storage');
        }

        if (collection[id]) {
            var item = _.extend({}, collection[id]);
            var isDeleted = item && item[constants.offlineItemsStateMarker] === offlineItemStates.deleted;

            return isDeleted ? undefined : item;
        }
    },

    _prepareExpand: function (expand, dataQuery, isArray) {
        return new rsvp.Promise(function (resolve, reject) {
            if (expand) {
                expandProcessor.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
                    if (err) {
                        if (err.name === 'ExpandError') {
                            err.code = EverliveErrors.invalidExpandExpression.code;
                        }
                        return reject(err);
                    }
                    resolve(prepareResult);
                });
            } else {
                resolve();
            }
        });
    },

    _expandResult: function (prepareExpandResult, result) {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            if (prepareExpandResult) {
                expandProcessor.expand(prepareExpandResult.relationsTree, result, {
                    offlineModule: self
                }, function (err, result) {
                    if (err) {
                        if (err.name === 'ExpandError') {
                            err.code = EverliveErrors.invalidExpandExpression.code;
                        }
                        return reject(err);
                    }
                    resolve(result);
                });
            } else {
                resolve(result);
            }
        });
    },

    _getWithoutDeletedFilter: function (filter) {
        var withoutDeletedFilter = {
            $and: []
        };
        withoutDeletedFilter.$and.push(filter);
        var deleteOfflineFilter = {};
        deleteOfflineFilter[constants.offlineItemsStateMarker] = {$ne: offlineItemStates.deleted};
        withoutDeletedFilter.$and.push(deleteOfflineFilter);
        return withoutDeletedFilter;
    },

    _getUpdateItemsResult: function (updateItems) {
        var updatedItemCount = updateItems.length;
        var modifiedAtResult = updatedItemCount ? updateItems[0].ModifiedAt : new Date();

        return {
            ModifiedAt: modifiedAtResult,
            result: updatedItemCount
        };
    },

    update: function (dataQuery, filter) {
        var self = this;

        return this._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync).then(function (updateItems) {
            return self._getUpdateItemsResult(updateItems);
        });
    },

    remove: function (dataQuery, filter) {
        return this._removeItems(dataQuery, filter, dataQuery.isSync);
    },

    count: function (dataQuery, filter) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var filterResult = self._readInternal(collection, filter);
                    resolve({result: filterResult.length});
                }).catch(reject);
        });
    },

    _setItemDates: function (currentItem, itemToCreate, contentType) {
        // we need to manually clone the dates in order to dereference them from the original object as
        // _.extends will pass a reference to the original date instead of creating a new instance
        if (currentItem.CreatedAt && currentItem.CreatedAt instanceof Date) {
            itemToCreate.CreatedAt = utils.cloneDate(currentItem.CreatedAt);
        } else {
            itemToCreate.CreatedAt = new Date();
        }

        if (currentItem.ModifiedAt && currentItem.ModifiedAt instanceof Date) {
            itemToCreate.ModifiedAt = utils.cloneDate(currentItem.ModifiedAt);
        } else {
            itemToCreate.ModifiedAt = utils.cloneDate(itemToCreate.CreatedAt);
        }

        itemToCreate.CreatedBy = itemToCreate.CreatedBy || this.everlive.setup.principalId || constants.guidEmpty;
        itemToCreate.ModifiedBy = itemToCreate.ModifiedBy || itemToCreate.CreatedBy;
        if (contentType === 'Users') {
            itemToCreate.Owner = itemToCreate._id;
        } else {
            itemToCreate.Owner = itemToCreate.CreatedBy || constants.guidEmpty;
        }
    },

    _mapCreateItem: function (currentItem, collection, isSync, preserveState, contentType) {
        var self = this;

        var itemToCreate = _.extend({}, currentItem);
        itemToCreate._id = itemToCreate.Id || utils.uuid();
        delete itemToCreate.Id;

        var existingItem = self._getById(collection, itemToCreate._id);
        var itemExists = !!existingItem;
        var state;
        if (itemExists && (!isSync && !preserveState)) {
            // TODO: [offline] return the same error as the server does
            throw new EverliveError('An item with the specified id already exists');
        } else {
            if (isSync && preserveState && itemExists) {
                state = existingItem[constants.offlineItemsStateMarker];
            } else {
                state = isSync ? undefined : offlineItemStates.created; // set the state to created only if not syncing
            }
        }

        function processItemResult() {
            self._setItemDates(currentItem, itemToCreate, contentType);
            self._setItem(collection, _.extend({}, itemToCreate), state);
            return itemToCreate;
        }

        if (utils.isContentType.files(contentType)) {
            return self.offlineFilesProcessor.upsertFileFromObject(itemToCreate, true, isSync).then(processItemResult);
        } else {
            return processItemResult();
        }
    },

    _createItems: function (contentType, items, isSync, preserveState) {
        var self = this;
        return this._getCollection(contentType)
            .then(function (collection) {
                var itemsForCreate = _.isArray(items) ? items : [items];
                var createdItems = _.map(itemsForCreate, function (currentItem) {
                    return self._mapCreateItem(currentItem, collection, isSync, preserveState, contentType);
                });

                return rsvp.all(createdItems)
                    .then(function (items) {
                        return self._persistData(contentType)
                            .then(function () {
                                // Ids are generated regardless of the autoGenerateId option. However the Id's are omitted when returning
                                // the items to the client if autoGenerateId is false
                                if (!self._shouldAutogenerateIdForContentType(contentType) && !isSync) {
                                    createdItems = offlineTransformations.removeIdTransform(items);
                                }

                                return items;
                            });
                    });
            });
    },

    _applyUpdateOperation: function (originalUpdateExpression, itemToUpdate, collection, isSync, modifiedAt) {
        var dbOperators = utils.getDbOperators(originalUpdateExpression, true);
        var hasDbOperator = dbOperators.length !== 0;

        var updateExpression;
        if (hasDbOperator) {
            updateExpression = originalUpdateExpression;
        } else {
            updateExpression = {
                $set: originalUpdateExpression
            };
        }
        var updateExpressionForUser = {
            ModifiedBy: this.everlive.setup.principalId || constants.guidEmpty
        };
        updateExpression.$set = _.extend(updateExpressionForUser, updateExpression.$set);

        if (isSync) {
            updateExpression.$set.ModifiedAt = utils.cloneDate(originalUpdateExpression.ModifiedAt || modifiedAt);
        }

        mongoQuery(itemToUpdate, {}, updateExpression, {strict: true}); // Setting strict to true so only exact matches would be updated

        itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
        delete itemToUpdate.Id;

        var newState;
        if (isSync) {
            newState = undefined;
        } else if (itemToUpdate[constants.offlineItemsStateMarker] === offlineItemStates.created) {
            newState = offlineItemStates.created;
        } else {
            newState = offlineItemStates.modified;
        }

        this._setItem(collection, itemToUpdate, newState);
    },

    updateFileContent: function (dataQuery) {
        var isSync = dataQuery.isSync;
        var updateExpression = dataQuery.data;
        var self = this;
        var itemId = dataQuery.additionalOptions.id;
        var updateItems;
        var typeName = dataQuery.collectionName;
        return this._getCollection(typeName)
            .then(function (collection) {
                var singleItemForUpdate = self._getById(collection, itemId);
                updateItems = [singleItemForUpdate];
                singleItemForUpdate.base64 = updateExpression.base64;
                singleItemForUpdate.Filename = updateExpression.Filename;
                singleItemForUpdate.ContentType = updateExpression.ContentType;
                delete singleItemForUpdate.Uri;

                return self._overwriteFile(itemId, singleItemForUpdate, isSync)
                    .then(function () {
                        self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection);
                        self._setItem(collection, singleItemForUpdate, constants.offlineItemStates.modified);
                        return self._persistData(typeName);
                    })
                    .then(function () {
                        return self._getUpdateItemsResult(updateItems);
                    })
            });
    },

    _overwriteFile: function (itemId, itemForUpdate, isSync) {
        var self = this;

        return self.everlive.offlineStorage.files.purge(itemId)
            .then(function () {
                return self.offlineFilesProcessor.upsertFileFromObject(itemForUpdate, true, isSync);
            })
    },

    _updateItems: function (dataQuery, updateExpression, filter, isSync) {
        var self = this;
        var collectionName = dataQuery.collectionName;

        return self._getCollection(collectionName)
            .then(function (collection) {
                var updateItems;

                if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
                    var itemId = dataQuery.additionalOptions.id;
                    var singleItemForUpdate = self._getById(collection, itemId);
                    updateItems = [singleItemForUpdate];

                    if (utils.isContentType.files(collectionName) && updateExpression.$set && updateExpression.$set.Filename || updateExpression.Filename) {
                        var filename = updateExpression.Filename || updateExpression.$set.Filename;
                        var extension = path.extname(filename);
                        return self.everlive.offlineStorage.files.changeFileExtensionById(itemId, extension)
                            .then(function () {
                                self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
                                return self._persistData(collectionName);
                            })
                            .then(function () {
                                return updateItems;
                            });
                    } else {
                        self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
                    }
                } else {
                    updateItems = self._readInternal(collection, filter);
                    for (var i = 0; i < updateItems.length; i++) {
                        var itemToUpdate = updateItems[i];
                        var itemExists = !!self._getById(collection, itemToUpdate._id.toString());

                        if (!itemExists && !isSync) {
                            // TODO: [offline] return the correct error
                            throw new Error(EverliveErrors.itemNotFound);
                        }

                        self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync, dataQuery.ModifiedAt);
                    }
                }

                return self._persistData(collectionName)
                    .then(function () {
                        return updateItems;
                    });
            });
    },

    _getAllCollections: function () {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            self._persister.getAllData(function (allData) {
                _.each(allData, function (value, key) {
                    var decryptedData = self._encryptionProvider.decrypt(value);
                    allData[key] = JSON.parse(decryptedData || '{}', utils.parseUtilities.getReviver());
                });

                resolve(allData);
            }, reject);
        });
    },

    _getCollection: function (contentType) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            // check the persister if there is no data in the collection cache for this content type
            if (!self._collectionCache[contentType]) {
                self._persister.getData(contentType, function (data) {
                    var decryptedDataRaw = self._encryptionProvider.decrypt(data);
                    var decryptedData = JSON.parse(decryptedDataRaw || '{}', utils.parseUtilities.getReviver());
                    self._collectionCache[contentType] = decryptedData;

                    resolve(self._collectionCache[contentType]);
                }, reject);
            } else {
                resolve(self._collectionCache[contentType]);
            }
        });
    },

    _setItem: function (collection, item, state) {
        if (!state) {
            delete item[constants.offlineItemsStateMarker];
        } else {
            item[constants.offlineItemsStateMarker] = state;
        }

        collection[item._id] = item;
    },


    _getDirtyItems: function (collection) {
        var filter = {};
        filter[constants.offlineItemsStateMarker] = {$exists: true};
        var query = mingo.Query(filter);
        var cursor = mingo.Cursor(collection, query);
        return cursor.all();
    },

    _persistData: function (contentType) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            var contentTypeData = self._collectionCache[contentType] || {};
            self._transformPersistedData(contentType, contentTypeData);
            var contentTypeDataRaw = JSON.stringify(contentTypeData);
            var contentTypeDataRawEncrypted = self._encryptionProvider.encrypt(contentTypeDataRaw);
            self._persister.saveData(contentType, contentTypeDataRawEncrypted, resolve, reject);
        });
    },

    _shouldAutogenerateIdForContentType: function (contentType) {
        return !(this.setup && this.setup.typeSettings && this.setup.typeSettings[contentType] && this.setup.typeSettings[contentType].autoGenerateId === false);
    },

    _clearItem: function (collection, item) {
        delete collection[item._id];
    },

    _mapRemoveItem: function (itemToRemove, collection, isSync, collectionName) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            if (utils.isContentType.files(collectionName)) {
                return self.everlive.offlineStorage.files.purge(itemToRemove._id).then(resolve, reject);
            } else {
                return resolve();
            }
        }).then(function () {
                itemToRemove._id = itemToRemove._id || itemToRemove.Id;

                var itemExists = !!self._getById(collection, itemToRemove._id.toString());
                if (!itemExists && !isSync) {
                    throw new EverliveError('Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.');
                }

                // if the item has existed only offline or the data is syncing
                // and the item was deleted by the conflict resolution strategy
                var removeFromMemory = itemToRemove[constants.offlineItemsStateMarker] === offlineItemStates.created || isSync;
                if (removeFromMemory) {
                    self._clearItem(collection, itemToRemove);
                } else {
                    self._setItem(collection, itemToRemove, offlineItemStates.deleted);
                }
            });
    },

    _removeItems: function (dataQuery, filter, isSync) {
        var self = this;
        var collectionName = dataQuery.collectionName;

        return self._getCollection(collectionName)
            .then(function (collection) {
                var itemsToRemove = self._readInternal(collection, filter);

                var removedItemsPromises = _.map(itemsToRemove, function (itemToRemove) {
                    return self._mapRemoveItem(itemToRemove, collection, isSync, collectionName);
                });

                return rsvp.all(removedItemsPromises);
            })
            .then(function (itemsToRemove) {
                return self._persistData(collectionName)
                    .then(function () {
                        return itemsToRemove;
                    });
            })
            .then(function (itemsToRemove) {
                return self._transformOfflineResult(itemsToRemove.length);
            });
    },

    _applyTransformations: function (transformedResult, transformations) {
        if (Array.isArray(transformedResult.result)) {
            _.each(transformations, function (transformation) {
                transformedResult.result.map(function (value, key) {
                    transformedResult.result[key] = transformation(value);
                });
            });
        } else {
            _.each(transformations, function (transformation) {
                transformedResult.result = transformation(transformedResult.result);
            });
        }
    },

    _transformOfflineResult: function (resultSet, count, dataQuery, additionalTransformations) {
        var transformedResult = {
            result: resultSet,
            count: count || (resultSet || []).length
        };

        if ((count !== undefined && count !== null) || Array.isArray(resultSet)) {
            transformedResult.count = count || resultSet.length;
        }

        var transformations = [];

        transformations.push(offlineTransformations.idTransform);
        transformations.push(offlineTransformations.removeMarkersTransform);

        if (dataQuery) {
            var includeCount = dataQuery.getHeader(Headers.includeCount);
            if (includeCount === false) {
                delete transformedResult.count;
            }

            var singleFieldExpression = dataQuery.getHeader(Headers.singleField);
            if (typeof singleFieldExpression === 'string') {
                transformations.push(offlineTransformations.singleFieldTransform.bind(this, singleFieldExpression));
            }
        }

        if (additionalTransformations) {
            transformations = transformations.concat(additionalTransformations);
        }

        this._applyTransformations(transformedResult, transformations);

        if (transformedResult.count === undefined) {
            delete transformedResult.count;
        }

        return transformedResult;
    },

    _transformPersistedData: function (contentType, contentTypeData) {
        var transformFields = [];

        if (contentType === 'Users') {
            transformFields = transformFields.concat(['Password', 'SecretQuestionId', 'SecretAnswer']);
        }

        if (transformFields.length) {
            _.each(contentTypeData, function (contentTypeObject) {
                offlineTransformations.removeFieldsTransform(contentTypeObject, transformFields);
            });
        }
    },

    purgeAll: function (success, error) {
        var self = this;
        this._collectionCache = {};
        return buildPromise(function (success, error) {
            self._persister.purgeAll(success, error);
        }, success, error);
    },

    purge: function (contentType, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            self._persister.purge(contentType, success, error);
        }, success, error);
    }
};

module.exports = OfflineQueryProcessor;
},{"../EverliveError":39,"../ExpandProcessor":40,"../common":48,"../constants":49,"../query/DataQuery":68,"../query/Query":69,"../utils":82,"./offlineTransformations":64,"path":5}],61:[function(require,module,exports){
var DataQuery = require('../query/DataQuery');
var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;
var constants = require('../constants');
var offlineItemStates = constants.offlineItemStates;
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var utils = require('../utils');
var Request = require('../Request');
var offlineTransformations = require('./offlineTransformations');
var buildPromise = require('../utils').buildPromise;
var OfflineQueryProcessor = require('./OfflineQueryProcessor');
var OfflineFilesProcessor = require('./OfflineFilesProcessor');
var OfflineFilesModule = require('./OfflineFilesModule');
var path = require('path');

var syncLocation = {
    server: 'server',
    client: 'client'
};

var syncStartEventData = {
    cancel: function () {
        throw new EverliveError(EverliveErrors.syncCancelledByUser.message, EverliveErrors.syncCancelledByUser.code);
    }
};


/**
 * @class OfflineModule
 * @classDesc A class providing access to the various offline storage features.
 */

/**
 * Represents the {@link OfflineModule} class.
 * @memberOf Everlive.prototype
 * @member {OfflineModule} offlineStorage
 */

module.exports = (function () {
    function OfflineModule(everlive, options, persister, encryptionProvider) {
        this._everlive = everlive;
        this.setup = options;
        this._isSynchronizing = false;
        this._encryptionProvider = encryptionProvider;

        if (this.setup.enabled) {
            this._offlineFilesProcessor = new OfflineFilesProcessor(this.setup, this._everlive);
            this._queryProcessor = new OfflineQueryProcessor(persister, encryptionProvider, this._offlineFilesProcessor, this._everlive, this.setup);


            /**
             * @memberOf Everlive.prototype
             * @instance
             * @description An instance of the [OfflineFilesModule]{@link OfflineFilesModule} class for working with files in offline mode.
             * @member {OfflineFilesModule} files
             */
            this.files = new OfflineFilesModule(this._offlineFilesProcessor, this._everlive);
        }
    }

    var getSyncFilterForItem = function (item) {
        var filter = getSyncFilterNoModifiedAt(item);
        filter.ModifiedAt = item.ModifiedAt;
        return filter;
    };

    var getSyncFilterNoModifiedAt = function (item) {
        return {
            Id: item.Id
        }
    };


    OfflineModule.prototype = {
        /**
         * Removes all data from the offline storage.
         * @method purgeAll
         * @name purgeAll
         * @memberOf OfflineModule.prototype
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Removes all data from the offline storage.
         * @method purgeAll
         * @name purgeAll
         * @memberOf OfflineModule.prototype
         * @returns Promise
         */
        purgeAll: function (success, error) {
            return this._queryProcessor.purgeAll(success, error);
        },

        /**
         * Removes all data for a specific content type from the offline storage.
         * @method purge
         * @name purge
         * @memberOf OfflineModule.prototype
         * @param {string} contentType The content type to purge.
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Removes all data for a specific content type from the offline storage.
         * @method purge
         * @name purge
         * @memberOf OfflineModule.prototype
         * @param {string} contentType The content type to purge.
         * @returns Promise
         */
        purge: function (contentType, success, error) {
            return this._queryProcessor.purge(contentType, success, error);
        },

        processQuery: function (query) {
            return this._queryProcessor.processQuery(query);
        },

        _setOffline: function (offline) {
            this.setup.offline = offline;
        },

        isOnline: function () {
            return !this.setup.offline;
        },

        _prepareSyncData: function (contentTypesForSync) {
            var self = this;

            var contentTypesSyncData = {};
            var conflicts = [];
            _.each(contentTypesForSync, function (contentType, typeName) {
                var syncItems = offlineTransformations.idTransform(contentType.offlineItemsToSync);
                var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
                conflicts.push(syncData.conflicts);
                contentTypesSyncData[typeName] = syncData.itemsForSync;
            });

            return {
                conflicts: conflicts,
                contentTypesSyncData: contentTypesSyncData
            };
        },

        _resolveConflicts: function (syncData) {
            var self = this;
            return this._applyResolutionStrategy(syncData.conflicts)
                .then(function () {
                    return self._mergeResolvedConflicts(syncData.conflicts, syncData.contentTypesSyncData);
                })
                .then(function () {
                    return syncData.contentTypesSyncData;
                });
        },

        isSynchronizing: function () {
            return this._isSynchronizing;
        },

        _fireSyncStart: function () {
            var self = this;

            return new rsvp.Promise(function (resolve) {
                if (!self._isSynchronizing) {
                    self._isSynchronizing = true;
                    self._everlive._emitter.emit('syncStart', syncStartEventData);
                    resolve();
                } else {
                    resolve();
                }
            });
        },

        _fireSyncEnd: function () {
            var self = this;

            this._isSynchronizing = false;
            _.each(this._syncResultInfo.syncedItems, function (syncedItems) {
                self._syncResultInfo.syncedToServer += _.where(syncedItems, {storage: syncLocation.server}).length;
                self._syncResultInfo.syncedToClient += _.where(syncedItems, {storage: syncLocation.client}).length;
            });

            this._everlive._emitter.emit('syncEnd', this._syncResultInfo);
            delete this._syncResultInfo;
        },

        _eachSyncItem: function (items, getFilterFunction, contentTypeName, operation) {
            var self = this;

            _.each(items, function (item) {
                var itemFilter = getFilterFunction(item.remoteItem);
                // if we already have an error for this item we do not want to try and sync it again
                var resultItem = item.resultingItem;
                var isCustom = item.isCustom;
                if (_.some(self._syncResultInfo.failedItems[contentTypeName], {itemId: resultItem.Id})) {
                    return;
                }

                operation(resultItem, itemFilter, isCustom);
            });
        },

        _shouldAutogenerateIdForContentType: function (collectionName) {
            return this._queryProcessor._shouldAutogenerateIdForContentType(collectionName);
        },

        _addCreatedFileToSyncPromises: function (resultingItemsForCreate, syncPromises, collectionName) {
            var self = this;

            _.each(resultingItemsForCreate, function (item) {
                var filesCollection = self._everlive.files;
                syncPromises[item.Id] = new rsvp.Promise(function (resolve, reject) {
                    self.files.getOfflineLocation(item.Id)
                        .then(function (location) {
                            if (location) {
                                return self._transferFile(false, item, location);
                            }
                        }, function (err) {
                            reject({
                                type: offlineItemStates.created,
                                items: item,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            });
                        })
                        .then(function (res) {
                            var mergedWithServerResponseItem = _.extend({}, item, res.result);
                            self._addSyncedItemToResult(mergedWithServerResponseItem, collectionName, syncLocation.server, offlineItemStates.created);
                            return filesCollection
                                .isSync(true)
                                .useOffline(true)
                                .updateSingle(mergedWithServerResponseItem);
                        }, function (err) {
                            reject({
                                type: offlineItemStates.created,
                                items: item,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            });
                        })
                        .then(resolve, function (err) {
                            reject({
                                type: offlineItemStates.modified,
                                items: item,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.client
                            });
                        });
                });
            });
        },

        _transferFile: function (isUpdate, item, location) {
            var sdk = this._everlive;

            return new rsvp.Promise(function (resolve, reject) {
                var self = this;
                var uploadUrl = sdk.files.getUploadUrl();
                var fileExistsPromise = utils.successfulPromise();

                if (isUpdate) {
                    fileExistsPromise = new rsvp.Promise(function (resolve) {
                        sdk.files
                            .isSync(true)
                            .applyOffline(false)
                            .getById(item.Id)
                            .then(function () {
                                resolve(true);
                            }).catch(function () {
                                resolve(false);
                            });
                    });
                }

                fileExistsPromise.then(function (fileExistsOnServer) {
                    var canUpdate = isUpdate && fileExistsOnServer;
                    if (canUpdate) {
                        uploadUrl += '/' + item.Id + '/Content';
                    }

                    var fileTransfer = new FileTransfer();
                    var fileKey = constants.fileUploadKey;
                    var options = {
                        fileKey: fileKey,
                        httpMethod: canUpdate ? 'PUT' : 'POST',
                        mimeType: item.ContentType,
                        fileName: item.Filename,
                        headers: sdk.buildAuthHeader()
                    };

                    options.params = {};

                    _.each(item, function (value, key) {
                        var prefixedKey = constants.fileUploadKey + constants.fileUploadDelimiter + key;
                        options.params[prefixedKey] = value;
                    });

                    fileTransfer.upload(location, uploadUrl, function (result) {
                        var parsedResult = utils.parseUtilities.parseJSON(result.response);
                        if (parsedResult.Result === false) {
                            reject.apply(self, arguments);
                        } else if (_.isArray(parsedResult.Result)) {
                            resolve({
                                result: parsedResult.Result[0]
                            })
                        } else {
                            resolve(parsedResult);
                        }
                    }, reject, options);
                });
            });
        },

        _addCreatedObjectToSyncPromises: function (syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids) {
            var self = this;

            syncPromises[offlineItemStates.created] =
                new rsvp.Promise(function (resolve, reject) {
                    dataCollection
                        .isSync(true)
                        .applyOffline(false)
                        .create(resultingItemsForCreate)
                        .then(function (res) {
                            resultingItemsForCreate = _.map(resultingItemsForCreate, function (item, index) {
                                item.Id = res.result[index].Id;
                                item.CreatedAt = item.ModifiedAt = res.result[index].CreatedAt;
                                if (contentTypeData.isCustom) {
                                    self._addSyncedItemToResult(item, collectionName, syncLocation.client, offlineItemStates.created);
                                }

                                return item;
                            });
                        }, function (err) {
                            reject({
                                type: offlineItemStates.created,
                                items: resultingItemsForCreate,
                                contentType: collectionName,
                                error: err,
                                storage: syncLocation.server
                            })
                        })
                        .then(function () {
                            return dataCollection
                                .isSync(true)
                                .useOffline(true)
                                .create(resultingItemsForCreate)
                                .then(function () {
                                    _.each(resultingItemsForCreate, function (createdItem) {
                                        self._addSyncedItemToResult(createdItem, collectionName, syncLocation.server, offlineItemStates.created);
                                    });
                                }, function (err) {
                                    reject({
                                        type: offlineItemStates.created,
                                        items: resultingItemsForCreate,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.client
                                    })
                                });
                        })
                        .then(function () {
                            if (ids && ids.length) {
                                var filter = {Id: {$in: ids}};
                                return dataCollection
                                    .isSync(true)
                                    .useOffline(true)
                                    .destroy(filter).catch(function (err) {
                                        reject({
                                            type: offlineItemStates.created,
                                            items: resultingItemsForCreate,
                                            contentType: collectionName,
                                            error: err,
                                            storage: syncLocation.client
                                        })
                                    });
                            }
                        })
                        .then(resolve, function (err) {
                            reject({
                                type: offlineItemStates.created,
                                items: resultingItemsForCreate,
                                contentType: collectionName,
                                error: err
                            });
                        });
                });

            return resultingItemsForCreate;
        },

        _addCreatedItemsForSync: function (contentTypeData, syncPromises, dataCollection) {
            var collectionName = dataCollection.collectionName;

            var resultingItemsForCreate = _.pluck(contentTypeData.createdItems, 'resultingItem');
            var ids;
            if (!this._shouldAutogenerateIdForContentType(collectionName)) {
                ids = _.pluck(resultingItemsForCreate, 'Id');
                resultingItemsForCreate = offlineTransformations.removeIdTransform(resultingItemsForCreate);
            }

            if (utils.isContentType.files(collectionName)) {
                return this._addCreatedFileToSyncPromises(resultingItemsForCreate, syncPromises, collectionName);
            } else {
                return this._addCreatedObjectToSyncPromises(syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids);
            }
        },

        _addUpdatedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemUpdateOperation) {
            var self = this;
            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.modifiedItems, getFilterOperation, collectionName, itemUpdateOperation);
        },

        _addDeletedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemDeleteOperation) {
            var self = this;

            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.deletedItems, getFilterOperation, collectionName, itemDeleteOperation);
        },

        _onSyncResponse: function (res, item, collectionName, operation, isCustomItem) {
            var self = this;

            if (res.result !== 1) {
                return new rsvp.Promise(function (resolve, reject) {
                    reject(_.extend({}, EverliveErrors.syncConflict, {
                        contentType: collectionName
                    }));
                });
            } else {
                if (operation === DataQuery.operations.update) {
                    self._addSyncedItemToResult(item, collectionName, syncLocation.server, offlineItemStates.modified);
                    var updatedItem = _.extend({}, item, {
                        ModifiedAt: res.ModifiedAt
                    });

                    var updateQuery = new DataQuery({
                        operation: operation,
                        data: updatedItem,
                        additionalOptions: {
                            id: item.Id
                        },
                        collectionName: collectionName,
                        isSync: true
                    });

                    return this.processQuery(updateQuery)
                        .then(function () {
                            if (isCustomItem) {
                                self._addSyncedItemToResult(item, collectionName, syncLocation.client, offlineItemStates.modified);
                            }
                        });
                } else if (operation === DataQuery.operations.remove) {
                    self._addSyncedItemToResult(item, collectionName, syncLocation.server, offlineItemStates.deleted);
                    return this._purgeById(collectionName, item.Id)
                        .then(function () {
                            if (isCustomItem) {
                                self._addSyncedItemToResult(item, collectionName, syncLocation.client, offlineItemStates.deleted);
                            }
                        });
                }
            }
        },

        _purgeById: function (contentType, itemId) {
            var self = this;

            return this._queryProcessor._getCollection(contentType)
                .then(function (collection) {
                    delete collection[itemId];
                    return self._queryProcessor._persistData(contentType);
                });
        },

        sync: function () {
            var self = this;
            self._syncResultInfo = self._syncResultInfo || {
                syncedItems: {},
                syncedToServer: 0,
                syncedToClient: 0,
                failedItems: {},
                error: undefined // added for visibility
            };

            if (!this.isOnline()) {
                throw new EverliveError('Cannot synchronize while offline');
            }

            self._fireSyncStart()
                .then(function () {
                    return self._applySync();
                })
                .then(function (syncResults) {
                    var conflictsWhileSync = [];
                    _.each(syncResults, function (syncResult, itemId) {
                        if (syncResult && syncResult.state === 'rejected') {
                            var targetType = syncResult.reason.contentType;
                            if (syncResult.reason && syncResult.reason.code === EverliveErrors.syncConflict.code) {
                                conflictsWhileSync.push(syncResult);
                            } else {
                                // to save time and traffic we are using a single create request for all items
                                // this is why if there is an error we need to split the items we tried to create
                                // and set the same error for all items.
                                var type = syncResult.reason.type;
                                self._syncResultInfo.failedItems[targetType] = self._syncResultInfo.failedItems[targetType] || [];
                                if (type === offlineItemStates.created) {
                                    _.each(syncResult.reason.items, function (item) {
                                        self._syncResultInfo.failedItems[targetType]
                                            .push(_.extend({itemId: item.Id}, _.pick(syncResult.reason, 'storage', 'type', 'error')));
                                    });
                                } else {
                                    self._syncResultInfo.failedItems[targetType]
                                        .push(_.extend({itemId: itemId}, _.pick(syncResult.reason, 'storage', 'type', 'error')));
                                }
                            }
                        }
                    });

                    if (conflictsWhileSync.length) {
                        return self.sync();
                    } else {
                        self._fireSyncEnd();
                    }
                })
                .catch(function (err) {
                    self._syncResultInfo.error = err;
                    self._fireSyncEnd();
                });
        },

        _handleKeepServer: function (typeName, conflictingItem, offlineSyncOperations) {
            var self = this;

            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var syncQuery;
            if (serverItem && clientItem) {
                // update the item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    additionalOptions: {
                        id: serverItem.Id
                    },
                    data: serverItem
                });
            } else if (serverItem && !clientItem) {
                // create item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem
                });
            } else if (!serverItem && clientItem) {
                // delete item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.removeSingle,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.');
            }

            syncQuery.isSync = true;
            offlineSyncOperations.push(new rsvp.Promise(function (resolve, reject) {
                self.processQuery(syncQuery)
                    .then(function () {
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                self._addSyncedItemToResult(serverItem, typeName, syncLocation.client, offlineItemStates.modified);
                                break;
                            case DataQuery.operations.create:
                                self._addSyncedItemToResult(serverItem, typeName, syncLocation.client, offlineItemStates.created);
                                break;
                            case DataQuery.operations.removeSingle:
                                self._addSyncedItemToResult(clientItem, typeName, syncLocation.client, offlineItemStates.deleted);
                                break;
                        }
                        resolve();
                    }, function (err) {
                        var itemId;
                        var operation;
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                itemId = serverItem.Id;
                                operation = offlineItemStates.modified;
                                break;
                            case DataQuery.operations.create:
                                itemId = serverItem.Id;
                                operation = offlineItemStates.created;
                                break;
                            case DataQuery.operations.removeSingle:
                                itemId = clientItem.Id;
                                operation = offlineItemStates.deleted;
                                break;
                        }

                        reject({
                            itemId: itemId,
                            type: operation,
                            contentType: syncQuery.collectionName,
                            error: err,
                            storage: syncLocation.client
                        })
                    })
            }));
        },

        _handleKeepClient: function (conflictingItem, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            if (serverItem && clientItem) {
                var modifiedObject = _.extend(clientItem, {ModifiedAt: new Date(serverItem.ModifiedAt)});

                contentTypeSyncData.modifiedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: modifiedObject
                });
            } else if (serverItem && !clientItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem
                });
            } else if (!serverItem && clientItem) {
                contentTypeSyncData.createdItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: clientItem
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.');
            }
        },

        _handleCustom: function (conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var customItem = _.omit(conflictingItem.result.item, 'CreatedAt', 'ModifiedAt');
            if (serverItem && customItem) {
                var createItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem // create the server item offline and it will be updated when sync finishes
                });

                createItemOfflineQuery.preserveState = true;
                createItemOfflineQuery.isSync = true;

                offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));
            }

            if (serverItem && customItem && !clientItem) {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            } else if (serverItem && !customItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem,
                    isCustom: true
                });
            } else if (!serverItem && customItem && clientItem) {
                var updateItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    data: customItem,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });

                offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));
                customItem.Id = clientItem.Id;

                contentTypeSyncData.createdItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            } else {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem,
                    isCustom: true
                });
            }
        },

        _mergeResolvedConflicts: function (conflicts, syncData) {
            var self = this;

            var offlineSyncOperations = [];
            _.each(conflicts, function (conflict) {
                var typeName = conflict.contentTypeName;
                _.each(conflict.conflictingItems, function (conflictingItem) {
                    var contentTypeSyncData = syncData[typeName];
                    switch (conflictingItem.result.resolutionType) {
                        case constants.ConflictResolution.KeepServer:
                            self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations);
                            break;
                        case constants.ConflictResolution.KeepClient:
                            self._handleKeepClient(conflictingItem, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Custom:
                            if (utils.isContentType.files(typeName)) {
                                var err = EverliveErrors.customFileSyncNotSupported;
                                throw new EverliveError(err.message, err.code);
                            }

                            self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Skip:
                            break;
                    }
                });
            });

            return rsvp.all(offlineSyncOperations);
        },

        _getSyncItemStates: function (contentType, offlineItems, serverItems) {
            var self = this;

            var contentTypeSyncData = {
                itemsForSync: {
                    createdItems: [],
                    modifiedItems: [],
                    deletedItems: []
                },
                conflicts: {
                    contentTypeName: contentType,
                    conflictingItems: []
                }
            };

            _.each(offlineItems, function (offlineItem) {
                var serverItem = _.findWhere(serverItems, {Id: offlineItem.Id});
                if (serverItem) {
                    if (serverItem.Id === offlineItem.Id && offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                        self._syncResultInfo.failedItems[contentType] = self._syncResultInfo.failedItems[contentType] || [];
                        self._syncResultInfo.failedItems[contentType].push({
                            itemId: serverItem.Id,
                            type: offlineItemStates.created,
                            storage: syncLocation.client,
                            error: EverliveErrors.syncError
                        });

                        return;
                    }

                    var clientItemChanged = !!offlineItem[constants.offlineItemsStateMarker];
                    var hasUpdateConflict = false;

                    if (clientItemChanged) {
                        hasUpdateConflict = serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime()
                        || offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted;
                        //TODO: when an item is removed offline its ModifiedAt field is not set, check if it needs to be set or we can use this
                    }

                    if (hasUpdateConflict) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
                            // otherwise it is a simple modification conflict
                            clientItem: offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted ? null : offlineItem,
                            serverItem: serverItem,
                            result: {}
                        });
                    } else {
                        if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted) {
                            contentTypeSyncData.itemsForSync.deletedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        } else {
                            contentTypeSyncData.itemsForSync.modifiedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        }
                    }
                } else {
                    // if the item in memory has been modified, but the item on the server has been deleted
                    if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.modified) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            clientItem: offlineItem,
                            serverItem: null,
                            result: {}
                        });
                    } else {
                        contentTypeSyncData.itemsForSync.createdItems.push({
                            remoteItem: serverItem,
                            resultingItem: offlineItem
                        });
                    }
                }

                delete offlineItem[constants.offlineItemsStateMarker];
            });

            return contentTypeSyncData;
        },

        _setResolutionTypeForItem: function (resolutionType, conflictingItem) {
            conflictingItem.result = {
                resolutionType: resolutionType
            };
        },

        _applyResolutionStrategy: function (conflicts) {
            var self = this;
            var conflictResolutionStrategy = self.setup.conflicts.strategy;
            return new rsvp.Promise(function (resolve, reject) {
                var conflictResolutionPromises = [];

                for (var i = 0; i < conflicts.length; i++) {
                    var conflict = conflicts[i];
                    if (conflict.conflictingItems.length) {
                        switch (conflictResolutionStrategy) {
                            case constants.ConflictResolutionStrategy.ServerWins:
                                _.each(conflict.conflictingItems,
                                    self._setResolutionTypeForItem.bind(self, constants.ConflictResolution.KeepServer));
                                break;
                            case constants.ConflictResolutionStrategy.Custom:
                                var customStrategy = self.setup.conflicts.implementation;
                                if (!customStrategy) {
                                    return reject(new EverliveError('Implementation of the conflict resolution strategy ' +
                                    'must be provided when set to Custom'));
                                }

                                conflictResolutionPromises.push(new rsvp.Promise(function (resolve) {
                                    customStrategy(conflicts, resolve)
                                }));
                                break;
                            default:
                                return reject(new EverliveError('Invalid resolution strategy provided'));
                        }
                    }
                }

                rsvp.all(conflictResolutionPromises)
                    .then(function () {
                        resolve();
                    });
            });
        },

        _getSyncPromiseBatch: function (contentType, batchIds) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var dataQuery = new DataQuery({
                    collectionName: contentType,
                    filter: {
                        'Id': {
                            '$in': batchIds
                        }
                    },
                    operation: DataQuery.operations.read,
                    onSuccess: function (res) {
                        resolve(res.result);
                    },
                    applyOffline: false,
                    onError: reject
                });

                var getRequestOptionsFromQuery = RequestOptionsBuilder[dataQuery.operation];
                var requestOptions = getRequestOptionsFromQuery(dataQuery);
                var request = new Request(self._everlive.setup, requestOptions);
                request.send();
            });
        },

        _getDirtyItems: function (collection) {
            return this._queryProcessor._getDirtyItems(collection);
        },

        _getSyncPromiseForCollection: function (collection, contentType) {
            var self = this;

            var batches = [];
            var batchSize = constants.syncBatchSize;

            var offlineItemsToSync = self._getDirtyItems(collection);

            var allIdsForSync;
            if (this._shouldAutogenerateIdForContentType(contentType)) {
                allIdsForSync = _.pluck(offlineItemsToSync, '_id');
            } else {
                allIdsForSync = _.pluck(_.reject(offlineItemsToSync, function (offlineItem) {
                    return offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created;
                }), '_id');
            }

            var batchCount = Math.ceil(allIdsForSync.length / batchSize);

            for (var i = 0; i < batchCount; i++) {
                var batchSkipSize = i * batchSize;
                var batchIds = allIdsForSync.slice(batchSkipSize, batchSkipSize + batchSize);
                var syncGetServerItemsPromise = this._getSyncPromiseBatch(contentType, batchIds);
                batches.push(syncGetServerItemsPromise);
            }

            return rsvp.all(batches)
                .then(function (serverItemsSyncResponses) {
                    var result = {
                        serverItems: []
                    };

                    _.each(serverItemsSyncResponses, function (serverItems) {
                        result.serverItems = _.union(result.serverItems, serverItems);
                    });

                    result.offlineItemsToSync = offlineItemsToSync;
                    return result;
                });
        },

        _addSyncedItemToResult: function (item, contentType, syncStorage, syncType) {
            if (!this._syncResultInfo.syncedItems[contentType]) {
                this._syncResultInfo.syncedItems[contentType] = [];
            }

            var syncInfo = {
                itemId: item.Id,
                type: syncType,
                storage: syncStorage
            };
            this._syncResultInfo.syncedItems[contentType].push(syncInfo);

            this._everlive._emitter.emit('itemSynced', syncInfo);
        },

        _getClientWinsSyncData: function (collections) {
            var self = this;
            var syncData = {};
            _.each(collections, function (collection, typeName) {
                if (!syncData[typeName]) {
                    syncData[typeName] = {
                        createdItems: [],
                        modifiedItems: [],
                        deletedItems: []
                    };
                }

                var dirtyItems = self._getDirtyItems(collection);
                var itemsForSync = offlineTransformations.idTransform(dirtyItems);

                _.each(itemsForSync, function (itemForSync) {
                    switch (itemForSync[constants.offlineItemsStateMarker]) {
                        case offlineItemStates.created:
                            syncData[typeName].createdItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.modified:
                            syncData[typeName].modifiedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.deleted:
                            syncData[typeName].deletedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                    }

                    delete itemForSync[constants.offlineItemsStateMarker];
                });
            });

            return syncData;
        },

        _getModifiedFilesForSyncClientWins: function (itemId, item, collectionName) {
            var self = this;
            var sdk = self._everlive;

            return new rsvp.Promise(function (resolve, reject) {
                var offlineFiles = self.files;
                offlineFiles.getOfflineLocation(itemId)
                    .then(function (location) {
                        if (location) {
                            return self._transferFile(true, item, location)
                                .then(function (result) {
                                    if (result.Result === false) {
                                        reject({
                                            type: offlineItemStates.modified,
                                            itemId: item.Id,
                                            contentType: collectionName,
                                            error: result,
                                            storage: syncLocation.server
                                        });
                                    } else {
                                        return {
                                            result: result
                                        };
                                    }
                                }, function (err) {
                                    reject({
                                        type: offlineItemStates.modified,
                                        itemId: item.Id,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.server
                                    });
                                });
                        } else {
                            return sdk.files
                                .isSync(true)
                                .applyOffline(false)
                                .updateSingle(item)
                                .then(function (response) {
                                    return response;
                                }, function (err) {
                                    reject({
                                        type: offlineItemStates.modified,
                                        itemId: item.Id,
                                        contentType: collectionName,
                                        error: err,
                                        storage: syncLocation.server
                                    });
                                });
                        }
                    })
                    .then(function (onlineResponse) {
                        var onlineResult = onlineResponse.result;
                        item.ModifiedAt = onlineResult.ModifiedAt;
                        self._addSyncedItemToResult(item, collectionName, syncLocation.server, offlineItemStates.modified);
                        return sdk.files
                            .isSync(true)
                            .useOffline(true)
                            .updateSingle(item);
                    })
                    .then(resolve)
                    .catch(function (err) {
                        reject({
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: err,
                            storage: syncLocation.server
                        });
                    });
            });
        },

        _getModifiedItemForSyncClientWins: function (dataCollection, item, collectionName) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                return dataCollection
                    .isSync(true)
                    .applyOffline(false)
                    .updateSingle(item)
                    .then(function (res) {
                        self._addSyncedItemToResult(item, collectionName, syncLocation.server, offlineItemStates.modified);
                        var updatedItem = _.extend({}, item, {
                            ModifiedAt: res.ModifiedAt
                        });

                        var updateQuery = new DataQuery({
                            operation: DataQuery.operations.update,
                            data: updatedItem,
                            additionalOptions: {
                                id: item.Id
                            },
                            collectionName: collectionName,
                            isSync: true
                        });

                        return self.processQuery(updateQuery);
                    }, function (res) {
                        reject({
                            storage: syncLocation.server,
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: res
                        });
                    })
                    .then(resolve, function (err) {
                        reject({
                            storage: syncLocation.client,
                            type: offlineItemStates.modified,
                            itemId: item.Id,
                            contentType: collectionName,
                            error: err
                        });
                    });
            });
        },

        _addModifiedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addUpdatedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item) {
                var itemId = item.Id;
                if (!itemId) {
                    throw new EverliveError('When updating an item it must have an Id field.');
                }
                var collectionName = dataCollection.collectionName;

                if (utils.isContentType.files(collectionName)) {
                    syncPromises[itemId] = self._getModifiedFilesForSyncClientWins(itemId, item, collectionName);
                } else {
                    syncPromises[itemId] = self._getModifiedItemForSyncClientWins(dataCollection, item, collectionName);
                }
            });
        },

        _addDeletedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addDeletedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection,
                function (item, itemFilter) {
                    var collectionName = dataCollection.collectionName;
                    syncPromises[item.Id] = new rsvp.Promise(function (resolve, reject) {
                        var itemId = item.Id;
                        if (!itemId) {
                            throw new EverliveError('When deleting an item it must have an Id field.');
                        }

                        return dataCollection
                            .isSync(true)
                            .applyOffline(false)
                            .destroySingle(itemFilter)
                            .then(function () {
                                self._addSyncedItemToResult(item, collectionName, syncLocation.server, offlineItemStates.deleted);
                                return self._purgeById(collectionName, item.Id).then(function () {
                                    resolve();
                                }, function (err) {
                                    reject(_.extend({}, {
                                        storage: syncLocation.client,
                                        type: offlineItemStates.deleted,
                                        contentType: collectionName,
                                        itemId: itemId,
                                        error: err
                                    }));
                                });
                            }, function (err) {
                                reject(_.extend({}, {
                                    storage: syncLocation.server,
                                    type: offlineItemStates.deleted,
                                    contentType: collectionName,
                                    error: err,
                                    itemId: itemId
                                }));
                            });
                    });
                });
        },

        _applyClientWins: function (collections) {
            var self = this;
            var syncData = this._getClientWinsSyncData(collections);
            var syncPromises = {};

            _.each(syncData, function (contentTypeData, typeName) {
                var dataCollection = self._everlive.data(typeName);
                if (contentTypeData.createdItems.length) {
                    self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.modifiedItems.length) {
                    self._addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.deletedItems.length) {
                    self._addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }
            });

            return rsvp.hashSettled(syncPromises);
        },

        _applyStandardSync: function (collections) {
            var self = this;

            var promises = {};
            _.each(collections, function (collection, contentType) {
                promises[contentType] = self._getSyncPromiseForCollection(collection, contentType);
            });

            return rsvp.hash(promises)
                .then(function (contentTypes) {
                    return self._prepareSyncData(contentTypes);
                })
                .then(function (syncData) {
                    return self._resolveConflicts(syncData);
                })
                .then(function (contentTypeSyncData) {
                    var syncPromises = {};
                    _.each(contentTypeSyncData, function (contentTypeData, collectionName) {
                        var dataCollection = self._everlive.data(collectionName);
                        if (contentTypeData.createdItems.length) {
                            self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                        }

                        if (contentTypeData.modifiedItems.length) {
                            self._addUpdatedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom) {
                                var itemId = item.Id;

                                if (utils.isContentType.files(collectionName)) {
                                    var filesCollection = self._everlive.files;
                                    syncPromises[itemId] = new rsvp.Promise(function (resolve, reject) {
                                        var offlineLocation;
                                        self.files.getOfflineLocation(itemId)
                                            .then(function (locationOnDisk) {
                                                offlineLocation = locationOnDisk;
                                            })
                                            .then(function () {
                                                return filesCollection
                                                    .isSync(true)
                                                    .applyOffline(false)
                                                    .getById(itemId);
                                            })
                                            .then(function (response) {
                                                var file = response.result;
                                                if (file.ModifiedAt.getTime() !== item.ModifiedAt.getTime()) {
                                                    reject(_.extend({}, EverliveErrors.syncConflict, {
                                                        contentType: collectionName
                                                    }));
                                                } else {
                                                    if (offlineLocation) {
                                                        return self._transferFile(true, item, offlineLocation);
                                                    } else {
                                                        return filesCollection.isSync(true).updateSingle(item);
                                                    }
                                                }
                                            })
                                            .then(resolve)
                                            .catch(reject);
                                    });
                                } else {
                                    syncPromises[itemId] = dataCollection
                                        .isSync(true)
                                        .applyOffline(false)
                                        .update(item, itemFilter)
                                        .then(function (res) {
                                            return self._onSyncResponse(res, item, collectionName, DataQuery.operations.update, isCustom);
                                        }, function (err) {
                                            return new rsvp.Promise(function (resolve, reject) {
                                                reject({
                                                    type: offlineItemStates.modified,
                                                    itemId: item.Id,
                                                    contentType: collectionName,
                                                    error: err,
                                                    storage: syncLocation.server
                                                });
                                            });
                                        });
                                }
                            });
                        }

                        if (contentTypeData.deletedItems.length) {
                            self._addDeletedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom) {
                                syncPromises[item.Id] = dataCollection
                                    .isSync(true)
                                    .applyOffline(false)
                                    .destroy(itemFilter)
                                    .then(function (res) {
                                        return self._onSyncResponse(res, item, collectionName, DataQuery.operations.remove, isCustom);
                                    }, function (err) {
                                        return new rsvp.Promise(function (resolve, reject) {
                                            reject({
                                                type: offlineItemStates.deleted,
                                                itemId: item.Id,
                                                contentType: collectionName,
                                                error: err,
                                                storage: syncLocation.server
                                            });
                                        });
                                    });
                            });
                        }
                    });

                    return rsvp.hashSettled(syncPromises);
                });
        },

        _applySync: function () {
            var self = this;

            return this._queryProcessor._getAllCollections()
                .then(function (collections) {
                    if (self.setup.conflicts.strategy === constants.ConflictResolutionStrategy.ClientWins) {
                        return self._applyClientWins(collections);
                    } else {
                        return self._applyStandardSync(collections);
                    }
                });
        },

        /**
         * Get all the offline items that have not been synced online.
         * @method getItemsForSync
         * @name getItemsForSync
         * @memberOf OfflineModule.prototype
         * @param {function} [success] A success callback.
         * @param {function} [error] An error callback.
         */
        /**
         * Get all the offline items that have not been synced online.
         * @method getItemsForSync
         * @name getItemsForSync
         * @memberOf OfflineModule.prototype
         * @returns Promise
         */
        getItemsForSync: function (success, error) {
            var self = this;
            var dirtyItemsForSync = {};
            return buildPromise(function (successCb, errorCb) {
                self._queryProcessor._getAllCollections()
                    .then(function (collections) {
                        _.each(collections, function (collection, collectionName) {
                            var dirtyItems = self._getDirtyItems(collection);
                            dirtyItemsForSync[collectionName] = _.map(dirtyItems, function (item) {
                                var itemForSync = {
                                    item: _.extend({}, item),
                                    action: item[constants.offlineItemsStateMarker]
                                };

                                delete itemForSync.item[constants.offlineItemsStateMarker];
                                return itemForSync;
                            });
                        });

                        successCb(dirtyItemsForSync);
                    }).catch(errorCb);
            }, success, error);
        }
    };

    return OfflineModule;
})();

},{"../EverliveError":39,"../Request":44,"../common":48,"../constants":49,"../query/DataQuery":68,"../query/RequestOptionsBuilder":71,"../utils":82,"./OfflineFilesModule":58,"./OfflineFilesProcessor":59,"./OfflineQueryProcessor":60,"./offlineTransformations":64,"path":5}],62:[function(require,module,exports){
var constants = require('../constants');
var persistersModule = require('./offlinePersisters');
var LocalStoragePersister = persistersModule.LocalStoragePersister;
var FileSystemPersister = persistersModule.FileSystemPersister;
var OfflineStorageModule = require('./OfflineStorageModule');
var EverliveError = require('../EverliveError').EverliveError;
var isNativeScript = require('../everlive.platform').isNativeScript;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var CryptographicProvider = require('../encryption/CryptographicProvider');

var defaultOfflineStorageOptions = {
    autoSync: true,
    enabled: true,
    conflicts: {
        strategy: constants.ConflictResolutionStrategy.ClientWins,
        implementation: null
    },
    offline: false,
    storage: {
        name: '',
        provider: isNativeScript ? constants.StorageProvider.FileSystem : constants.StorageProvider.LocalStorage,
        implementation: null,
        storagePath: constants.DefaultStoragePath
    },
    typeSettings: {},
    encryption: {
        provider: constants.EncryptionProvider.Default,
        implementation: null,
        key: ''
    },
    files: {
        storagePath: constants.DefaultFilesStoragePath,
        metaPath: constants.DefaultFilesMetadataPath
    }
};

module.exports = (function () {

    var conflictResolutionStrategies = {};

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(local);
        });
    };

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(server);
        });
    };

    var initStoragePersister = function initStoragePersister(options) {
        var persister;
        var storageProvider = options.storage.provider;
        var storageProviderImplementation = options.storage.implementation;
        var storageKey = options.storage.name || 'everliveOfflineStorage_' + this.setup.apiKey;
        if (_.isObject(storageProviderImplementation) && storageProvider === constants.StorageProvider.Custom) {
            persister = storageProviderImplementation;
        } else {
            switch (storageProvider) {
                case constants.StorageProvider.LocalStorage:
                    persister = new LocalStoragePersister(storageKey, options);
                    break;
                case constants.StorageProvider.FileSystem:
                    persister = new FileSystemPersister(storageKey, options);
                    break;
                case constants.StorageProvider.Custom:
                    throw new EverliveError('Custom storage provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported storage type ' + storageProvider);
            }
        }

        options.storage.implementation = persister;
        return persister;
    };

    var initEncryptionProvider = function initEncryptionProvider(options) {
        var encryptor;
        var encryptionProvider = options.encryption.provider;
        var encryptionImplementation = options.encryption.implementation;
        if (_.isObject(encryptionImplementation) && encryptionProvider === constants.EncryptionProvider.Custom) {
            encryptor = encryptionImplementation;
        } else {
            switch (encryptionProvider) {
                case constants.EncryptionProvider.Default:
                    encryptor = new CryptographicProvider(options);
                    break;
                case constants.EncryptionProvider.Custom:
                    throw new EverliveError('Custom encryption provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported encryption provider ' + encryptionProvider);
            }
        }

        options.encryption.implementation = encryptor;
        return encryptor;
    };

    var buildOfflineStorageModule = function buildOfflineStorageModule(storageOptions) {
        var options;
        if (storageOptions === true) { // explicit check for shorthand initialization
            options = _.defaults({}, defaultOfflineStorageOptions);
        } else if (_.isObject(storageOptions)) {
            options = _.defaults(storageOptions, defaultOfflineStorageOptions);
            options.storage = _.defaults(storageOptions.storage, defaultOfflineStorageOptions.storage);
            options.encryption = _.defaults(storageOptions.encryption, defaultOfflineStorageOptions.encryption);
            options.conflicts = _.defaults(storageOptions.conflicts, defaultOfflineStorageOptions.conflicts);
        } else {
            options = _.defaults({}, defaultOfflineStorageOptions);
            options.enabled = false;
        }

        if (options.enabled) {
            var persister = initStoragePersister.call(this, options, storageOptions);
            var encryptionProvider = initEncryptionProvider.call(this, options);
        }

        return new OfflineStorageModule(this, options, persister, encryptionProvider);
    };

    var initOfflineStorage = function (options) {
        this.offlineStorage = buildOfflineStorageModule.call(this, options.offlineStorage);
    };

    return {
        initOfflineStorage: initOfflineStorage
    }
}());
},{"../EverliveError":39,"../common":48,"../constants":49,"../encryption/CryptographicProvider":50,"../everlive.platform":51,"./OfflineStorageModule":61,"./offlinePersisters":63}],63:[function(require,module,exports){
var BasePersister = require('./persisters/BasePersister');
var LocalStoragePersister = require('./persisters/LocalStoragePersister');
var FileSystemPersister = require('./persisters/FileSystemPersister');

module.exports = {
    BasePersister: BasePersister,
    LocalStoragePersister: LocalStoragePersister,
    FileSystemPersister: FileSystemPersister
};
},{"./persisters/BasePersister":65,"./persisters/FileSystemPersister":66,"./persisters/LocalStoragePersister":67}],64:[function(require,module,exports){
'use strict';

var constants = require('../constants');
var _ = require('../common')._;
var offlineItemStateMarker = constants.offlineItemsStateMarker;

var traverseAndApply = function (value, operation, additionalOptions) {
    if (_.isArray(value)) {
        return _.map(value, function (item) {
            return operation(item, additionalOptions);
        });
    } else {
        return operation(value, additionalOptions);
    }
};

var idTransformation = function (value) {
    if (typeof value === 'object' && value._id && !value.Id) {
        value.Id = value._id;
        delete value._id;
    }

    return value;
};

var removeIdTransform = function (value, opts) {
    var verifyStateCreated = opts.verifyStateCreated;
    var shouldModifyObject = verifyStateCreated ? value[constants.offlineItemsStateMarker] === constants.offlineItemStates.created : true;
    if (typeof value === 'object' && (value._id || value.Id) && shouldModifyObject) {
        delete value._id;
        delete value.Id;
    }

    return value;
};

var removeMarkerTransform = function (value) {
    delete value[offlineItemStateMarker];
    return value;
};

var offlineTransformations = {
    removeIdTransform: function (value, verifyStateCreated) {
        return traverseAndApply(value, removeIdTransform, {verifyStateCreated: verifyStateCreated});
    },
    idTransform: function (value) {
        return traverseAndApply(value, idTransformation);
    },
    singleFieldTransform: function (singleFieldExpression, value) {
        if (typeof value === 'undefined' || value === null) {
            return null;
        } else {
            return value[singleFieldExpression];
        }
    },
    traverseAndTransformFilterId: function (filterObj) {
        if (filterObj && filterObj.Id) {
            filterObj._id = filterObj.Id;
            delete filterObj.Id;
        }

        for (var prop in filterObj) {
            if (filterObj.hasOwnProperty(prop)) {
                var objectMember = filterObj[prop];
                if (typeof objectMember === 'object') {
                    offlineTransformations.traverseAndTransformFilterId(objectMember);
                }
            }
        }
    },
    removeMarkersTransform: function (value) {
        return traverseAndApply(value, removeMarkerTransform);
    },
    removeFieldsTransform: function (value, fields) {
        _.each(fields, function (field) {
            delete value[field];
        });

        return value;
    }
};

module.exports = offlineTransformations;
},{"../common":48,"../constants":49}],65:[function(require,module,exports){
'use strict';

var EverliveError = require('../../EverliveError').EverliveError;
var utils = require('../../utils');
var common = require('../../common');
var _ = common._;
var rsvp = common.rsvp;

var BasePersister = (function () {

    /**
     * @class BasePersister
     * @classdesc An abstraction layer for all persisters. Every persister can write/read
     * data to/from a specific place. The data is saved as key-value pairs where the keys are
     * content types.
     */
    function BasePersister(key, options) {
        this.key = key;
        this.options = options;
        this.contentTypesStoreKey = this.key + '@ContentTypes';
    }

    BasePersister.prototype = {
        /**
         * Gets all the saved data.
         * @method getAllData
         * @memberof BasePersister
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @returns {Object} The keys are the content types and the values are the corresponding data items.
         */
        getAllData: function (success, error) {
            var self = this;
            var promises = {};
            this._getContentTypes(function (contentTypes) {
                _.each(contentTypes, function (contentType) {
                    promises[contentType] = new rsvp.Promise(function (resolve, reject) {
                        self.getData(contentType, resolve, reject);
                    });
                });

                rsvp.hash(promises)
                    .then(success)
                    .catch(error);
            }, error);
        },

        /**
         * Returns the saved data for a specific content type.
         * @method getData
         * @param {string} contentType The content type for which to retrieve the data.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         * @returns {string} The retrieved data.
         */
        getData: function (contentType, success, error) {
            throw new EverliveError('The method getData is not implemented');
        },

        /**
         * Saves data for a specific content type.
         * @method saveData
         * @param {string} contentType The content for which to save the data.
         * @param {string} data The data corresponding to the specified content type.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         */
        saveData: function (contentType, data, success, error) {
            throw new EverliveError('The method saveData is not implemented');
        },

        /**
         * Clears the persisted data for a specific content type.
         * @method purge
         * @param {string} contentType The content type for which to clear the data.
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         * @memberof BasePersister
         */
        purge: function (contentType, success, error) {
            throw new EverliveError('The method clear is not implemented');
        },

        /**
         * Clears all persisted data in the offline store.
         * @method purgeAll
         * @memberof BasePersister
         * @param {Function} success A success callback.
         * @param {Function} error An error callback.
         */
        purgeAll: function (success, error) {
            throw new EverliveError('The method clearAll is not implemented');
        },

        _getKey: function (contentType) {
            return this.key + '_' + contentType;
        },

        _getContentTypes: function (success, error) {
            throw new EverliveError('The method _getContentTypes is not implemented');
        }
    };

    return BasePersister;
}());

module.exports = BasePersister;
},{"../../EverliveError":39,"../../common":48,"../../utils":82}],66:[function(require,module,exports){
'use strict';

var FileStore = require('../../storages/FileStore');
var BasePersister = require('./BasePersister');
var EverliveError = require('../../EverliveError').EverliveError;
var common = require('../../common');
var _ = common._;
var platform = require('../../everlive.platform');
var rsvp = common.rsvp;
var util = require('util');
var path = require('path');
var utils = require('../../utils');

var FileSystemPersister = (function () {
    /**
     * @class FileSystemPersister
     * @protected
     * @extends BasePersister
     */
    function FileSystemPersister(key, options) {
        BasePersister.apply(this, arguments);
        this.fileStore = new FileStore(options.storage.storagePath, options);
    }

    util.inherits(FileSystemPersister, BasePersister);

    FileSystemPersister.prototype.getAllData = function (success, error) {
        var errorHandler = this._fileSystemErrorHandler(error);
        FileSystemPersister.super_.prototype.getAllData.call(this, success, errorHandler);
    };

    FileSystemPersister.prototype.getData = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self._readFileContent(fileEntry, success, errorHandler);
        }, error);
    };

    FileSystemPersister.prototype.saveData = function (contentType, data, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self._writeFileContent(fileEntry, data, function () {
                self._saveContentTypes(contentType, success, errorHandler);
            }, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purge = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this.getFileHandle(contentType, function (fileEntry) {
            self.fileStore.removeFile(fileEntry).then(function () {
                success();
            }).catch(error);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purgeAll = function (success, error) {
        var errorHandler = this._fileSystemErrorHandler(error);
        this.fileStore.removeFilesDirectory()
            .then(function () {
                success();
            })
            .catch(errorHandler);
    };

    FileSystemPersister.prototype._getContentTypes = function (success, error) {
        this.getData(this.contentTypesStoreKey, function (savedContentTypesRaw) {
            var savedContentTypes = JSON.parse(savedContentTypesRaw || '[]');
            success(savedContentTypes);
        }, error);
    };

    FileSystemPersister.prototype._saveContentTypes = function (contentType, success, error) {
        var self = this;
        this._getContentTypes(function (savedContentTypes) {
            if (!_.contains(savedContentTypes, contentType)) {
                savedContentTypes.push(contentType);
            }

            self.getFileHandle(self.contentTypesStoreKey, function (contentTypesFile) {
                self._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
            }, error);
        });
    };

    FileSystemPersister.prototype.getFileHandle = function (contentType, success, error) {
        var self = this;
        var path = self._getFilePath(contentType);
        this.fileStore.getFilesDirectory()
            .then(function () {
                return self.fileStore.getFile(path);
            })
            .then(function (fileHandle) {
                success(fileHandle);
            })
            .catch(error);
    };

    FileSystemPersister.prototype._readFileContent = function (fileEntry, success, error) {
        this.fileStore.readFileAsText(fileEntry).then(function (content) {
            success(content);
        }).catch(error);
    };

    FileSystemPersister.prototype._writeFileContent = function (fileEntry, content, success, error) {
        this.fileStore.writeTextToFile(fileEntry, content)
            .then(success)
            .catch(error);
    };

    FileSystemPersister.prototype._getFilePath = function (contentType) {
        return this._getKey(contentType);
        //return utils.joinPath(this.fileStore.filesDirectoryPath, this._getKey(contentType));
    };

    FileSystemPersister.prototype._fileSystemErrorHandler = function (callback) {
        return this.fileStore.getErrorHandler(callback);
    };

    return FileSystemPersister;
}());

module.exports = FileSystemPersister;
},{"../../EverliveError":39,"../../common":48,"../../everlive.platform":51,"../../storages/FileStore":75,"../../utils":82,"./BasePersister":65,"path":5,"util":8}],67:[function(require,module,exports){
'use strict';

var common = require('../../common');
var _ = common._;
var rsvp = common.rsvp;
var util = require('util');
var LocalStore = require('../../storages/LocalStore');
var BasePersister = require('./BasePersister');

var LocalStoragePersister = (function () {

    /**
     * @class LocalStoragePersister
     * @extends BasePersister
     */
    function LocalStoragePersister(key, options) {
        BasePersister.apply(this, arguments);
        this._localStore = new LocalStore(options);
    }

    util.inherits(LocalStoragePersister, BasePersister);

    LocalStoragePersister.prototype.getData = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            var storedItem = this._getItem(key);
            success(storedItem);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.saveData = function (contentType, data, success, error) {
        try {
            var contentTypeKey = this._getKey(contentType);
            this._setItem(contentTypeKey, data);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purge = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            this._removeItem(key);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purgeAll = function (success, error) {
        try {
            var self = this;

            this._getContentTypes(function (contentTypes) {
                _.each(contentTypes, function (contentType) {
                    var contentTypeKey = self._getKey(contentType);
                    self._removeItem(contentTypeKey);
                });

                self._removeItem(self.contentTypesStoreKey);
                success();
            }, error);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._getItem = function (key) {
        return this._localStore.getItem(key);
    };

    LocalStoragePersister.prototype._setItem = function (key, value) {
        return this._localStore.setItem(key, value);
    };

    LocalStoragePersister.prototype._removeItem = function (key) {
        return this._localStore.removeItem(key);
    };

    LocalStoragePersister.prototype._getKey = function (contentType) {
        this._addTypeToCollectionsCache(contentType);
        return LocalStoragePersister.super_.prototype._getKey.apply(this, arguments);
    };

    LocalStoragePersister.prototype._getContentTypes = function (success, error) {
        try {
            var localStorageString = this._getItem(this.contentTypesStoreKey);

            var data = [];
            if (localStorageString) {
                data = JSON.parse(localStorageString);
            }

            success(data);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._setContentTypesCollection = function (collection) {
        this._setItem(this.contentTypesStoreKey, JSON.stringify(collection));
    };

    LocalStoragePersister.prototype._addTypeToCollectionsCache = function (typeName) {
        var self = this;
        this._getContentTypes(function (contentTypes) {
            if (!_.contains(contentTypes, typeName)) {
                contentTypes.push(typeName);
                self._setContentTypesCollection(contentTypes);
            }
        });
    };

    return LocalStoragePersister;
}());

module.exports = LocalStoragePersister;
},{"../../common":48,"../../storages/LocalStore":76,"./BasePersister":65,"util":8}],68:[function(require,module,exports){
var _ = require('../common')._;

module.exports = (function () {
    // TODO: [offline] Update the structure - filter field can be refactored for example and a skip/limit/sort property can be added
    var DataQuery = function (config) {
        this.collectionName = config.collectionName;
        this.headers = config.headers || {};
        this.filter = config.filter;
        this.onSuccess = config.onSuccess;
        this.onError = config.onError;
        this.operation = config.operation;
        this.parse = config.parse;
        this.additionalOptions = config.additionalOptions;
        this.data = config.data;
        this.useOffline = config.useOffline;
        this.applyOffline = config.applyOffline;
        this.noRetry = config.noRetry; //retry will be done by default, when a request fails because of expired token, once the authentication.completeAuthentication in sdk is called.
        this.skipAuth = config.skipAuth; //if set to true, the sdk will not require authorization if the data query fails because of expired token. Used internally for various login methods.
        this._normalizedHeaders = null;
        this.isSync = config.isSync;
    };

    DataQuery.prototype = {
        getHeader: function (header) {
            var self = this;
            var headerKeys = Object.keys(this.headers);

            if (!this._normalizedHeaders) {
                this._normalizedHeaders = {};
                _.each(headerKeys, function (headerKey) {
                    var normalizedKey = headerKey.toLowerCase();
                    var headerValue = self.headers[headerKey];
                    self._normalizedHeaders[normalizedKey] = headerValue;
                });
            }

            var normalizedHeader = header.toLowerCase();
            return this._normalizedHeaders[normalizedHeader];
        },

        getHeaderAsJSON: function (header) {
            var headerValue = this._normalizedHeaders[header.toLowerCase()];
            if (_.isObject(headerValue)) {
                return headerValue;
            }
            if (_.isString(headerValue)) {
                try {
                    return JSON.parse(headerValue);
                } catch (e) {
                    return headerValue;
                }
            } else {
                return headerValue;
            }
        }
    };

    DataQuery.operations = {
        read: 'read',
        create: 'create',
        update: 'update',
        remove: 'destroy',
        removeSingle: 'destroySingle',
        readById: 'readById',
        count: 'count',
        rawUpdate: 'rawUpdate',
        setAcl: 'setAcl',
        setOwner: 'setOwner',
        userLogin: 'login',
        userLogout: 'logout',
        userChangePassword: 'changePassword',
        userLoginWithProvider: 'loginWith',
        userLinkWithProvider: 'linkWith',
        userUnlinkFromProvider: 'unlinkFrom',
        userResetPassword: 'resetPassword',
        filesUpdateContent: 'updateContent',
        filesGetDownloadUrlById: 'downloadUrlById'
    };

    return DataQuery;
}());
},{"../common":48}],69:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;
var WhereQuery = require('./WhereQuery');
var QueryBuilder = require('./QueryBuilder');

module.exports = (function () {
    /**
     * @class Query
     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
     * @param {object} [filter] A [filter expression]({% slug rest-api-querying-filtering %}) definition.
     * @param {object} [fields] A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
     * @param {object} [sort] A [sort expression]({% slug rest-api-querying-sorting %}) definition.
     * @param {number} [skip] Number of items to skip. Used for paging.
     * @param {number} [take] Number of items to take. Used for paging.
     * @param {object} [expand] An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
     */
    function Query(filter, fields, sort, skip, take, expand) {
        this.filter = filter;
        this.fields = fields;
        this.sort = sort;
        this.toskip = skip;
        this.totake = take;
        this.expandExpression = expand;
        this.expr = new Expression(OperatorType.query);
    }

    Query.prototype = {
        /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @param {object} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Query}
         */
        /** Defines a filter definition for the current query.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @returns {WhereQuery}
         */
        where: function (filter) {
            if (filter) {
                return this._simple(OperatorType.filter, [filter]);
            }
            else {
                return new WhereQuery(this);
            }
        },
        /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
         * @memberOf Query.prototype
         * @method select
         * @param {object} fieldsExpression A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
         * @returns {Query}
         */
        select: function () {
            return this._simple(OperatorType.select, arguments);
        },
        // TODO
        //exclude: function () {
        //    return this._simple(OperatorType.exclude, arguments);
        //},
        /** Sorts the items in the current query in ascending order by the specified field.
         * @memberOf Query.prototype
         * @method order
         * @param {string} field The field name to order by in ascending order.
         * @returns {Query}
         */
        order: function (field) {
            return this._simple(OperatorType.order, [field]);
        },
        /** Sorts the items in the current query in descending order by the specified field.
         * @memberOf Query.prototype
         * @method orderDesc
         * @param {string} field The field name to order by in descending order.
         * @returns {Query}
         */
        orderDesc: function (field) {
            return this._simple(OperatorType.order_desc, [field]);
        },
        /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
         * @memberOf Query.prototype
         * @method skip
         * @see [query.take]{@link query.take}
         * @param {number} value The number of items to skip.
         * @returns {Query}
         */
        skip: function (value) {
            return this._simple(OperatorType.skip, [value]);
        },
        /** Takes a specified number of items from the query result. Used for paging.
         * @memberOf Query.prototype
         * @method take
         * @see [query.skip]{@link query.skip}
         * @param {number} value The number of items to take.
         * @returns {Query}
         */
        take: function (value) {
            return this._simple(OperatorType.take, [value]);
        },
        /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Query.prototype
         * @method expand
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Query}
         */
        expand: function (expandExpression) {
            return this._simple(OperatorType.expand, [expandExpression]);
        },
        /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
         * @memberOf Query.prototype
         * @method build
         * @returns {{$where,$select,$sort,$skip,$take,$expand}}
         */
        build: function () {
            return new QueryBuilder(this).build();
        },
        _simple: function (op, oprs) {
            var args = [].slice.call(oprs);
            this.expr.addOperand(new Expression(op, args));
            return this;
        }
    };

    return Query;
}());
},{"../Expression":41,"../constants":49,"./QueryBuilder":70,"./WhereQuery":72}],70:[function(require,module,exports){
var constants = require('../constants');
var OperatorType = constants.OperatorType;
var _ = require('../common')._;
var GeoPoint = require('../GeoPoint');
var EverliveError = require('../EverliveError').EverliveError;
var Expression = require('../Expression');
var maxDistanceConsts = constants.maxDistanceConsts;
var radiusConsts = constants.radiusConsts;

module.exports = (function () {
    function QueryBuilder(query) {
        this.query = query;
        this.expr = query.expr;
    }

    QueryBuilder.prototype = {
        // TODO merge the two objects before returning them
        build: function () {
            var query = this.query;
            if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expandExpression) {
                return {
                    $where: query.filter || null,
                    $select: query.fields || null,
                    $sort: query.sort || null,
                    $skip: query.toskip || null,
                    $take: query.totake || null,
                    $expand: query.expandExpression || null
                };
            }
            return {
                $where: this._buildWhere(),
                $select: this._buildSelect(),
                $sort: this._buildSort(),
                $skip: this._getSkip(),
                $take: this._getTake(),
                $expand: this._getExpand()
            };
        },
        _getSkip: function () {
            var skipExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.skip;
            });
            return skipExpression ? skipExpression.operands[0] : null;
        },
        _getTake: function () {
            var takeExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.take;
            });
            return takeExpression ? takeExpression.operands[0] : null;
        },
        _getExpand: function () {
            var expandExpression = _.chain(this.expr.operands)
                .filter(function (value) {
                    return value.operator === OperatorType.expand;
                })
                .reduce(function (result, expression) { //expression contains operands and has operator type expand
                    return _.extend(result, expression.operands[0]);
                }, {})
                .value();
            return _.isEmpty(expandExpression) ? null : expandExpression;
        },
        _buildSelect: function () {
            var selectExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.select;
            });
            var result = {};
            if (selectExpression) {
                _.reduce(selectExpression.operands, function (memo, value) {
                    memo[value] = 1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildSort: function () {
            var sortExpressions = _.filter(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.order || value.operator === OperatorType.order_desc;
            });
            var result = {};
            if (sortExpressions.length > 0) {
                _.reduce(sortExpressions, function (memo, value) {
                    memo[value.operands[0]] = value.operator === OperatorType.order ? 1 : -1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildWhere: function () {
            var whereExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.where;
            });
            if (whereExpression) {
                return this._build(new Expression(OperatorType.and, whereExpression.operands));
            }
            else {
                var filterExpression = _.find(this.expr.operands, function (value, index, list) {
                    return value.operator === OperatorType.filter;
                });
                if (filterExpression) {
                    return filterExpression.operands[0];
                }
                return null;
            }
        },
        _build: function (expr) {
            if (this._isSimple(expr)) {
                return this._simple(expr);
            }
            else if (this._isRegex(expr)) {
                return this._regex(expr);
            }
            else if (this._isGeo(expr)) {
                return this._geo(expr);
            }
            else if (this._isAnd(expr)) {
                return this._and(expr);
            }
            else if (this._isOr(expr)) {
                return this._or(expr);
            }
            else if (this._isNot(expr)) {
                return this._not(expr);
            }
        },
        _isSimple: function (expr) {
            return expr.operator >= OperatorType.equal && expr.operator <= OperatorType.size;
        },
        _simple: function (expr) {
            var term = {}, fieldTerm = {};
            var operands = expr.operands;
            var operator = this._translateoperator(expr.operator);
            if (operator) {
                term[operator] = operands[1];
            }
            else {
                term = operands[1];
            }
            fieldTerm[operands[0]] = term;
            return fieldTerm;
        },
        _isRegex: function (expr) {
            return expr.operator >= OperatorType.regex && expr.operator <= OperatorType.endsWith;
        },
        _regex: function (expr) {
            var fieldTerm = {};
            var regex = this._getRegex(expr);
            var regexValue = this._getRegexValue(regex);
            var operands = expr.operands;
            fieldTerm[operands[0]] = regexValue;
            return fieldTerm;
        },
        _getRegex: function (expr) {
            var pattern = expr.operands[1];
            var flags = expr.operands[2] ? expr.operands[2] : '';
            switch (expr.operator) {
                case OperatorType.regex:
                    return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
                case OperatorType.startsWith:
                    return new RegExp("^" + pattern, flags);
                case OperatorType.endsWith:
                    return new RegExp(pattern + "$", flags);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getRegexValue: function (regex) {
            var options = '';
            if (regex.global) {
                options += 'g';
            }
            if (regex.multiline) {
                options += 'm';
            }
            if (regex.ignoreCase) {
                options += 'i';
            }
            return {$regex: regex.source, $options: options};
        },
        _isGeo: function (expr) {
            return expr.operator >= OperatorType.nearShpere && expr.operator <= OperatorType.withinShpere;
        },
        _geo: function (expr) {
            var fieldTerm = {};
            var operands = expr.operands;
            fieldTerm[operands[0]] = this._getGeoTerm(expr);
            return fieldTerm;
        },
        _getGeoTerm: function (expr) {
            switch (expr.operator) {
                case OperatorType.nearShpere:
                    return this._getNearSphereTerm(expr);
                case OperatorType.withinBox:
                    return this._getWithinBox(expr);
                case OperatorType.withinPolygon:
                    return this._getWithinPolygon(expr);
                case OperatorType.withinShpere:
                    return this._getWithinCenterSphere(expr);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getNearSphereTerm: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var maxDistance = operands[2];
            var metrics = operands[3];
            var maxDistanceConst;
            var term = {
                '$nearSphere': center
            };
            if (typeof maxDistance !== 'undefined') {
                maxDistanceConst = maxDistanceConsts[metrics] || maxDistanceConsts.radians;
                term[maxDistanceConst] = maxDistance;
            }
            return term;
        },
        _getWithinBox: function (expr) {
            var operands = expr.operands;
            var bottomLeft = this._getGeoPoint(operands[1]);
            var upperRight = this._getGeoPoint(operands[2]);
            return {
                '$within': {
                    '$box': [bottomLeft, upperRight]
                }
            };
        },
        _getWithinPolygon: function (expr) {
            var operands = expr.operands;
            var points = this._getGeoPoints(operands[1]);
            return {
                '$within': {
                    '$polygon': points
                }
            };
        },
        _getWithinCenterSphere: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var radius = operands[2];
            var metrics = operands[3];
            var radiusConst = radiusConsts[metrics] || radiusConsts.radians;
            var sphereInfo = {
                'center': center
            };
            sphereInfo[radiusConst] = radius;
            return {
                '$within': {
                    '$centerSphere': sphereInfo
                }
            };
        },
        _getGeoPoint: function (point) {
            if (_.isArray(point)) {
                return new GeoPoint(point[0], point[1]);
            }
            return point;
        },
        _getGeoPoints: function (points) {
            var self = this;
            return _.map(points, function (point) {
                return self._getGeoPoint(point);
            });
        },
        _isAnd: function (expr) {
            return expr.operator === OperatorType.and;
        },
        _and: function (expr) {
            var i, l, term, result = {};
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result = this._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            var i, l, key, value, newValue;
            var keys = _.keys(newObj);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                value = andObj[key];
                if (typeof value === 'undefined') {
                    andObj[key] = newObj[key];
                }
                else {
                    newValue = newObj[key];
                    if (typeof value === 'object' && typeof newValue === 'object') {
                        value = _.extend(value, newValue);
                    } else {
                        value = newValue;
                    }
                    andObj[key] = value;
                }
            }
            return andObj;
        },
        _isOr: function (expr) {
            return expr.operator === OperatorType.or;
        },
        _or: function (expr) {
            var i, l, term, result = [];
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _isNot: function (expr) {
            return expr.operator === OperatorType.not;
        },
        _not: function (expr) {
            return {$not: this._build(expr.operands[0])};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case OperatorType.equal:
                    return null;
                case OperatorType.not_equal:
                    return '$ne';
                case OperatorType.gt:
                    return '$gt';
                case OperatorType.lt:
                    return '$lt';
                case OperatorType.gte:
                    return '$gte';
                case OperatorType.lte:
                    return '$lte';
                case OperatorType.isin:
                    return '$in';
                case OperatorType.notin:
                    return '$nin';
                case OperatorType.all:
                    return '$all';
                case OperatorType.size:
                    return '$size';
            }
            throw new EverliveError('Unknown operator type.');
        }
    };

    return QueryBuilder;
}());
},{"../EverliveError":39,"../Expression":41,"../GeoPoint":42,"../common":48,"../constants":49}],71:[function(require,module,exports){
var DataQuery = require('./DataQuery');
var Request = require('../Request');
var _ = require('../common')._;

module.exports = (function () {
    var RequestOptionsBuilder = {};

    RequestOptionsBuilder._buildEndpointUrl = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
            endpoint += '/' + dataQuery.additionalOptions.id;
        }

        return endpoint;
    };

    RequestOptionsBuilder._buildBaseObject = function (dataQuery) {
        var defaultObject = {
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery),
            filter: dataQuery.filter,
            success: dataQuery.onSuccess,
            error: dataQuery.onError,
            data: dataQuery.data,
            headers: dataQuery.headers
        };

        if (dataQuery.parse) {
            defaultObject.parse = dataQuery.parse;
        }

        return defaultObject;
    };

    RequestOptionsBuilder._build = function (dataQuery, additionalOptions) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);
    };

    RequestOptionsBuilder[DataQuery.operations.read] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.readById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.count] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_count'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.create] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.rawUpdate] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        var ofilter = null; // request options filter

        if (typeof filter === 'string') {
            endpoint += '/' + filter; // send the filter through query string
        } else if (typeof filter === 'object') {
            ofilter = filter; // send the filter as filter headers
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint,
            filter: ofilter
        });
    };

    RequestOptionsBuilder[DataQuery.operations.update] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.remove] = function (dataQuery) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), {
            method: 'DELETE'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.removeSingle] = RequestOptionsBuilder[DataQuery.operations.remove];

    RequestOptionsBuilder[DataQuery.operations.setAcl] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;

        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_acl';
        var method, data;
        if (dataQuery.additionalOptions.acl === null) {
            method = 'DELETE';
        } else {
            method = 'PUT';
            data = dataQuery.additionalOptions.acl;
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: method,
            endpoint: endpoint,
            data: data
        });
    };

    RequestOptionsBuilder[DataQuery.operations.setOwner] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_owner';

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogin] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: 'oauth/token',
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogout] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: 'oauth/logout'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userChangePassword] = function (dataQuery) {
        var keepTokens = dataQuery.additionalOptions.keepTokens;
        var endpoint = 'Users/changepassword';
        if (keepTokens) {
            endpoint += '?keepTokens=true';
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: endpoint,
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLoginWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            authHeaders: false
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLinkWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userUnlinkFromProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userResetPassword] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/resetpassword'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesUpdateContent] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesGetDownloadUrlById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    return RequestOptionsBuilder;
}());
},{"../Request":44,"../common":48,"./DataQuery":68}],72:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;

module.exports = (function () {
    /**
     * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
     * @class WhereQuery
     * @protected
     * @borrows WhereQuery#eq as WhereQuery#equal
     * @borrows WhereQuery#ne as WhereQuery#notEqual
     * @borrows WhereQuery#gt as WhereQuery#greaterThan
     * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
     * @borrows WhereQuery#lt as WhereQuery#lessThan
     * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
     */
    function WhereQuery(parentQuery, exprOp, singleOperand) {
        this.parent = parentQuery;
        this.single = singleOperand;
        this.expr = new Expression(exprOp || OperatorType.where);
        this.parent.expr.addOperand(this.expr);
    }

    WhereQuery.prototype = {
        /**
         * Adds an `and` clause to the current condition and returns it for further chaining.
         * @method and
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        and: function () {
            return new WhereQuery(this, OperatorType.and);
        },
        /**
         * Adds an `or` clause to the current condition and returns it for further chaining.
         * @method or
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        or: function () {
            return new WhereQuery(this, OperatorType.or);
        },
        /**
         * Adds a `not` clause to the current condition and returns it for further chaining.
         * @method not
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        not: function () {
            return new WhereQuery(this, OperatorType.not, true);
        },
        _simple: function (operator) {
            var args = [].slice.call(arguments, 1);
            this.expr.addOperand(new Expression(operator, args));
            return this._done();
        },
        /**
         * Adds a condition that a field must be equal to a specific value.
         * @method eq
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the fields must be equal).
         * @returns {WhereQuery}
         */
        eq: function (field, value) {
            return this._simple(OperatorType.equal, field, value);
        },
        /**
         * Adds a condition that a field must *not* be equal to a specific value.
         * @method ne
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the field must not be equal).
         * @returns {WhereQuery}
         */
        ne: function (field, value) {
            return this._simple(OperatorType.not_equal, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
         * @method gt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than).
         * @returns {WhereQuery}
         */
        gt: function (field, value) {
            return this._simple(OperatorType.gt, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method gte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than or equal to).
         * @returns {WhereQuery}
         */
        gte: function (field, value) {
            return this._simple(OperatorType.gte, field, value);
        },
        /**
         * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
         * @method lt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than).
         * @returns {WhereQuery}
         */
        lt: function (field, value) {
            return this._simple(OperatorType.lt, field, value);
        },
        /**
         * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method lte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than or equal to).
         * @returns {WhereQuery}
         */
        lte: function (field, value) {
            return this._simple(OperatorType.lte, field, value);
        },
        /**
         * Adds a condition that a field must be in a set of values.
         * @method isin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of the values that the field should be in.
         * @returns {WhereQuery}
         */
        isin: function (field, value) {
            return this._simple(OperatorType.isin, field, value);
        },
        /**
         * Adds a condition that a field must *not* be in a set of values.
         * @method notin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field should not be in.
         * @returns {WhereQuery}
         */
        notin: function (field, value) {
            return this._simple(OperatorType.notin, field, value);
        },
        /**
         * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
         * @method all
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field must include.
         * @returns {WhereQuery}
         */
        all: function (field, value) {
            return this._simple(OperatorType.all, field, value);
        },
        /**
         * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
         * @method size
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {number} value The size that the array must be bigger than.
         * @returns {WhereQuery}
         */
        size: function (field, value) {
            return this._simple(OperatorType.size, field, value);
        },
        /**
         * Adds a condition that a field must satisfy a specified regex.
         * @method regex
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} regularExpression Regular expression in PCRE format.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        regex: function (field, value, flags) {
            return this._simple(OperatorType.regex, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *start* with a specified string.
         * @method startsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should start with.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        startsWith: function (field, value, flags) {
            return this._simple(OperatorType.startsWith, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *end* with a specified string.
         * @method endsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should end with.
         * @param {string} [options] A string of  regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        endsWith: function (field, value, flags) {
            return this._simple(OperatorType.endsWith, field, value, flags);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
         * @method nearSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} point Comparison geopoint value.
         * @param {number} distance Distance value.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        nearSphere: function (field, point, distance, metrics) {
            return this._simple(OperatorType.nearShpere, field, point, distance, metrics);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
         * @method withinBox
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
         * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
         * @example ```js
         var query = new Everlive.Query();
         query.where().withinBox('Location',
         new Everlive.GeoPoint(23.317871, 42.687709),
         new Everlive.GeoPoint(23.331346, 42.707075));
         ```
         * @returns {WhereQuery}
         */
        withinBox: function (field, pointBottomLeft, pointUpperRight) {
            return this._simple(OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
         * @method withinPolygon
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
         * @example ```js
         var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
         var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
         var point3 = new Everlive.GeoPoint(23.331346, 42.702282);

         var query = new Everlive.Query();
         query.where().withinPolygon("location", [point1, point2, point3]);
         * ```
         * @returns {WhereQuery}
         */
        withinPolygon: function (field, points) {
            return this._simple(OperatorType.withinPolygon, field, points);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
         * @method withinCenterSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
         * @param {number} radius Value specifying the radius length.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        withinCenterSphere: function (field, center, radius, metrics) {
            return this._simple(OperatorType.withinShpere, field, center, radius, metrics);
        },
        /**
         * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
         * @method done
         * @memberOf WhereQuery.prototype
         * @returns {Query}
         */
        done: function () {
            if (this.parent instanceof WhereQuery) {
                return this.parent._done();
            } else {
                return this.parent;
            }
        },
        _done: function () {
            if (this.single) {
                return this.parent;
            } else {
                return this;
            }
        }
    };

    WhereQuery.prototype.equal = WhereQuery.prototype.eq;
    WhereQuery.prototype.notEqual = WhereQuery.prototype.ne;
    WhereQuery.prototype.greaterThan = WhereQuery.prototype.gt;
    WhereQuery.prototype.greaterThanEqual = WhereQuery.prototype.gte;
    WhereQuery.prototype.lessThan = WhereQuery.prototype.lt;
    WhereQuery.prototype.lessThanEqual = WhereQuery.prototype.lte;

    return WhereQuery;
}());
},{"../Expression":41,"../constants":49}],73:[function(require,module,exports){
var http = require('http');
module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var httpRequestOptions = {
            url: options.url,
            method: options.method,
            headers: options.headers || {}
        };

        if (options.data) {
            httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
        }

        httpRequestOptions.headers['Accept'] = 'application/json';
        httpRequestOptions.headers['Content-Type'] = 'application/json';

        var noop = function () {
        };
        var success = options.success || noop;
        var error = options.error || noop;

        var requestSuccessCallback = function (response) {
            var contentString = response.content.toString();
            if (response.statusCode < 400) {
                // Success callback calls a custom parse function
                success(contentString);
            } else {
                // Error callback relies on a JSON Object with ResponseText inside
                error({
                    responseText: contentString
                });
            }
        };

        var requestErrorCallback = function (err) {
            // error: function(jqXHR, textStatus, errorThrown)
            // when timeouting for example (i.e. no internet connectivity), we get an err with content { message: "timeout...", stack: null }
            error({
                responseText: err
            });
        };

        http.request(httpRequestOptions).then(requestSuccessCallback, requestErrorCallback);
    }

    return reqwest;
}());
},{"http":"http"}],74:[function(require,module,exports){
(function (Buffer){
var url = require('url');
var http = require('http');
var https = require('https');
var rsvp = require('rsvp');
var zlib = require('zlib');
var _ = require('underscore');

module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var urlParts = url.parse(options.url);
        var request;
        if (urlParts.protocol === 'https:') {
            request = https.request;
        }
        else {
            request = http.request;
        }
        var headers = options.headers || {};
        options.success = options.success || _.noop;
        options.error = options.error || _.noop;

        headers['Content-Type'] = options.contentType;
        var req = request({
            method: options.method,
            hostname: urlParts.hostname,
            port: urlParts.port,
            path: urlParts.path,
            headers: headers
        }, function (res) {
            var json = '';
            var contentEncoding = res.headers['content-encoding'];
            var responseProxy;
            switch (contentEncoding){
                case 'gzip':
                    responseProxy = zlib.createGunzip();
                    res.pipe(responseProxy);
                    break;
                default:
                    responseProxy = res;
                    responseProxy.setEncoding('utf8');
                    break;
            }

            responseProxy.on('data', function (data) {
                json += data.toString();
            });

            responseProxy.on('end', function () {
                // 1xx Informational, 2xx Success, 3xx Redirection, 4xx Client Error, 5xx Server Error
                if (res.statusCode >= 200 && res.statusCode < 400) {
                    options.success(json, res);
                } else {
                    if (json) {
                        options.error({ responseText: json });
                    }
                    else { // empty response
                        var error = new Error('Response error.');
                        error.statusCode = res.statusCode;
                        options.error({ responseText: error });
                    }
                }
            });
        });

        req.on('error', function (e) {
            options.error({ responseText: e }); // TODO
        });

        if (options.data) {
            var contentEncoding = headers['content-encoding'];
            switch (contentEncoding){
                case 'gzip':
                    var buf = new Buffer(options.data, 'utf-8');
                    zlib.gzip(buf, function (err, result) {
                        req.end(result);
                    });
                    break;
                default:
                    req.end(options.data);
                    break;
            }
        }
        else {
            req.end();
        }
    }

    return reqwest;
}());
}).call(this,require("buffer").Buffer)

},{"buffer":"buffer","http":"http","https":"https","rsvp":2,"underscore":2,"url":"url","zlib":"zlib"}],75:[function(require,module,exports){
var platform = require('../everlive.platform');
var WebFileStore = require('./WebFileStore');
var NativeScriptFileStore = require('./NativeScriptFileStore');
var _ = require('../common')._;

'use strict';

if (platform.isNativeScript) {
    module.exports = NativeScriptFileStore;
} else if (platform.isCordova || platform.isDesktop) {
    module.exports = WebFileStore;
} else {
    module.exports = _.noop;
}
},{"../common":48,"../everlive.platform":51,"./NativeScriptFileStore":77,"./WebFileStore":78}],76:[function(require,module,exports){
var platform = require('./../everlive.platform.js');
var isNativeScript = platform.isNativeScript;
var isNodejs = platform.isNodejs;
var constants = require('./../constants');

module.exports = (function () {
    'use strict';

    function initLocalStorage(options) {
        if (isNativeScript) {
            var localSettings;

            //workound for older nativescript versions
            try {
                localSettings = require('application-settings');
            } catch (e) {
                localSettings = require('local-settings');
            }

            return {
                getItem: function (key) {
                    return localSettings.getString(key);
                },

                removeItem: function (key) {
                    return localSettings.remove(key);
                },

                setItem: function (key, value) {
                    return localSettings.setString(key, value);
                }
            };
        } else {
            var localStorage;
            if (isNodejs) {
                var LocalStorage = require('node-localstorage').LocalStorage;
                localStorage = new LocalStorage(options.storage.storagePath);
            } else {
                localStorage = window.localStorage;
            }

            return {
                getItem: function (key) {
                    return localStorage.getItem(key);
                },

                removeItem: function (key) {
                    return localStorage.removeItem(key);
                },

                setItem: function (key, value) {
                    return localStorage.setItem(key, value);
                }
            };
        }
    }

    function LocalStore(options) {
        this.options = options;
        this._localStorage = initLocalStorage(this.options);
    }

    LocalStore.prototype = {
        getItem: function (key) {
            return this._localStorage.getItem(key);
        },

        removeItem: function (key) {
            return this._localStorage.removeItem(key);
        },

        setItem: function (key, value) {
            return this._localStorage.setItem(key, value);
        }
    };

    return LocalStore;
}());
},{"./../constants":49,"./../everlive.platform.js":51,"application-settings":"application-settings","local-settings":"local-settings","node-localstorage":"node-localstorage"}],77:[function(require,module,exports){
'use strict';

var common = require('../common');
var rsvp = common.rsvp;

function NativeScriptFileStore(storagePath, options) {
    this.options = options;
    this.fs = require('file-system');
    this.dataDirectoryPath = this.fs.knownFolders.documents().path;
    this.filesDirectoryPath = storagePath;
}

NativeScriptFileStore.prototype = {
    getErrorHandler: function (callback) {
        return function (e) {
            callback && callback(e);
        }
    },

    removeFilesDirectory: function (directoryEntry) {
        var filesDirectoryPath = this.fs.path.join(directoryEntry.path, this.filesDirectoryPath);
        var filesDirectory = this.fs.Folder.fromPath(filesDirectoryPath);
        return filesDirectory.remove();
    },

    removeFile: function (fileEntry) {
        return fileEntry.remove();
    },

    readFileAsText: function (fileEntry) {
        return fileEntry.readText();
    },

    writeTextToFile: function (fileEntry, content) {
        return fileEntry.writeText(content);
    },

    getFile: function (path) {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            self.resolveDataDirectory(function (directoryEntry) {
                var fullFilePath = self.fs.path.join(directoryEntry.path, path);
                var file = self.fs.File.fromPath(fullFilePath);
                resolve(file);
            }, reject);
        });
    },

    resolveDataDirectory: function () {
        var self = this;

        return new rsvp.Promise(function (resolve) {
            var dataDirectory = self.fs.Folder.fromPath(self.dataDirectoryPath);
            resolve(dataDirectory);
        });
    },

    ensureFilesDirectory: function () {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            self.resolveDataDirectory(function (directoryEntry) {
                var fileDirectoryPath = self.fs.path.join(directoryEntry.path, self.filesDirectoryPath);
                self.fs.Folder.fromPath(fileDirectoryPath);
                resolve();
            });
        });
    },

    getFilesDirectoryPath: function () {
        return this.filesDirectoryPath;
    },

    // TODO: [offline] Implement
    writeText: function (fileName, text) {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    createDirectory: function () {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    getFileSize: function (file, getFileSize) {
        throw new Error('Not implemented');
    },

    // TODO: [offline] Implement
    getFileByAbsolutePath: function (path) {
        throw new Error('Not implemented');
    },

    readFileAsBase64: function (file) {
        throw new Error('Not implemented');
    },

    renameFile: function () {
        throw new Error('Not implemented');
    },
};

module.exports = NativeScriptFileStore;
},{"../common":48,"file-system":"file-system"}],78:[function(require,module,exports){
'use strict';

var EverliveError = require('../EverliveError').EverliveError;
var common = require('../common');
var rsvp = common.rsvp;
var utils = require('../utils');
var platform = require('../everlive.platform');
var path = require('path');

function WebFileStore(storagePath, options) {
    this.options = options;

    var filesDirectoryPath;
    if (platform.isWindowsPhone) {
        filesDirectoryPath = '/' + storagePath;
    } else {
        filesDirectoryPath = storagePath + '/';
    }

    this.filesDirectoryPath = filesDirectoryPath;
    this._requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    this._resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;
    this._PERSISTENT_FILE_SYSTEM = window.LocalFileSystem ? window.LocalFileSystem.PERSISTENT : window.PERSISTENT;
}

WebFileStore.prototype = {
    getErrorHandler: function getErrorHandler(callback) {
        var errorsMap = {
            '1000': 'NOT_FOUND'
        };

        _.each(Object.keys(FileError), function (error) {
            errorsMap[FileError[error]] = error;
        });

        return function (e) {
            if (!e.message) {
                e.message = errorsMap[e.code];
            }

            callback && callback(e);
        }
    },

    getDataDirectory: (function () {
        var fileSystemRoot;

        return function getDataDirectory() {
            var self = this;
            var requestFileSystem = function (bytes, success, error) {
                self._requestFileSystem.call(window, self._PERSISTENT_FILE_SYSTEM, bytes, function (fileSystem) {
                    fileSystemRoot = fileSystem.root;
                    fileSystemRoot.nativeURL = fileSystemRoot.nativeURL || fileSystemRoot.toURL();
                    success(fileSystemRoot);
                }, error);
            };

            return new rsvp.Promise(function (resolve, reject) {
                if (fileSystemRoot) {
                    return resolve(fileSystemRoot);
                }

                if (platform.isDesktop) {
                    if (navigator && !navigator.webkitPersistentStorage) {
                        return reject(new EverliveError('FileSystemStorage can be used only with browsers supporting it. Consider using localStorage.'))
                    }

                    navigator.webkitPersistentStorage.requestQuota(self.options.storage.requestedQuota, function (grantedBytes) {
                        requestFileSystem(grantedBytes, resolve, reject);
                    }, reject);
                } else {
                    requestFileSystem(0, resolve, reject);
                }
            });
        }
    }()),

    getFilesDirectory: function getFilesDirectory() {
        var self = this;
        return new rsvp.Promise(function (resolve, reject) {
            self.getDataDirectory()
                .then(function (dataDirectory) {
                    dataDirectory.getDirectory(self.filesDirectoryPath, {
                        create: true,
                        exclusive: false
                    }, resolve, reject);
                })
                .catch(reject);
        });
    },

    removeFilesDirectory: function () {
        var self = this;

        return this.getFilesDirectory()
            .then(function (filesDirectory) {
                return self._removeFolderWrap(filesDirectory);
            });
    },

    removeFile: function (fileEntry) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.remove(function () {
                resolve();
            }, reject);
        });
    },

    readFileAsText: function (fileEntry) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            self.getFilesDirectory().then(function () {
                fileEntry.file(function (file) {
                    var reader = new FileReader();
                    reader.onloadend = function () {
                        var result = this.result;

                        //windows phone returns an object....
                        if (typeof this.result === 'object') {
                            result = JSON.stringify(this.result);
                        }

                        resolve(result);
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                }, reject);
            }).catch(reject);
        });
    },

    writeTextToFile: function (fileEntry, content) {
        var self = this;

        return self.getFilesDirectory()
            .then(function () {
                return self._getWriterWrap(fileEntry, content);
            });
    },

    getFileSize: function (filename, folder) {
        var self = this;

        return new rsvp.Promise(function (resolve, reject) {
            var fileLocation = utils.joinPath(folder, filename);

            return self.getFile(fileLocation)
                .then(function (fileEntry) {
                    fileEntry.file(function (file) {
                        resolve(file.size);
                    }, reject);
                })
        });
    },

    getFile: function (fileName, dirEntry) {
        return this.getFilesDirectory()
            .then(function (directoryEntry) {
                var fileDirectory;
                if (dirEntry) {
                    fileDirectory = dirEntry;
                } else {
                    fileDirectory = directoryEntry;
                }

                return new rsvp.Promise(function (resolve, reject) {
                    fileDirectory.getFile(fileName, {
                        create: true,
                        exclusive: false
                    }, resolve, reject);
                });
            });
    },

    getFileByAbsolutePath: function (path) {
        var self = this;
        path = utils.transformPlatformPath(path);

        return new rsvp.Promise(function (resolve, reject) {
            self._resolveLocalFileSystemURL.call(window, path, resolve, function (err) {
                if (err && err.code === FileError.NOT_FOUND_ERR) {
                    return resolve();
                }

                return reject(err);
            });
        });
    },

    createDirectory: function (directory) {
        var self = this;

        return this.getFilesDirectory()
            .then(function (directoryEntry) {
                return self._getDirectoryWrap(directory, directoryEntry, {
                    create: true,
                    exclusive: false
                });
            });
    },

    renameFile: function (directoryEntry, fileEntry, filename) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.moveTo(directoryEntry, filename, resolve, reject);
        });
    },

    _getDirectoryWrap: function (directory, directoryEntry, options) {
        return new rsvp.Promise(function (resolve, reject) {
            directoryEntry.getDirectory(directory, options, resolve, reject);
        });
    },

    _removeFolderWrap: function (filesDirEntry) {
        return new rsvp.Promise(function (resolve, reject) {
            filesDirEntry.removeRecursively(function () {
                resolve();
            }, reject);
        });
    },

    _getWriterWrap: function (fileEntry, content) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.createWriter(function (fileWriter) {
                fileWriter.onwriteend = function () {
                    resolve();
                };

                fileWriter.onerror = reject;

                var bb = new Blob([content]);
                fileWriter.write(bb);
            }, reject);
        });
    },

    writeText: function (fileName, text, path) {
        var self = this;
        var fileHandle;

        return this.getFilesDirectory()
            .then(function (directoryEntry) {
                if (path) {
                    return self.createDirectory(path);
                } else {
                    return directoryEntry;
                }
            })
            .then(function (directoryEntry) {
                return self.getFile(fileName, directoryEntry);
            })
            .then(function (fileEntry) {
                fileHandle = fileEntry;
                return self.writeTextToFile(fileEntry, text);
            })
            .then(function () {
                // there  is a difference between the cordova implementation and the standard FileTransfer fileEntry
                return fileHandle.nativeURL || fileHandle.toURL();
            });
    },

    // http://stackoverflow.com/questions/9583363/get-base64-from-imageuri-with-phonegap
    readFileAsBase64: function (fileEntry) {
        return new rsvp.Promise(function (resolve, reject) {
            fileEntry.file(function (file) {
                var reader = new FileReader();
                reader.onloadend = function (evt) {
                    resolve(utils.arrayBufferToBase64(evt.target.result));
                };

                reader.readAsArrayBuffer(file);
            }, reject);
        });
    }
};

module.exports = WebFileStore;
},{"../EverliveError":39,"../common":48,"../everlive.platform":51,"../utils":82,"path":5}],79:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var rsvp = require('../common').rsvp;
var Request = require('../Request');
var idField = require('../constants').idField;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;
var _ = require('../common')._;

module.exports = (function () {
    function mergeResultData(data, success) {
        return function (res, response) {
            var attrs = res.result;
            // support for kendo observable array
            if (_.isArray(data) || typeof data.length === 'number') {
                _.each(data, function (item, index) {
                    _.extend(item, attrs[index]);
                });
            }
            else {
                _.extend(data, attrs);
            }

            success(res, response);
        };
    }

    function mergeUpdateResultData(data, success) {
        return function (res) {
            var modifiedAt = res.ModifiedAt;
            data.ModifiedAt = modifiedAt;
            success(res);
        };
    }

    /**
     * @class Data
     * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
     * @param {object} setup
     * @param {string} collectionName
     * @protected
     */
    function Data(setup, collectionName, offlineStorage, everlive) {
        this.setup = setup;
        this.collectionName = collectionName;
        this.options = null;
        this.offlineStorage = offlineStorage;
        this.everlive = everlive;
    }


    Data.prototype = {
        _isOnline: function () {
            return this.offlineStorage ? this.offlineStorage.isOnline() : true;
        },

        _getOfflineCreateData: function (query, requestResponse) {
            var createData;
            if (_.isArray(query.data)) {
                createData = [];
                for (var i = 0; i < query.data.length; i++) {
                    var objectToCreate = _.extend(query.data[i], requestResponse.result[i]);
                    createData.push(objectToCreate)
                }
            } else {
                createData = _.extend(query.data, requestResponse.result);
            }

            return createData;
        },
        _applyOffline: function (query, requestResponse) {
            var autoSyncEnabled = this.offlineStorage && this.offlineStorage.setup.autoSync;
            if (autoSyncEnabled) {
                switch (query.operation) {
                    case DataQuery.operations.read:
                    case DataQuery.operations.readById:
                        var syncReadQuery = new DataQuery(_.defaults({
                            data: requestResponse.result,
                            isSync: true,
                            operation: DataQuery.operations.create
                        }, query));
                        return this.offlineStorage.processQuery(syncReadQuery);
                    case DataQuery.operations.create:
                        var createData = this._getOfflineCreateData(query, requestResponse);
                        var createQuery = new DataQuery(_.defaults({
                            data: createData,
                            isSync: true
                        }, query));
                        return this.offlineStorage.processQuery(createQuery);
                    case DataQuery.operations.update:
                    case DataQuery.operations.rawUpdate:
                        query.isSync = true;
                        query.ModifiedAt = requestResponse.ModifiedAt;
                        return this.offlineStorage.processQuery(query);
                    default:
                        query.isSync = true;
                        return this.offlineStorage.processQuery(query);
                }
            }

            return new rsvp.Promise(function (resolve) {
                resolve();
            });
        },

        _setOption: function (key, value) {
            this.options = this.options || {};
            if (_.isObject(value)) {
                this.options[key] = _.extend({}, this.options[key], value);
            } else {
                this.options[key] = value;
            }
            return this;
        },

        /**
         * @memberOf Data.prototype
         * @method
         * Modifies whether the query should be invoked on the offline storage.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @param workOffline
         * @returns {Data}
         * */
        useOffline: function (useOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in useOffline() query modifier');
            }
            return this._setOption('useOffline', useOffline);
        },

        isSync: function (isSync) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in isSync() query modifier');
            }
            return this._setOption('isSync', isSync);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * Modifies whether the query should invoke the {{@link Authentication.prototype.hasAuthenticationRequirement}}.
         * Default is false.
         * Only valid when authentication module has an onAuthenticationRequired function .
         * @param skipAuth
         * @returns {Data}
         * */
        skipAuth: function (skipAuth) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in skipAuth() query modifier');
            }
            return this._setOption('skipAuth', skipAuth);
        },

        /**
         * Modifies whether the query should be applied offline, if the sdk is currenty working online.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @memberOf Data.prototype
         * @method
         * @param applyOffline
         * @returns {Data}
         * */
        applyOffline: function (applyOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in applyOffline() query modifier');
            }
            return this._setOption('applyOffline', applyOffline);
        },

        /**
         * Sets additional non-standard HTTP headers in the current data request. See [List of Non-Standard HTTP Headers]{{% slug rest-api-headers}} for more information.
         * @memberOf Data.prototype
         * @method
         * @param {object} headers Additional headers to be sent with the data request.
         * @returns {Data}
         */
        withHeaders: function (headers) {
            return this._setOption('headers', headers);
        },
        /**
         * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Data.prototype
         * @method
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Data}
         */
        expand: function (expandExpression) {
            var expandHeader = {
                'X-Everlive-Expand': JSON.stringify(expandExpression)
            };
            return this.withHeaders(expandHeader);
        },

        /**
         * Processes a query with all of its options. Applies the operation online/offline
         * @param {DataQuery} query The query to process
         * @private
         * @param {DataQuery} query
         * @returns {Promise}
         */
        processDataQuery: function (query) {
            var self = this;

            var offlineStorageEnabled = this.everlive._isOfflineStorageEnabled();
            query.useOffline = offlineStorageEnabled ? !this.everlive.isOnline() : false;
            query.applyOffline = offlineStorageEnabled;

            if (this.options) {
                query = _.defaults(this.options, query);
            }

            this.options = null;
            if (!query.skipAuth && this.everlive.authentication && this.everlive.authentication.isAuthenticationInProgress()) {
                query.onError = _.wrap(query.onError, function (errorFunc, err) {
                    if (err.code === EverliveErrors.invalidToken.code || err.code === EverliveErrors.expiredToken.code) {
                        var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                        if (!query.noRetry) {
                            whenAuthenticatedPromise.then(function () {
                                return self.processDataQuery(query);
                            });
                        }
                    } else {
                        errorFunc.call(self, err);
                    }
                });

                //if we are currently authenticating, queue the data query after we have logged in
                if (self.everlive.authentication.isAuthenticating()) {
                    var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                    if (!query.noRetry) {
                        whenAuthenticatedPromise.then(function () {
                            return self.processDataQuery(query);
                        });
                    }
                    return whenAuthenticatedPromise
                }
            }

            if ((!query.isSync && this.offlineStorage && this.offlineStorage.isSynchronizing())) {
                query.onError.call(this, EverliveErrors.syncInProgress);
            } else if (!query.useOffline) {
                var originalSuccess = query.onSuccess;
                query.onSuccess = function () {
                    var args = arguments;
                    var data = args[0];
                    if (query.applyOffline) {
                        return self._applyOffline(query, data)
                            .then(function () {
                                originalSuccess.apply(this, args);
                            }, function () {
                                query.onError.apply(this, arguments);
                            });
                    } else {
                        return originalSuccess.apply(this, args);
                    }
                };

                var getRequestOptionsFromQuery = RequestOptionsBuilder[query.operation];
                var requestOptions = getRequestOptionsFromQuery(query);
                var request = new Request(this.setup, requestOptions);
                request.send();
            } else {
                if (!query.applyOffline) {
                    return query.onError.call(this, new EverliveError('The applyOffline must be false when working offline.'));
                }

                self.offlineStorage.processQuery(query).then(function () {
                    query.onSuccess.apply(this, arguments);
                }, function (err) {
                    if (!err.code) {
                        err = new EverliveError(err.message, EverliveErrors.generalDatabaseError.code);
                    }
                    query.onError.call(this, err);
                });
            }
        },
        // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        get: function (filter, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.read,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: successCb,
                    onError: errorCb
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO handle options
        // TODO think to pass the id as a filter

        /**
         * Gets a data item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets an item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         * */
        getById: function (id, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.readById,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    additionalOptions: {
                        id: id
                    },
                    onSuccess: successCb,
                    onError: errorCb
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Gets the count of the data items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets the count of the items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        count: function (filter, success, error) {
            var self = this;

            return buildPromise(function (sucessCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.count,
                    collectionName: self.collectionName,
                    filter: filter,
                    parse: Request.parsers.single,
                    onSuccess: sucessCb,
                    onError: errorCb
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Creates a data item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data Item or items that will be created.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Creates an item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data The item or items that will be created.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        create: function (data, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.create,
                    collectionName: self.collectionName,
                    data: data,
                    parse: Request.parsers.single,
                    onSuccess: mergeResultData(data, success),
                    onError: error
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updatedObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        rawUpdate: function (attrs, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.rawUpdate,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: attrs,
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO: Check if there is a case in which replace = true is passed to this function
        _update: function (attrs, filter, single, replace, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var data = {};
                data[replace ? '$replace' : '$set'] = attrs;

                // if the update is for a single item - merge the update result and add the ModifiedAt field to the result
                var onSuccess = single ? mergeUpdateResultData(attrs, success) : success;

                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.update,
                    collectionName: self.collectionName,
                    parse: Request.parsers.update,
                    filter: filter,
                    data: data,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    },
                    onSuccess: onSuccess,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} item The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the provided item.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} model The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        updateSingle: function (model, success, error) {
            return this._update(model, null, true, false, success, error);
        },

        /**
         * Updates all items that match a filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} updateObject The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all items that match the filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} model The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        update: function (model, filter, success, error) {
            return this._update(model, filter, false, false, success, error);
        },
        _destroy: function (attrs, filter, single, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: single ? DataQuery.operations.removeSingle : DataQuery.operations.remove,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: success,
                    onError: error,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    }
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} item Object containing the item ID to be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} model Object containing the item ID to be deleted.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroySingle: function (model, success, error) {
            return this._destroy(model, null, true, success, error);
        },

        /**
         * Deletes all data items that match a filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes all items that match the filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroy: function (filter, success, error) {
            return this._destroy(null, filter, false, success, error);
        },

        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of an item with a specified ID.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setAcl: function (acl, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setAcl,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    filter: filter,
                    additionalOptions: {
                        acl: acl
                    },
                    onSuccess: success,
                    onError: error
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.useOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setOwner: function (ownerId, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setOwner,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: {
                        Owner: ownerId
                    },
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} item An object containing the item that is being saved.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} model An object containing the item that is being saved.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        save: function (model, success, error) {
            var self = this;
            var isNew = this.isNew(model);

            return buildPromise(function (success, error) {
                function saveSuccess(res) {
                    res.type = isNew ? 'create' : 'update';
                    success(res);
                }

                function saveError(err) {
                    err.type = isNew ? 'create' : 'update';
                    error(err);
                }

                if (isNew) {
                    return self.create(model, saveSuccess, saveError);
                } else {
                    return self.updateSingle(model, saveSuccess, saveError);
                }
            }, success, error);
        },
        /**
         * Checks if the specified data item is new or not.
         * @memberOf Data.prototype
         * @method
         * @param model Item to check.
         * @returns {boolean}
         */
        isNew: function (model) {
            return typeof model[idField] === 'undefined';
        }
    };

    return Data;
}());

},{"../Everlive":38,"../EverliveError":39,"../Request":44,"../common":48,"../constants":49,"../query/DataQuery":68,"../query/RequestOptionsBuilder":71,"../utils":82}],80:[function(require,module,exports){
/**
 * @class Files
 * @protected
 * @extends Data
 */

var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var utils = require('../utils');

module.exports.addFilesFunctions = function addFilesFunctions(ns) {
    /**
     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUploadUrl
     * @returns {string}
     */
    ns.getUploadUrl = function () {
        return utils.buildUrl(this.setup) + this.collectionName;
    };

    /**
     * Get the download URL for a file.
     * @memberof Files.prototype
     * @method getDownloadUrl
     * @deprecated
     * @see {@link Files.getDownloadUrlById}
     * @param {string} fileId The ID of the file.
     * @returns {string} url The download URL.
     */
    ns.getDownloadUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this.collectionName + '/' + fileId + '/Download';
    };

    ns._getUpdateUrl = function (fileId) {
        return this.collectionName + '/' + fileId + '/Content';
    };

    /**
     * Get a URL that can be used as an endpoint for updating a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUpdateUrl
     * @param {string} fileId The ID of the file.
     * @returns {string} url The update URL.
     */
    ns.getUpdateUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this._getUpdateUrl(fileId);
    };

    /**
     * Updates a file's content
     * @memberof Files.prototype
     * @method updateContent
     * @param {string} fileId File ID.
     * @param {Object} file The file metadata and the base64 encoded file content.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     * @returns {Promise} The promise for the request
     */
    ns.updateContent = function (fileId, file, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesUpdateContent,
                // the passed file content is base64 encoded
                data: file,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                onSuccess: success,
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @param operationParameters
     * @returns {Promise} The promise for the request
     */
    ns.getDownloadUrlById = function (fileId, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesGetDownloadUrlById,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                parse: Request.parsers.single,
                onSuccess: function (data) {
                    success(data.result.Uri);
                },
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };
};
},{"../Request":44,"../query/DataQuery":68,"../utils":82}],81:[function(require,module,exports){
/**
 * @class Users
 * @extends Data
 * @protected
 */

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var guardUnset = utils.guardUnset;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var _ = require('../common')._;
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports.addUsersFunctions = function addUsersFunctions(ns, everlive) {

    /**
     * Registers a new user with username and password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
     * @returns {Promise} The promise for the request.
     */
    /**
     * Registers a new user using a username and a password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param attrs
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.register = function (username, password, attrs, success, error) {
        guardUnset(username, 'username');
        guardUnset(password, 'password');
        var user = {
            Username: username,
            Password: password
        };
        _.extend(user, attrs);
        return this.create(user, success, error);
    };

    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with {@link Users.ResultTypes.curentUserResult}.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @returns {Promise} The promise for the request.
     */
    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with {@link Users.ResultTypes.curentUserResult}.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.currentUser = function (success, error) {
        var self = this;
        var id = self.everlive._isOfflineStorageEnabled() && self.everlive.isOffline() ? self.everlive.setup.principalId : 'me';
        return buildPromise(function (success, error) {
            if (id === 'me' && !self.everlive.setup.token && !self.everlive.setup.masterKey || !id) {
                return success({result: null});
            }

            self.getById(id).then(function (res) {
                    if (typeof res.result !== 'undefined') {
                        success({result: res.result});
                    } else {
                        success({result: null});
                    }
                },
                function (err) {
                    if (self.everlive.authentication && self.everlive.authentication.isAuthenticationInProgress()) {
                        success({result: null});
                    } else if (err.code === 601) { // invalid request, i.e. the access token is missing
                        success({result: null});
                    } else if (err.code === 801) {
                        error(EverliveErrors.invalidToken);
                    } else {
                        error(err);
                    }
                }
            );
        }, success, error);
    };

    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.changePassword = function (username, password, newPassword, keepTokens, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            success = _.wrap(success, function (success, data) {
                if (data && data.result) {
                    if (!keepTokens) {
                        ns.clearAuthorization();
                    }
                }
                return success(data);
            });

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userChangePassword,
                collectionName: self.collectionName,
                data: {
                    Username: username,
                    Password: password,
                    NewPassword: newPassword
                },
                additionalOptions: {
                    keepTokens: keepTokens
                },
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(dataQuery)
        }, success, error)
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.login}
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.login}
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.login = function (username, password, success, error) {
        return everlive.authentication.login(username, password, success, error);

    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.logout}
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.logout}
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.logout = function (success, error) {
        return everlive.authentication.logout(success, error);

    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithFacebook = function (accessToken, success, error) {
        return everlive.authentication.loginWithFacebook(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a Backend Services user with a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithFacebook = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromFacebook = function (userId, success, error) {
        return ns._unlinkFromProvider('Facebook', userId, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithADFS = function (accessToken, success, error) {
        return everlive.authentication.loginWithADFS(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithADFS = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromADFS = function (userId, success, error) {
        return ns._unlinkFromProvider('ADFS', userId, success, error);
    };

    /**
     * Log in a user using a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
     * @param {string} accessToken Microsoft Account access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
     * @param {string} accessToken Microsoft Account access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithLiveID = function (accessToken, success, error) {
        return everlive.authentication.loginWithLiveID(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithLiveID = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromLiveID = function (userId, success, error) {
        return ns._unlinkFromProvider('LiveID', userId, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithGoogle = function (accessToken, success, error) {
        return everlive.authentication.loginWithGoogle(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithGoogle = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromGoogle = function (userId, success, error) {
        return ns._unlinkFromProvider('Google', userId, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithTwitter = function (token, tokenSecret, success, error) {
        return everlive.authentication.loginWithTwitter(token, tokenSecret, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithTwitter = function (userId, token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromTwitter = function (userId, success, error) {
        return ns._unlinkFromProvider('Twitter', userId, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Users.prototype
     * @method setAuthorization
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.setAuthorization}
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    ns.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        everlive.authentication.setAuthorization(token, tokenType, principalId)
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
     * @method clearAuthorization
     * @deprecated
     * @see [authentication.login]{@link ../Authentication/authentication.clearAuthorization}
     * @memberOf Users.prototype
     */
    ns.clearAuthorization = function clearAuthorization() {
        everlive.authentication.setAuthorization(null, null, null);
    };

    /**
     *
     * Sends a password reset email to the user with the specified email address.
     * @memberOf Users.prototype
     * @method resetPassword
     * @name resetPassword
     * @param {string} email The user's username.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Sends a password reset email to the user with the specified email address.
     * @memberOf Users.prototype
     * @method resetPassword
     * @name resetPassword
     * @param {string} email The user's username.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.resetPassword = function (email, success, error) {
        var self = this;

        return buildPromise(function (successCb, errorCb) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userResetPassword,
                collectionName: self.collectionName,
                data: {
                    Email: email
                },
                onSuccess: successCb,
                onError: errorCb
            });

            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    ns._linkWithProvider = function (identity, userId, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    id: userId
                },
                operation: DataQuery.operations.userLinkWithProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };

    ns._unlinkFromProvider = function (providerName, userId, success, error) {
        var identity = {
            Provider: providerName
        };
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    userId: userId
                },
                operation: DataQuery.operations.userUnlinkFromProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };
};
},{"../EverliveError":39,"../Request":44,"../common":48,"../query/DataQuery":68,"../utils":82}],82:[function(require,module,exports){
var EverliveError = require('./EverliveError').EverliveError;
var common = require('./common');
var _ = common._;
var rsvp = common.rsvp;
var Everlive = require('./Everlive');
var platform = require('./everlive.platform');
var path = require('path');

var utils = {};

utils.guardUnset = function guardUnset(value, name, message) {
    if (!message) {
        message = 'The ' + name + ' is required';
    }
    if (typeof value === 'undefined' || value === null) {
        throw new EverliveError(message);
    }
};

utils.parseUtilities = {
    getReviver: function (parseOnlyCompleteDateTimeString) {
        var dateParser;
        if (parseOnlyCompleteDateTimeString) {
            dateParser = utils.parseUtilities.parseIsoDateString;
        } else {
            dateParser = utils.parseUtilities.parseOnlyCompleteDateTimeString;
        }

        return function (key, value) {
            if (typeof value === 'string') {
                var date = dateParser(value);
                if (date) {
                    value = date;
                }
            }

            return value;
        };
    },

    parseIsoDateString: function (string) {
        var match;
        if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
            // DateTime
            var secondParts = match[12];
            if (secondParts) {
                if (secondParts.length > 3) {
                    secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
                }
                else if (secondParts.length < 3) {
                    // if the secondParts are one or two characters then two or one zeros should be appended
                    // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
                    secondParts += secondParts.length === 2 ? '0' : '00';
                }
            }
            var date = new Date(
                Date.UTC(
                    Number(match[1]), // year
                    (Number(match[3]) - 1) || 0, // month
                    Number(match[5]) || 0, // day
                    Number(match[7]) || 0, // hour
                    Number(match[8]) || 0, // minute
                    Number(match[10]) || 0, // second
                    Number(secondParts) || 0
                )
            );

            if (match[13] && match[13] !== "Z") {
                var h = Number(match[16]) || 0,
                    m = Number(match[17]) || 0;

                h *= 3600000;
                m *= 60000;

                var offset = h + m;
                if (match[15] === "+")
                    offset = -offset;

                date = new Date(date.valueOf() + offset);
            }

            return date;
        } else {
            return null;
        }
    },

    parseOnlyCompleteDateTimeString: function (string) {
        if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
            // Date
            return null;
        }

        if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
            // Time
            return null;
        }

        return utils.parseUtilities.parseIsoDateString(string);
    },

    traverse: function (obj, func) {
        var key, value, newValue;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                value = obj[key];
                newValue = func(key, value);
                obj[key] = newValue;
                if (value === newValue && typeof value === 'object') {
                    utils.parseUtilities.traverse(value, func);
                }
            }
        }
        return obj;
    },

    traverseAndRevive: function (data, reviver) {
        if (!reviver) {
            reviver = utils.parseUtilities.getReviver();
        }

        return utils.parseUtilities.traverse(data, reviver);
    },

    parseError: function (reviver, error) {
        if (typeof error === 'string' && error.length > 0) {
            try {
                error = JSON.parse(error);
                return {message: error.message, code: error.errorCode};
            } catch (e) {
                return error;
            }
        } else {
            return error;
        }
    },

    _parseInternal: function (reviver, data) {
        if (typeof data === 'string' && data.length > 0) {
            data = JSON.parse(data, reviver);
        } else if (typeof data === 'object') {
            utils.parseUtilities.traverseAndRevive(data, reviver);
        }

        return data;
    },

    _transformResult: function (data, additionalProperties) {
        if (data) {
            var result = {result: data.Result};
            _.extend(result, additionalProperties);
            return result;
        } else {
            return data;
        }
    },

    parseResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {count: data.Count});
    },

    parseSingleResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data);
    },

    parseUpdateResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {ModifiedAt: data.ModifiedAt});
    },

    parseJSON: function (json) {
        return JSON.parse(json, utils.parseUtilities.getReviver());
    }
};

utils.buildPromise = function buildPromise(operation, success, error) {
    var callbacks = utils.getCallbacks(success, error);
    operation(callbacks.success, callbacks.error);
    return callbacks.promise;
};

utils.getCallbacks = function (success, error) {
    var promise;
    var createPromise = function () {
        return new rsvp.Promise(function (resolve, reject) {
            success = function (data) {
                resolve(data);
            };
            error = function (error) {
                reject(error);
            };
        });
    };

    if (platform.isNodejs) {
        // node js style continuation
        if (typeof success === 'function' && typeof error !== 'function') {
            var callback = success;
            success = function (data, response) {
                callback(null, data, response);
            };
            error = function (error) {
                callback(error);
            };
        } else if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    } else {
        if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    }

    return {promise: promise, success: success, error: error};
};

utils.buildAuthHeader = function buildAuthHeader(setup, options) {
    var authHeaderValue = null;
    if (options && options.authHeaders === false) {
        return authHeaderValue;
    }
    if (setup.token) {
        authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
    }
    else if (setup.masterKey) {
        authHeaderValue = 'masterkey ' + setup.masterKey;
    }
    if (authHeaderValue) {
        return {Authorization: authHeaderValue};
    } else {
        return null;
    }
};

utils.DeviceRegistrationResult = function DeviceRegistrationResult(token) {
    this.token = token;
};

utils.cloneDate = function (date) {
    return new Date(date);
};

utils.buildUrl = function (setup) {
    var url = '';
    if (typeof setup.scheme === 'string') {
        url += setup.scheme + ':';
    }
    url += setup.url;
    if (setup.apiKey) {
        url += setup.apiKey + '/';
    }
    return url;
};

utils.getDbOperators = function (expression, shallow) {
    var dbOperators = [];

    if (typeof expression === 'string') {
        return dbOperators;
    }

    var modifierKeys = Object.keys(expression);
    _.each(modifierKeys, function (key) {
        if (key.indexOf('$') === 0) {
            dbOperators.push(key);
        } else if (typeof expression[key] === 'object' && !shallow) {
            dbOperators = dbOperators.concat(utils.getDbOperators(expression[key]));
        }
    });

    return dbOperators;
};

utils.disableRequestCache = function (url, method) {
    if (method === 'GET') {
        var timestamp = (new Date()).getTime();
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        url += separator + '_el=' + timestamp;
    }

    return url;
};

var unsupportedDbOperators = [
    '$geoWithin',
    '$geoIntersects',
    '$near',
    '$within',
    '$nearSphere'
];

utils.getUnsupportedOperators = function (filter) {
    var dbOperators = utils.getDbOperators(filter);
    return _.intersection(dbOperators, unsupportedDbOperators);
};

// http://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid
utils.isGuid = function (str) {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str);
};

// http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript/16245768#16245768
utils.b64toBlob = function (b64Data, contentType, sliceSize) {
    contentType = contentType || '';
    sliceSize = sliceSize || 512;

    var byteCharacters = atob(b64Data);
    var byteArrays = [];

    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        var slice = byteCharacters.slice(offset, offset + sliceSize);

        var byteNumbers = new Array(slice.length);
        for (var i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }

        var byteArray = new Uint8Array(byteNumbers);

        byteArrays.push(byteArray);
    }

    var blob = new Blob(byteArrays, {type: contentType});
    return blob;
};

// http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
utils.arrayBufferToBase64 = function (buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }

    return btoa(binary);
};

utils.successfulPromise = function (data) {
    return new rsvp.Promise(function (resolve) {
        resolve(data);
    });
};

utils.rejectedPromise = function (err) {
    return new rsvp.Promise(function (resolve, reject) {
        reject(err);
    });
};

utils.transformPlatformPath = function transformPlatformPath(platformPath) {
    if (!platformPath) {
        return '';
    }

    if (platform.isWindowsPhone) {
        if (platformPath.charAt(0) === '/' && platformPath.charAt(1) !== '/') {
            platformPath = '/' + platformPath;
        }
    } else { //TODO: probably desktop too
        if (platformPath.indexOf('file:/') !== -1 && platformPath.indexOf('file:///') === -1) {
            platformPath = platformPath.replace('file:/', 'file:///');
        }
    }

    return platformPath;
};

utils._stringCompare = function (string, check) {
    return string.toLowerCase() === check;
};

utils.isContentType = {
    files: function (collectionName) {
        return utils._stringCompare(collectionName, 'files');
    },
    users: function (collectionName) {
        return utils._stringCompare(collectionName, 'users');
    }
};

utils.isElement = {
    _isElement: function (el, check) {
        var tag = el;

        if (typeof tag !== 'string') {
            if (el instanceof HTMLElement) {
                tag = el.tagName;
            }
        }

        return utils._stringCompare(tag, check);
    },
    image: function (el) {
        return utils.isElement._isElement(el, 'img');
    },
    anchor: function (el) {
        return utils.isElement._isElement(el, 'a');
    }
};

utils.joinPath = function joinPath() {
    var args = [].slice.apply(arguments).map(function (arg) {
        return arg || '';
    });

    var joinedPath = path.join.apply(path, args);
    return utils.transformPlatformPath(joinedPath);
};

utils.uuid = function () {
    //http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });

    return uuid;
};

utils.getId = function (obj) {
    return obj.Id || obj._id || obj.id;
};

module.exports = utils;

},{"./Everlive":38,"./EverliveError":39,"./common":48,"./everlive.platform":51,"path":5}]},{},[56])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQmFzZTY0L2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L21vZHMuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC10eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kb3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kb3QtY29tcG9uZW50L25vZGVfbW9kdWxlcy90eXBlLWNvbXBvbmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvbW9uZ28tZXFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9vYmplY3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L29wcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9jcnlwdG9qcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvYWVzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9jaXBoZXItY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvZW5jLWJhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvZXZwa2RmLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9qc29uZm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9tZDUuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvQ29uc3RhbnRzLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL0V4ZWN1dGlvblRyZWUuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvRXhwYW5kRXJyb3IuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvUHJvY2Vzc29yLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL1JlbGF0aW9uTm9kZS5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9SZWxhdGlvblRyZWVCdWlsZGVyLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCJzcmMvQ3VycmVudERldmljZS5qcyIsInNyYy9FdmVudEVtaXR0ZXJQcm94eS5qcyIsInNyYy9FdmVybGl2ZS5qcyIsInNyYy9FdmVybGl2ZUVycm9yLmpzIiwic3JjL0V4cGFuZFByb2Nlc3Nvci5qcyIsInNyYy9FeHByZXNzaW9uLmpzIiwic3JjL0dlb1BvaW50LmpzIiwic3JjL1B1c2guanMiLCJzcmMvUmVxdWVzdC5qcyIsInNyYy9TZXR1cC5qcyIsInNyYy9hdXRoL0F1dGhlbnRpY2F0aW9uLmpzIiwic3JjL2F1dGgvQXV0aGVudGljYXRpb25TZXR1cC5qcyIsInNyYy9jb21tb24uanMiLCJzcmMvY29uc3RhbnRzLmpzIiwic3JjL2VuY3J5cHRpb24vQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyLmpzIiwic3JjL2V2ZXJsaXZlLnBsYXRmb3JtLmpzIiwic3JjL2hlbHBlcnMvaGVscGVycy5qcyIsInNyYy9oZWxwZXJzL2h0bWwvaHRtbEhlbHBlci5qcyIsInNyYy9oZWxwZXJzL2h0bWwvaHRtbEhlbHBlck9mZmxpbmVNb2R1bGUuanMiLCJzcmMvaGVscGVycy9odG1sL2h0bWxIZWxwZXJSZXNwb25zaXZlTW9kdWxlLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2tlbmRvL2tlbmRvLmV2ZXJsaXZlLmpzIiwic3JjL29mZmxpbmUvT2ZmbGluZUZpbGVzTW9kdWxlLmpzIiwic3JjL29mZmxpbmUvT2ZmbGluZUZpbGVzUHJvY2Vzc29yLmpzIiwic3JjL29mZmxpbmUvT2ZmbGluZVF1ZXJ5UHJvY2Vzc29yLmpzIiwic3JjL29mZmxpbmUvT2ZmbGluZVN0b3JhZ2VNb2R1bGUuanMiLCJzcmMvb2ZmbGluZS9vZmZsaW5lLmpzIiwic3JjL29mZmxpbmUvb2ZmbGluZVBlcnNpc3RlcnMuanMiLCJzcmMvb2ZmbGluZS9vZmZsaW5lVHJhbnNmb3JtYXRpb25zLmpzIiwic3JjL29mZmxpbmUvcGVyc2lzdGVycy9CYXNlUGVyc2lzdGVyLmpzIiwic3JjL29mZmxpbmUvcGVyc2lzdGVycy9GaWxlU3lzdGVtUGVyc2lzdGVyLmpzIiwic3JjL29mZmxpbmUvcGVyc2lzdGVycy9Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXIuanMiLCJzcmMvcXVlcnkvRGF0YVF1ZXJ5LmpzIiwic3JjL3F1ZXJ5L1F1ZXJ5LmpzIiwic3JjL3F1ZXJ5L1F1ZXJ5QnVpbGRlci5qcyIsInNyYy9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXIuanMiLCJzcmMvcXVlcnkvV2hlcmVRdWVyeS5qcyIsInNyYy9yZXF3ZXN0Lm5hdGl2ZXNjcmlwdC5qcyIsInNyYy9yZXF3ZXN0Lm5vZGVqcy5qcyIsInNyYy9zdG9yYWdlcy9GaWxlU3RvcmUuanMiLCJzcmMvc3RvcmFnZXMvTG9jYWxTdG9yZS5qcyIsInNyYy9zdG9yYWdlcy9OYXRpdmVTY3JpcHRGaWxlU3RvcmUuanMiLCJzcmMvc3RvcmFnZXMvV2ViRmlsZVN0b3JlLmpzIiwic3JjL3R5cGVzL0RhdGEuanMiLCJzcmMvdHlwZXMvRmlsZXMuanMiLCJzcmMvdHlwZXMvVXNlcnMuanMiLCJzcmMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIjsoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzOyAvLyAjODogd2ViIHdvcmtlcnNcbiAgdmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuICBmdW5jdGlvbiBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcjtcbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbiAgLy8gZW5jb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vOTk5MTY2XSBieSBbaHR0cHM6Ly9naXRodWIuY29tL25pZ25hZ11cbiAgb2JqZWN0LmJ0b2EgfHwgKFxuICBvYmplY3QuYnRvYSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpO1xuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnMsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuICAgICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICAgKSB7XG4gICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGlkeCArPSAzLzQpO1xuICAgICAgaWYgKGNoYXJDb2RlID4gMHhGRikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2J0b2EnIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBlbmNvZGVkIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3V0c2lkZSBvZiB0aGUgTGF0aW4xIHJhbmdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxuICAvLyBkZWNvZGVyXG4gIC8vIFtodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDIwMzk2XSBieSBbaHR0cHM6Ly9naXRodWIuY29tL2F0a11cbiAgb2JqZWN0LmF0b2IgfHwgKFxuICBvYmplY3QuYXRvYiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoc3RyLmxlbmd0aCAlIDQgPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIidhdG9iJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuXCIpO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXG4gICAgICB2YXIgYmMgPSAwLCBicywgYnVmZmVyLCBpZHggPSAwLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGdldCBuZXh0IGNoYXJhY3RlclxuICAgICAgYnVmZmVyID0gc3RyLmNoYXJBdChpZHgrKyk7XG4gICAgICAvLyBjaGFyYWN0ZXIgZm91bmQgaW4gdGFibGU/IGluaXRpYWxpemUgYml0IHN0b3JhZ2UgYW5kIGFkZCBpdHMgYXNjaWkgdmFsdWU7XG4gICAgICB+YnVmZmVyICYmIChicyA9IGJjICUgNCA/IGJzICogNjQgKyBidWZmZXIgOiBidWZmZXIsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgZmlyc3Qgb2YgZWFjaCA0IGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIGZpcnN0IDggYml0cyB0byBvbmUgYXNjaWkgY2hhcmFjdGVyXG4gICAgICAgIGJjKysgJSA0KSA/IG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmIGJzID4+ICgtMiAqIGJjICYgNikpIDogMFxuICAgICkge1xuICAgICAgLy8gdHJ5IHRvIGZpbmQgY2hhcmFjdGVyIGluIHRhYmxlICgwLTYzLCBub3QgZm91bmQgPT4gLTEpXG4gICAgICBidWZmZXIgPSBjaGFycy5pbmRleE9mKGJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pO1xuXG59KCkpO1xuIixudWxsLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgb3BzID0gcmVxdWlyZSgnLi9vcHMnKTtcbnZhciBlcWwgPSByZXF1aXJlKCdtb25nby1lcWwnKTtcbnZhciBkb3QgPSByZXF1aXJlKCdkb3QtY29tcG9uZW50Jyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9uZ28tcXVlcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmaWx0ZXI7XG5leHBvcnRzLm9wcyA9IG9wcztcblxuLyoqXG4gKiBGaWx0ZXJzIGFuIGBvYmpgIGJ5IHRoZSBnaXZlbiBgcXVlcnlgIGZvciBzdWJkb2N1bWVudHMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fEJvb2xlYW59IGZhbHNlIGlmIG5vIG1hdGNoLCBvciBtYXRjaGVkIHN1YmRvY3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyKG9iaiwgcXVlcnkpe1xuICBvYmogPSBvYmogfHwge307XG4gIHZhciByZXQgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpIHtcbiAgICBpZiAoIXF1ZXJ5Lmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gc2VhcmNoIHZhbHVlXG4gICAgdmFyIHZhbCA9IHF1ZXJ5W2tleV07XG5cbiAgICAvLyBzcGxpdCB0aGUga2V5IGludG8gcHJlZml4IGFuZCBzdWZmaXhcbiAgICB2YXIga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIHZhciB0YXJnZXQgPSBvYmo7XG4gICAgdmFyIHByZWZpeCwgc2VhcmNoO1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICB3YWxrX2tleXM6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXRba2V5c1tpXV07XG5cbiAgICAgIHN3aXRjaCAodHlwZSh0YXJnZXQpKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFycmF5IHN1YmRvY3VtZW50IHNlYXJjaCB3ZSBzdG9wIGhlcmVcbiAgICAgICAgICBwcmVmaXggPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgICAgc2VhcmNoID0ga2V5cy5zbGljZShpICsgMSkuam9pbignLicpO1xuXG4gICAgICAgICAgZGVidWcoJ3NlYXJjaGluZyBhcnJheSBcIiVzXCInLCBwcmVmaXgpO1xuXG4gICAgICAgICAgLy8gd2Ugc3BlY2lhbCBjYXNlIG9wZXJhdG9ycyB0aGF0IGRvbid0IHdhbGsgdGhlIGFycmF5XG4gICAgICAgICAgaWYgKHZhbC4kc2l6ZSAmJiAhc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUodmFsLCB0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdhbGsgc3ViZG9jc1xuICAgICAgICAgIHZhciBzdWJzZXQgPSByZXRbcHJlZml4XSB8fCB0YXJnZXQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3Vic2V0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHEgPSB7fTtcbiAgICAgICAgICAgICAgcVtzZWFyY2hdID0gdmFsO1xuICAgICAgICAgICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZShzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHN1YmRvYyBzZWFyY2ggd2l0aCBxdWVyeSAlaicsIHEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIoc3Vic2V0W2lpXSwgcSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgcmV0IHZhbHVlIG9mIGZpbHRlclxuICAgICAgICAgICAgICAgICAgaWYgKCFyZXRbcHJlZml4XSB8fCAhfnJldFtwcmVmaXhdLmluZGV4T2Yoc3Vic2V0W2lpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YnNldFtpaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVidWcoJ3BlcmZvcm1pbmcgc2ltcGxlIGFycmF5IGl0ZW0gc2VhcmNoJyk7XG4gICAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbCwgc3Vic2V0W2lpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJldFtwcmVmaXhdIHx8ICF+cmV0W3ByZWZpeF0uaW5kZXhPZihzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YnNldFtpaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0W3ByZWZpeF0gPSByZXRbcHJlZml4XSB8fCBbXTtcbiAgICAgICAgICAgIHJldFtwcmVmaXhdLnB1c2guYXBwbHkocmV0W3ByZWZpeF0sIG1hdGNoZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdlIGRvbid0IGNvbnRpbnVlIHRoZSBrZXkgc2VhcmNoXG4gICAgICAgICAgYnJlYWsgd2Fsa19rZXlzO1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmluZCB0aGUga2V5XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKG51bGwgIT0ga2V5c1tpICsgMV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXBhcmUodmFsLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFjb21wYXJlKHZhbCwgdGFyZ2V0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIGdpdmVuIG1hdGNoZXIgd2l0aCB0aGUgZG9jdW1lbnQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbWF0Y2hlclxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmUobWF0Y2hlciwgdmFsKXtcbiAgaWYgKCdvYmplY3QnICE9IHR5cGUobWF0Y2hlcikpIHtcbiAgICByZXR1cm4gZXFsKG1hdGNoZXIsIHZhbCk7XG4gIH1cblxuICB2YXIga2V5cyA9IG9iamVjdC5rZXlzKG1hdGNoZXIpO1xuICBpZiAoJyQnID09IGtleXNbMF1bMF0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igc3ViLW9iamVjdCBtYXRjaGluZ1xuICAgICAgaWYgKCckZWxlbU1hdGNoJyA9PSBrZXlzW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZSAhPT0gZmlsdGVyKHZhbCwgbWF0Y2hlci4kZWxlbU1hdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3BzW2tleXNbaV1dKG1hdGNoZXJba2V5c1tpXV0sIHZhbCkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVxbChtYXRjaGVyLCB2YWwpO1xuICB9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgbW9kcyA9IHJlcXVpcmUoJy4vbW9kcycpO1xudmFyIGZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG52YXIgZG90ID0gcmVxdWlyZSgnZG90LWNvbXBvbmVudCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCdjb21wb25lbnQtdHlwZScpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoJ29iamVjdC1jb21wb25lbnQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vbmdvLXF1ZXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcXVlcnk7XG5cbi8qKlxuICogRXhwb3J0IGZpbHRlciBoZWxwZXIuXG4gKi9cblxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG5cbi8qKlxuICogRXhwb3J0IG1vZGlmaWVycy5cbiAqL1xuXG5leHBvcnRzLm1vZHMgPSBtb2RzO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBxdWVyeS5cbiAqXG4gKiBPcHRpb25zOlxuICogIC0gYHN0cmljdGAgb25seSBtb2RpZnkgaWYgcXVlcnkgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gYWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyeSB0byBmaWx0ZXIgbW9kaWZpY2F0aW9ucyBieVxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gcXVlcnkob2JqLCBxdWVyeSwgdXBkYXRlLCBvcHRzKXtcbiAgb2JqID0gb2JqIHx8IHt9O1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgcXVlcnkgPSBxdWVyeSB8fCB7fTtcbiAgdXBkYXRlID0gdXBkYXRlIHx8IHt9O1xuXG4gIC8vIHN0cmljdCBtb2RlXG4gIHZhciBzdHJpY3QgPSAhIW9wdHMuc3RyaWN0O1xuXG4gIHZhciBtYXRjaDtcbiAgdmFyIGxvZyA9IFtdO1xuXG4gIGlmIChvYmplY3QubGVuZ3RoKHF1ZXJ5KSkge1xuICAgIG1hdGNoID0gZmlsdGVyKG9iaiwgcXVlcnkpO1xuICB9XG5cbiAgaWYgKCFzdHJpY3QgfHwgZmFsc2UgIT09IG1hdGNoKSB7XG4gICAgdmFyIGtleXMgPSBvYmplY3Qua2V5cyh1cGRhdGUpO1xuICAgIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChtb2RzW2tleXNbaV1dKSB7XG4gICAgICAgIGRlYnVnKCdmb3VuZCBtb2RpZmllciBcIiVzXCInLCBrZXlzW2ldKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHVwZGF0ZVtrZXlzW2ldXSkge1xuICAgICAgICAgIHZhciBwb3MgPSBrZXkuaW5kZXhPZignLiQuJyk7XG5cbiAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGtleS5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBrZXkuc3Vic3RyKHBvcyArIDMpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbcHJlZml4XSkge1xuICAgICAgICAgICAgICBkZWJ1ZygnZXhlY3V0aW5nIFwiJXNcIiAlcyBvbiBmaXJzdCBtYXRjaCB3aXRoaW4gXCIlc1wiJywga2V5LCBrZXlzW2ldLCBwcmVmaXgpO1xuICAgICAgICAgICAgICB2YXIgZm4gPSBtb2RzW2tleXNbaV1dKG1hdGNoW3ByZWZpeF1bMF0sIHN1ZmZpeCwgdXBkYXRlW2tleXNbaV1dW2tleV0pO1xuICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlIGEga2V5IG5hbWUgcmVwbGFjaW5nICQgd2l0aCB0aGUgYWN0dWFsIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyB1bm5lY2Vzc2FyaWx5IGV4cGVuc2l2ZVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGRvdC5nZXQob2JqLCBwcmVmaXgpLmluZGV4T2YobWF0Y2hbcHJlZml4XVswXSk7XG4gICAgICAgICAgICAgICAgZm4ua2V5ID0gcHJlZml4ICsgJy4nICsgaW5kZXggKyAnLicgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgZm4ub3AgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKGZuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIFwiJXNcIiAlcyAtIG5vIG1hdGNoZXMgd2l0aGluIFwiJXNcIicsIGtleSwga2V5c1tpXSwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuID0gbW9kc1trZXlzW2ldXShvYmosIGtleSwgdXBkYXRlW2tleXNbaV1dW2tleV0pO1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgIGZuLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgZm4ub3AgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMucHVzaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Zygnc2tpcHBpbmcgdW5rbm93biBtb2RpZmllciBcIiVzXCInLCBrZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgLy8gaWYgd2UgZ290IGhlcmUgZXJyb3IgZnJlZSB3ZSBwcm9jZXNzIGFsbCB0cmFuc2FjdGlvbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IHRyYW5zYWN0aW9uc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IGZuKCk7XG4gICAgICAgIGxvZy5wdXNoKHsgb3A6IGZuLm9wLCBrZXk6IGZuLmtleSwgdmFsdWU6IHZhbCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ25vIG1hdGNoZXMgZm9yIHF1ZXJ5ICVqJywgcXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIGxvZztcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlcWwgPSByZXF1aXJlKCdtb25nby1lcWwnKTtcbnZhciBkb3QgPSByZXF1aXJlKCdkb3QtY29tcG9uZW50Jyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1jb21wb25lbnQnKS5rZXlzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9uZ28tcXVlcnknKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkc2V0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kc2V0ID0gZnVuY3Rpb24gJHNldChvYmosIHBhdGgsIHZhbCl7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoIWVxbChvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAobnVtZXJpYyhrZXkpKSB7XG4gICAgICAgIGlmICghZXFsKG9ialtrZXldLCB2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyRzZXQgb25seSBzdXBwb3J0cyBvYmplY3Qgbm90ICcgKyB0eXBlKG9iaikpO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGFuIGAkdW5zZXRgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiR1bnNldCA9IGZ1bmN0aW9uICR1bnNldChvYmosIHBhdGgpe1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAvLyByZW1pbmRlcjogYGRlbGV0ZSBhcnJbMV1gID09PSBgZGVsZXRlIGFyclsnMSddYCBbIV1cbiAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBmYWlsIHNpbGVudGx5XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyB1bnNldCBvZiBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRyZW5hbWVgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRyZW5hbWUgPSBmdW5jdGlvbiAkcmVuYW1lKG9iaiwgcGF0aCwgbmV3S2V5KXtcbiAgLy8gdGFyZ2V0ID0gc291cmNlXG4gIGlmIChwYXRoID09IG5ld0tleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignJHJlbmFtZSBzb3VyY2UgbXVzdCBkaWZmZXIgZnJvbSB0YXJnZXQnKTtcbiAgfVxuXG4gIC8vIHRhcmdldCBpcyBwYXJlbnQgb2Ygc291cmNlXG4gIGlmICgwID09PSBwYXRoLmluZGV4T2YobmV3S2V5ICsgJy4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignJHJlbmFtZSB0YXJnZXQgbWF5IG5vdCBiZSBhIHBhcmVudCBvZiBzb3VyY2UnKTtcbiAgfVxuXG4gIHZhciBwID0gZG90LnBhcmVudChvYmosIHBhdGgpO1xuICB2YXIgdCA9IHR5cGUocCk7XG5cbiAgaWYgKCdvYmplY3QnID09IHQpIHtcbiAgICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gICAgaWYgKHAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2YWwgPSBwW2tleV07XG4gICAgICAgIGRlbGV0ZSBwW2tleV07XG5cbiAgICAgICAgLy8gdGFyZ2V0IGRvZXMgaW5pdGlhbGl6ZSB0aGUgcGF0aFxuICAgICAgICB2YXIgbmV3cCA9IGRvdC5wYXJlbnQob2JqLCBuZXdLZXksIHRydWUpO1xuXG4gICAgICAgIC8vIGFuZCBhbHNvIGZhaWxzIHNpbGVudGx5IHVwb24gdHlwZSBtaXNtYXRjaFxuICAgICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZShuZXdwKSkge1xuICAgICAgICAgIG5ld3BbbmV3S2V5LnNwbGl0KCcuJykucG9wKCldID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdpbnZhbGlkICRyZW5hbWUgdGFyZ2V0IHBhdGggdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbmV3IGtleVxuICAgICAgICByZXR1cm4gbmV3S2V5O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHJlbmFtZSBmcm9tIGluZXhpc3Rpbmcgc291cmNlJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnICE9IHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRyZW5hbWUgc291cmNlIGZpZWxkIGludmFsaWQnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiBgJGluY2AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJGluYyA9IGZ1bmN0aW9uICRpbmMob2JqLCBwYXRoLCBpbmMpe1xuICBpZiAoJ251bWJlcicgIT0gdHlwZShpbmMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2RpZmllciAkaW5jIGFsbG93ZWQgZm9yIG51bWJlcnMgb25seScpO1xuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInICE9IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJGluYyBtb2RpZmllciB0byBub24tbnVtYmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSArPSBpbmM7XG4gICAgICAgICAgcmV0dXJuIGluYztcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZignb2JqZWN0JyA9PSB0eXBlKG9iaikgfHwgbnVtZXJpYyhrZXkpKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBpbmM7XG4gICAgICAgICAgcmV0dXJuIGluYztcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJGluYyBtb2RpZmllciB0byBub24tbnVtYmVyJyk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gYCRwb3BgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRwb3AgPSBmdW5jdGlvbiAkcG9wKG9iaiwgcGF0aCwgdmFsKXtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIC8vIHdlIG1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IGp1c3QgdGhlIHBhcmVudCBvZiB0aGUgbWFpbiBrZXlcbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgaWYgKG9ialtrZXldLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBpZiAoLTEgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tleV0uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gbW9uZ29kYiBhbGxvd3MgYW55IHZhbHVlIHRvIHBvcFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBwb3AgdG8gaW5leGlzdGluZyBrZXknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwb3AgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBwb3AgdG8gaW5leGlzdGluZyBrZXknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb3AgdG8gaW5leGlzdGluZyBrZXknKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRwdXNoYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBwdXNoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHB1c2ggPSBmdW5jdGlvbiAkcHVzaChvYmosIHBhdGgsIHZhbCl7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVzaEFsbGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgdG8gcHVzaFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRwdXNoQWxsID0gZnVuY3Rpb24gJHB1c2hBbGwob2JqLCBwYXRoLCB2YWwpe1xuICBpZiAoJ2FycmF5JyAhPSB0eXBlKHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGlmaWVyICRwdXNoQWxsL3B1bGxBbGwgYWxsb3dlZCBmb3IgYXJyYXlzIG9ubHknKTtcbiAgfVxuXG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldLnB1c2guYXBwbHkob2JqW2tleV0sIHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1c2gvJHB1c2hBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaC5hcHBseShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1bGxgLlxuICovXG5cbmV4cG9ydHMuJHB1bGwgPSBmdW5jdGlvbiAkcHVsbChvYmosIHBhdGgsIHZhbCl7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgdmFyIHQgPSB0eXBlKG9iaik7XG5cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgW3ZhbF0sIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgW3ZhbF0sIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcHVsbCB0byBub24gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTEVGVF9TVUJGSUVMRCBvbmx5IHN1cHBvcnRzIE9iamVjdDogaGVsbG8gbm90OiAnICsgdCk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1bGxBbGxgLlxuICovXG5cbmV4cG9ydHMuJHB1bGxBbGwgPSBmdW5jdGlvbiAkcHVsbEFsbChvYmosIHBhdGgsIHZhbCl7XG4gIGlmICgnYXJyYXknICE9IHR5cGUodmFsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kaWZpZXIgJHB1c2hBbGwvcHVsbEFsbCBhbGxvd2VkIGZvciBhcnJheXMgb25seScpO1xuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICB2YXIgdCA9IHR5cGUob2JqKTtcblxuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCB2YWwsIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHZhciBwdWxsZWQgPSBbXTtcbiAgICAgICAgICB2YXIgc3BsaWNlID0gcHVsbChvYmpba2V5XSwgdmFsLCBwdWxsZWQpO1xuICAgICAgICAgIGlmIChwdWxsZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgc3BsaWNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBwdWxsZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVsbC8kcHVsbEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHB1bGwgdG8gbm9uIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xFRlRfU1VCRklFTEQgb25seSBzdXBwb3J0cyBPYmplY3Q6IGhlbGxvIG5vdDogJyArIHQpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRhZGRUb1NldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gcHVzaFxuICogQHBhcmFtIHtCb29sZWFufSBpbnRlcm5hbCwgdHJ1ZSBpZiByZWN1cnNpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kYWRkVG9TZXQgPSBmdW5jdGlvbiAkYWRkVG9TZXQob2JqLCBwYXRoLCB2YWwsIHJlY3Vyc2luZyl7XG4gIGlmICghcmVjdXJzaW5nICYmICdhcnJheScgPT0gdHlwZSh2YWwuJGVhY2gpKSB7XG4gICAgdmFyIGZucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsLiRlYWNoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGZuID0gJGFkZFRvU2V0KG9iaiwgcGF0aCwgdmFsLiRlYWNoW2ldLCB0cnVlKTtcbiAgICAgIGlmIChmbikgZm5zLnB1c2goZm4pO1xuICAgIH1cbiAgICBpZiAoZm5zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHZhbHVlcy5wdXNoKGZuc1tpXSgpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgaWYgKCFoYXMob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkYWRkVG9TZXQgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gW3ZhbF07XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgaWYgKCFoYXMob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkYWRkVG9TZXQgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobnVtZXJpYyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gW3ZhbF07XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBhcHBlbmQgdG8gYXJyYXkgdXNpbmcgc3RyaW5nIGZpZWxkIG5hbWUgWycgKyBrZXkgKyAnXScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBkZXRlcm1pbmluZyBpZiBhbiBhcnJheSBoYXMgdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzKGFycmF5LCB2YWwpe1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChlcWwodmFsLCBhcnJheVtpXSkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBcnJheSNmaWx0ZXIgZnVuY3Rpb24gZ2VuZXJhdG9yIGZvciBgJHB1bGxgL2AkcHVsbEFsbGAgb3BlcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiB2YWx1ZXMgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IHRvIHBvcHVsYXRlIHdpdGggcmVzdWx0c1xuICogQHJldHVybiB7RnVuY3Rpb259IHRoYXQgc3BsaWNlcyB0aGUgYXJyYXlcbiAqL1xuXG5mdW5jdGlvbiBwdWxsKGFyciwgdmFscywgcHVsbGVkKXtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICBmb3IgKHZhciBhID0gMDsgYSA8IGFyci5sZW5ndGg7IGErKykge1xuICAgIHZhciB2YWwgPSBhcnJbYV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXRjaGVyID0gdmFsc1tpXTtcbiAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKG1hdGNoZXIpKSB7XG4gICAgICAgIC8vIHdlIG9ubHkgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvYmogPC0+IG9iaiBjb21wYXJpc29uc1xuICAgICAgICBpZiAoJ29iamVjdCcgPT0gdHlwZSh2YWwpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoa2V5cyhtYXRjaGVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbWF0Y2hlcikge1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIGtleSB0byBwdWxsXG4gICAgICAgICAgICAgICAgaWYgKGVxbChtYXRjaGVyW2ldLCB2YWxbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIGEgc2luZ2xlIGtleSBkb2Vzbid0IG1hdGNoIHdlIG1vdmUgb25cbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFrZXlzKHZhbCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBwdWxsIGB7fWAgbWF0Y2hlcyBbe31dXG4gICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goYSk7XG4gICAgICAgICAgICBwdWxsZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyBwdWxsIG1hdGNoIGFnYWluc3Qgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlcWwobWF0Y2hlciwgdmFsKSkge1xuICAgICAgICAgIGluZGV4ZXMucHVzaChhKTtcbiAgICAgICAgICBwdWxsZWQucHVzaCh2YWwpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2ldO1xuICAgICAgYXJyLnNwbGljZShpbmRleCAtIGksIDEpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgbnVtZXJpYy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG51bWVyaWNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG51bWVyaWModmFsKXtcbiAgcmV0dXJuICdudW1iZXInID09IHR5cGUodmFsKSB8fCBOdW1iZXIodmFsKSA9PSB2YWw7XG59XG4iLCIvKipcbiAqIHRvU3RyaW5nIHJlZi5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpe1xuICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6IHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgIT09IHZhbCkgcmV0dXJuICduYW4nO1xuICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztcblxuICB2YWwgPSB2YWwudmFsdWVPZlxuICAgID8gdmFsLnZhbHVlT2YoKVxuICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbClcblxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIFVzZSBjaHJvbWUuc3RvcmFnZS5sb2NhbCBpZiB3ZSBhcmUgaW4gYW4gYXBwXG4gKi9cblxudmFyIHN0b3JhZ2U7XG5cbmlmICh0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY2hyb21lLnN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKVxuICBzdG9yYWdlID0gY2hyb21lLnN0b3JhZ2UubG9jYWw7XG5lbHNlXG4gIHN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IHN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtY29tcG9uZW50Jyk7XG5cbi8qKlxuICogR2V0cyBhIGNlcnRhaW4gYHBhdGhgIGZyb20gdGhlIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdH0gZm91bmQgb2JqZWN0LCBvciBgdW5kZWZpbmVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoKXtcbiAgaWYgKH5wYXRoLmluZGV4T2YoJy4nKSkge1xuICAgIHZhciBwYXIgPSBwYXJlbnQob2JqLCBwYXRoKTtcbiAgICB2YXIgbWFpbktleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgICB2YXIgdCA9IHR5cGUocGFyKTtcbiAgICBpZiAoJ29iamVjdCcgPT0gdCB8fCAnYXJyYXknID09IHQpIHJldHVybiBwYXJbbWFpbktleV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9ialtwYXRoXTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBnaXZlbiBgcGF0aGAgdG8gYHZhbGAgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQFBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWwpe1xuICBpZiAofnBhdGguaW5kZXhPZignLicpKSB7XG4gICAgdmFyIHBhciA9IHBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICAgIHZhciBtYWluS2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgIGlmIChwYXIgJiYgJ29iamVjdCcgPT0gdHlwZShwYXIpKSBwYXJbbWFpbktleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgb2JqW3BhdGhdID0gdmFsO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBvYmplY3QgZm9yIGEgZ2l2ZW4ga2V5IChkb3Qgbm90YXRpb24gYXdhcmUpLlxuICpcbiAqIC0gSWYgYSBwYXJlbnQgb2JqZWN0IGRvZXNuJ3QgZXhpc3QsIGl0J3MgaW5pdGlhbGl6ZWQuXG4gKiAtIEFycmF5IGluZGV4IGxvb2t1cCBpcyBzdXBwb3J0ZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlIGlmIGl0IHNob3VsZCBpbml0aWFsaXplIHRoZSBwYXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyZW50ID0gcGFyZW50O1xuXG5mdW5jdGlvbiBwYXJlbnQob2JqLCBrZXksIGluaXQpe1xuICBpZiAofmtleS5pbmRleE9mKCcuJykpIHtcbiAgICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgdmFyIHJldCA9IG9iajtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgLy8gaWYgdGhlIGtleSBpcyBhIG51bWJlciBzdHJpbmcgYW5kIHBhcmVudCBpcyBhbiBhcnJheVxuICAgICAgaWYgKE51bWJlcihwaWVjZXNbaV0pID09IHBpZWNlc1tpXSAmJiAnYXJyYXknID09IHR5cGUocmV0KSkge1xuICAgICAgICByZXQgPSByZXRbcGllY2VzW2ldXTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZShyZXQpKSB7XG4gICAgICAgIGlmIChpbml0ICYmICFyZXQuaGFzT3duUHJvcGVydHkocGllY2VzW2ldKSkge1xuICAgICAgICAgIHJldFtwaWVjZXNbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCkgcmV0ID0gcmV0W3BpZWNlc1tpXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59XG4iLCJcbi8qKlxuICogdG9TdHJpbmcgcmVmLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG4gIHN3aXRjaCAodG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOiByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzogcmV0dXJuICdkYXRlJztcbiAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzogcmV0dXJuICdhcmd1bWVudHMnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzogcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCA9PT0gT2JqZWN0KHZhbCkpIHJldHVybiAnb2JqZWN0JztcblxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBlcWw7XG5cbi8qKlxuICogTW9uZ29EQiBzdHlsZSB2YWx1ZSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hlclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZXkgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBlcWwobWF0Y2hlciwgdmFsKXtcbiAgc3dpdGNoICh0eXBlKG1hdGNoZXIpKSB7XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIC8vIHdlIHRyZWF0IG51bGwgYXMgdW5kZWZpbmVkXG4gICAgICByZXR1cm4gbnVsbCA9PSB2YWw7XG5cbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgcmV0dXJuIG1hdGNoZXIudGVzdCh2YWwpO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKCdhcnJheScgPT0gdHlwZSh2YWwpICYmIG1hdGNoZXIubGVuZ3RoID09IHZhbC5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFlcWwodmFsW2ldLCBtYXRjaGVyW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gb2JqZWN0IGNhbiBtYXRjaCBrZXlzIGluIGFueSBvcmRlclxuICAgICAgdmFyIGtleXMgPSB7fTtcblxuICAgICAgLy8gd2UgbWF0Y2ggYWxsIHZhbHVlcyBvZiBgbWF0Y2hlcmAgaW4gYHZhbGBcbiAgICAgIGZvciAodmFyIGkgaW4gbWF0Y2hlcikge1xuICAgICAgICBpZiAobWF0Y2hlci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGlmICghdmFsLmhhc093blByb3BlcnR5KGkpIHx8ICFlcWwobWF0Y2hlcltpXSwgdmFsW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzW2ldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgbWFrZSBzdXJlIGB2YWxgIGRvZXNuJ3QgaGF2ZSBleHRyYSBrZXlzXG4gICAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5KGkpICYmICFrZXlzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBtYXRjaGVyID09PSB2YWw7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBIT1AgcmVmLlxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFJldHVybiBvd24ga2V5cyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKXtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogUmV0dXJuIG93biB2YWx1ZXMgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24ob2JqKXtcbiAgdmFyIHZhbHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHMucHVzaChvYmpba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuLyoqXG4gKiBNZXJnZSBgYmAgaW50byBgYWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGlmIChoYXMuY2FsbChiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGVuZ3RoIG9mIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5sZW5ndGggPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gZXhwb3J0cy5rZXlzKG9iaikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmlzRW1wdHkgPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gMCA9PSBleHBvcnRzLmxlbmd0aChvYmopO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZXFsID0gcmVxdWlyZSgnbW9uZ28tZXFsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG5cbi8qKlxuICogJG5lOiBub3QgZXF1YWwuXG4gKi9cblxuZXhwb3J0cy4kbmUgPSBmdW5jdGlvbiAkbmUobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuICFlcWwobWF0Y2hlciwgdmFsKTtcbn07XG5cbi8qKlxuICogJGd0OiBncmVhdGVyIHRoYW4uXG4gKi9cblxuZXhwb3J0cy4kZ3QgPSBmdW5jdGlvbiAkZ3QobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA+IG1hdGNoZXI7XG59O1xuXG4vKipcbiAqICRndGU6IGdyZWF0ZXIgdGhhbiBlcXVhbC5cbiAqL1xuXG5leHBvcnRzLiRndGUgPSBmdW5jdGlvbiAkZ3RlKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiB0eXBlKG1hdGNoZXIpID09PSAnbnVtYmVyJyAmJiB2YWwgPj0gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJGx0OiBsZXNzIHRoYW4uXG4gKi9cblxuZXhwb3J0cy4kbHQgPSBmdW5jdGlvbiAkbHQobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA8IG1hdGNoZXI7XG59O1xuXG4vKipcbiAqICRsdGU6IGxlc3MgdGhhbiBlcXVhbC5cbiAqL1xuXG5leHBvcnRzLiRsdGUgPSBmdW5jdGlvbiAkbHRlKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiB0eXBlKG1hdGNoZXIpID09PSAnbnVtYmVyJyAmJiB2YWwgPD0gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJHJlZ2V4OiBzdXBwbHkgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgYSBzdHJpbmcuXG4gKi9cblxuZXhwb3J0cy4kcmVnZXggPSBmdW5jdGlvbiAkcmVnZXgobWF0Y2hlciwgdmFsKXtcbiAgLy8gVE9ETzogYWRkICRvcHRpb25zIHN1cHBvcnRcbiAgaWYgKCdyZWdleHAnICE9IHR5cGUoJ21hdGNoZXInKSkgbWF0Y2hlciA9IG5ldyBSZWdFeHAobWF0Y2hlcik7XG4gIHJldHVybiBtYXRjaGVyLnRlc3QodmFsKTtcbn07XG5cbi8qKlxuICogJGV4aXN0czoga2V5IGV4aXN0cy5cbiAqL1xuXG5leHBvcnRzLiRleGlzdHMgPSBmdW5jdGlvbiAkZXhpc3RzKG1hdGNoZXIsIHZhbCl7XG4gIGlmIChtYXRjaGVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCAhPT0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQgPT09IHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiAkaW46IHZhbHVlIGluIGFycmF5LlxuICovXG5cbmV4cG9ydHMuJGluID0gZnVuY3Rpb24gJGluKG1hdGNoZXIsIHZhbCl7XG4gIGlmICgnYXJyYXknICE9IHR5cGUobWF0Y2hlcikpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGVxbChtYXRjaGVyW2ldLCB2YWwpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqICRuaW46IHZhbHVlIG5vdCBpbiBhcnJheS5cbiAqL1xuXG5leHBvcnRzLiRuaW4gPSBmdW5jdGlvbiAkbmluKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiAhZXhwb3J0cy4kaW4obWF0Y2hlciwgdmFsKTtcbn07XG5cbi8qKlxuICogQHNpemU6IGFycmF5IGxlbmd0aFxuICovXG5cbmV4cG9ydHMuJHNpemUgPSBmdW5jdGlvbihtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpICYmIG1hdGNoZXIgPT0gdmFsLmxlbmd0aDtcbn07XG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2xpYi9jb3JlJykuQ3J5cHRvSlM7XG5yZXF1aXJlKCcuL2xpYi9lbmMtYmFzZTY0Jyk7XG5yZXF1aXJlKCcuL2xpYi9tZDUnKTtcbnJlcXVpcmUoJy4vbGliL2V2cGtkZicpO1xucmVxdWlyZSgnLi9saWIvY2lwaGVyLWNvcmUnKTtcbnJlcXVpcmUoJy4vbGliL2FlcycpO1xudmFyIEpzb25Gb3JtYXR0ZXIgPSByZXF1aXJlKCcuL2xpYi9qc29uZm9ybWF0dGVyJykuSnNvbkZvcm1hdHRlcjtcblxuZXhwb3J0cy5DcnlwdG9KUyA9IENyeXB0b0pTO1xuZXhwb3J0cy5Kc29uRm9ybWF0dGVyID0gSnNvbkZvcm1hdHRlcjsiLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcclxuXHJcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcclxuICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG4gICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XHJcbiAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cclxuICAgIC8vIExvb2t1cCB0YWJsZXNcclxuICAgIHZhciBTQk9YID0gW107XHJcbiAgICB2YXIgSU5WX1NCT1ggPSBbXTtcclxuICAgIHZhciBTVUJfTUlYXzAgPSBbXTtcclxuICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcclxuICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcclxuICAgIHZhciBTVUJfTUlYXzMgPSBbXTtcclxuICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XHJcbiAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xyXG4gICAgdmFyIElOVl9TVUJfTUlYXzIgPSBbXTtcclxuICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXHJcbiAgICAgICAgdmFyIGQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XHJcbiAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdhbGsgR0YoMl44KVxyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgeGkgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XHJcbiAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xyXG4gICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XHJcbiAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcclxuICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cclxuICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcclxuICAgICAgICAgICAgdmFyIHg0ID0gZFt4Ml07XHJcbiAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xyXG4gICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XHJcbiAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcclxuICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcclxuICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcclxuICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xyXG4gICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcclxuICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XHJcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcclxuICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xyXG4gICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxyXG4gICAgICAgICAgICBpZiAoIXgpIHtcclxuICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xyXG4gICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXHJcbiAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxyXG4gICAgICovXHJcbiAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XHJcbiAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XHJcbiAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcclxuICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXHJcbiAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xyXG4gICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxyXG4gICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXHJcbiAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXHJcbiAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3NcclxuICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcclxuICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xyXG4gICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XHJcbiAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcclxuICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xyXG5cclxuICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXHJcbiAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZHNcclxuICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcclxuICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcclxuICAgICAgICAgICAgICAgIHMwID0gdDA7XHJcbiAgICAgICAgICAgICAgICBzMSA9IHQxO1xyXG4gICAgICAgICAgICAgICAgczIgPSB0MjtcclxuICAgICAgICAgICAgICAgIHMzID0gdDM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxyXG4gICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcclxuICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0MjtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGtleVNpemU6IDI1Ni8zMlxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XHJcbiAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XHJcbiAgICAgKi9cclxuICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xyXG59KCkpO1xyXG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcclxuXHJcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqXHJcbiAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5DcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcclxuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XHJcbiAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XHJcbiAgICB2YXIgQ19lbmMgPSBDLmVuYztcclxuICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcclxuICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XHJcbiAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG4gICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XHJcbiAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcclxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXHJcbiAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXHJcbiAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xyXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBBcHBlbmRcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xyXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcclxuICAgICAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcclxuICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxyXG5cclxuICAgICAgICBpdlNpemU6IDEyOC8zMixcclxuXHJcbiAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxyXG5cclxuICAgICAgICBfREVDX1hGT1JNX01PREU6IDIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0oKSlcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXHJcbiAgICAgKi9cclxuICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcclxuICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXHJcbiAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBibG9ja1NpemU6IDFcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW9kZSBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXHJcbiAgICAgKi9cclxuICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENCQyBlbmNyeXB0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XHJcbiAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENCQyBkZWNyeXB0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxyXG4gICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xyXG4gICAgICAgICAgICBpZiAoaXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGl2O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcclxuICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBYT1IgYmxvY2tzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gQ0JDO1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXHJcbiAgICAgKi9cclxuICAgIHZhciBQa2NzNyA9IENfcGFkLlBrY3M3ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xyXG4gICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcclxuICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXHJcbiAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXHJcbiAgICAgKi9cclxuICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcclxuICAgICAgICAgKi9cclxuICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcclxuICAgICAgICAgICAgbW9kZTogQ0JDLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcclxuICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xyXG4gICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XHJcbiAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xyXG4gICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5hbGl6ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxyXG4gICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcclxuICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXHJcbiAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cclxuICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xyXG4gICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcclxuICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxyXG4gICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxyXG4gICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcclxuICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXHJcbiAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcclxuICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcclxuICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcclxuICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcclxuICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xyXG4gICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0IG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XHJcbiAgICAgICAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3JtYXRcclxuICAgICAgICAgICAgaWYgKHNhbHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xyXG4gICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcclxuXHJcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcclxuICAgICAgICAgICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PSAweDY1NjQ1ZjVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNhbHRcclxuICAgICAgICAgICAgICAgIHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxyXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcclxuICAgICAgICAgICAgICAgIGNpcGhlcnRleHQuc2lnQnl0ZXMgLT0gMTY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcclxuICAgICAgICAgKi9cclxuICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuY3J5cHRcclxuICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xyXG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcclxuICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcclxuICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcclxuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxyXG4gICAgICAgICAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcclxuICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcclxuICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVjcnlwdFxyXG4gICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcclxuICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xyXG4gICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XHJcbiAgICAgICAgICAgIGlmICghc2FsdCkge1xyXG4gICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcclxuICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xyXG4gICAgICAgICAgICBrZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcclxuICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXHJcbiAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xyXG4gICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXHJcbiAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XHJcblxyXG4gICAgICAgICAgICAvLyBFbmNyeXB0XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXHJcbiAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xyXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xyXG4gICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xyXG5cclxuICAgICAgICAgICAgLy8gRGVjcnlwdFxyXG4gICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSgpKTtcclxuIiwiLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKipcclxuICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxyXG4gKi9cclxudmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlicmFyeSBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBGKCkge31cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNwYXduXHJcbiAgICAgICAgICAgICAgICBGLnByb3RvdHlwZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IG5ldyBGKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXVnbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxyXG4gICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxyXG4gICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgICAgICAqICAgICAgICAgfVxyXG4gICAgICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcclxuICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xyXG4gICAgICAgICAgICAgKiAgICAgfSk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxyXG4gICAgICovXHJcbiAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xyXG4gICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcclxuICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXHJcbiAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbmNhdFxyXG4gICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0V29yZHMubGVuZ3RoID4gMHhmZmZmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29weSBhbGwgd29yZHMgYXQgb25jZVxyXG4gICAgICAgICAgICAgICAgdGhpc1dvcmRzLnB1c2guYXBwbHkodGhpc1dvcmRzLCB0aGF0V29yZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3JkcztcclxuICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENsYW1wXHJcbiAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XHJcbiAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CeXRlczsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApIHwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0XHJcbiAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXHJcbiAgICAgKi9cclxuICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcclxuICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydFxyXG4gICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydFxyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxyXG4gICAgICovXHJcbiAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xyXG4gICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZFxyXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XHJcbiAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcclxuICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxyXG4gICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XHJcbiAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXHJcbiAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxyXG4gICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcclxuICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxyXG4gICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxyXG4gICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xyXG4gICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxyXG4gICAgICovXHJcbiAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcclxuICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcclxuICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xyXG4gICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBBcHBlbmRcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoYWluYWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXHJcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xyXG4gICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xyXG4gICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XHJcblxyXG4gICAgcmV0dXJuIEM7XHJcbn0oTWF0aCkpO1xyXG5cclxuZXhwb3J0cy5DcnlwdG9KUyA9IENyeXB0b0pTO1xyXG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcblxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIHZhciBDID0gQ3J5cHRvSlM7XG4gICAgdmFyIENfbGliID0gQy5saWI7XG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcbiAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cbiAgICAgKi9cbiAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAgICAgICAqL1xuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcbiAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG4gICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydFxuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICAgICAgICB2YXIgbkJ5dGVzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAlIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdHMxID0gbWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpIC0gMSkpIDw8ICgoaSAlIDQpICogMik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRzMiA9IG1hcC5pbmRleE9mKGJhc2U2NFN0ci5jaGFyQXQoaSkpID4+PiAoNiAtIChpICUgNCkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSAoYml0czEgfCBiaXRzMikgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21hcDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuICAgIH07XG59KCkpO1xuIiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9jb3JlJykuQ3J5cHRvSlM7XHJcblxyXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcclxuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XHJcbiAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG4gICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cclxuICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXHJcbiAgICAgKi9cclxuICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xyXG4gICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXHJcbiAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxyXG4gICAgICAgICAgICBpdGVyYXRpb25zOiAxXHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoKTtcclxuICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XHJcbiAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcclxuICAgICAgICAgICAgdmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcclxuICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcclxuICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcclxuXHJcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxyXG4gICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XHJcbiAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xyXG4gICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcclxuICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XHJcbiAgICAgKi9cclxuICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcclxuICAgICAgICByZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG4gICAgfTtcclxufSgpKTtcclxuIiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9jb3JlJykuQ3J5cHRvSlM7XG5cbi8vIGNyZWF0ZSBjdXN0b20ganNvbiBzZXJpYWxpemF0aW9uIGZvcm1hdFxudmFyIEpzb25Gb3JtYXR0ZXIgPSB7XG5cdHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHRcdC8vIGNyZWF0ZSBqc29uIG9iamVjdCB3aXRoIGNpcGhlcnRleHRcblx0XHR2YXIganNvbk9iaiA9IHtcblx0XHRcdGN0OiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhDcnlwdG9KUy5lbmMuQmFzZTY0KVxuXHRcdH07XG5cdFx0XG5cdFx0Ly8gb3B0aW9uYWxseSBhZGQgaXYgYW5kIHNhbHRcblx0XHRpZiAoY2lwaGVyUGFyYW1zLml2KSB7XG5cdFx0XHRqc29uT2JqLml2ID0gY2lwaGVyUGFyYW1zLml2LnRvU3RyaW5nKCk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjaXBoZXJQYXJhbXMuc2FsdCkge1xuXHRcdFx0anNvbk9iai5zID0gY2lwaGVyUGFyYW1zLnNhbHQudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0XHQvLyBzdHJpbmdpZnkganNvbiBvYmplY3Rcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNvbk9iailcblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKGpzb25TdHIpIHtcblx0XHQvLyBwYXJzZSBqc29uIHN0cmluZ1xuXHRcdHZhciBqc29uT2JqID0gSlNPTi5wYXJzZShqc29uU3RyKTtcblx0XHRcblx0XHQvLyBleHRyYWN0IGNpcGhlcnRleHQgZnJvbSBqc29uIG9iamVjdCwgYW5kIGNyZWF0ZSBjaXBoZXIgcGFyYW1zIG9iamVjdFxuXHRcdHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdFx0XHRjaXBoZXJ0ZXh0OiBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGpzb25PYmouY3QpXG5cdFx0fSk7XG5cdFx0XG5cdFx0Ly8gb3B0aW9uYWxseSBleHRyYWN0IGl2IGFuZCBzYWx0XG5cdFx0aWYgKGpzb25PYmouaXYpIHtcblx0XHRcdGNpcGhlclBhcmFtcy5pdiA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoanNvbk9iai5pdik7XG5cdFx0fVxuICAgICAgICAgICAgXG5cdFx0aWYgKGpzb25PYmoucykge1xuXHRcdFx0Y2lwaGVyUGFyYW1zLnNhbHQgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGpzb25PYmoucyk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBjaXBoZXJQYXJhbXM7XG5cdH1cbn07XG5cbmV4cG9ydHMuSnNvbkZvcm1hdHRlciA9IEpzb25Gb3JtYXR0ZXI7IiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnLi9jb3JlJykuQ3J5cHRvSlM7XHJcblxyXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoTWF0aCkge1xyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG4gICAgdmFyIENfbGliID0gQy5saWI7XHJcbiAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xyXG4gICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcblxyXG4gICAgLy8gQ29uc3RhbnRzIHRhYmxlXHJcbiAgICB2YXIgVCA9IFtdO1xyXG5cclxuICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xyXG4gICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xyXG4gICAgICAgIH1cclxuICAgIH0oKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XHJcbiAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXHJcbiAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxyXG4gICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxyXG4gICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XHJcbiAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzAgID0gTVtvZmZzZXQgKyAwXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEgID0gTVtvZmZzZXQgKyAxXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzMgID0gTVtvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzQgID0gTVtvZmZzZXQgKyA0XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzYgID0gTVtvZmZzZXQgKyA2XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzcgID0gTVtvZmZzZXQgKyA3XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzkgID0gTVtvZmZzZXQgKyA5XTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXHJcbiAgICAgICAgICAgIHZhciBhID0gSFswXTtcclxuICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xyXG4gICAgICAgICAgICB2YXIgYyA9IEhbMl07XHJcbiAgICAgICAgICAgIHZhciBkID0gSFszXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXHJcbiAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xyXG4gICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcclxuICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XHJcbiAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xyXG4gICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcclxuICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XHJcbiAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xyXG4gICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcclxuICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XHJcbiAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xyXG4gICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XHJcbiAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcclxuICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xyXG4gICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XHJcbiAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcclxuICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xyXG5cclxuICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xyXG4gICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgIDksICBUWzE3XSk7XHJcbiAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcclxuICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xyXG4gICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDUsICBUWzIwXSk7XHJcbiAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgIFRbMjFdKTtcclxuICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xyXG4gICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgIDIwLCBUWzIzXSk7XHJcbiAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNSwgIFRbMjRdKTtcclxuICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xyXG4gICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE0LCBUWzI2XSk7XHJcbiAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAgMjAsIFRbMjddKTtcclxuICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xyXG4gICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgIDksICBUWzI5XSk7XHJcbiAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTQsIFRbMzBdKTtcclxuICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xyXG5cclxuICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xyXG4gICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XHJcbiAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcclxuICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xyXG4gICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XHJcbiAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcclxuICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xyXG4gICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XHJcbiAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcclxuICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xyXG4gICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XHJcbiAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcclxuICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xyXG4gICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XHJcbiAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcclxuICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xyXG5cclxuICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xyXG4gICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XHJcbiAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcclxuICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xyXG4gICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XHJcbiAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcclxuICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xyXG4gICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XHJcbiAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcclxuICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xyXG4gICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XHJcbiAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcclxuICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xyXG4gICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XHJcbiAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcclxuICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xyXG5cclxuICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcclxuICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xyXG4gICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XHJcbiAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcclxuICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcclxuICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcclxuICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XHJcblxyXG4gICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XHJcbiAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XHJcbiAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxyXG4gICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxyXG4gICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXHJcbiAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XHJcbiAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcclxuICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xyXG5cclxuICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xyXG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XHJcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICAgICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcclxuICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xyXG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xyXG4gICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XHJcbiAgICAgKi9cclxuICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY01ENShtZXNzYWdlLCBrZXkpO1xyXG4gICAgICovXHJcbiAgICBDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcclxufShNYXRoKSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBDb25zdGFudHMgPSB7fTtcbkNvbnN0YW50cy5EZWZhdWx0VGFrZUl0ZW1zQ291bnQgPSA1MDtcbkNvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSA9ICdFeHBhbmQnO1xuQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lID0gJ1JldHVybkFzJztcbkNvbnN0YW50cy5GaWVsZHNFeHByZXNzaW9uTmFtZSA9ICdGaWVsZHMnO1xuQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWUgPSAnU2luZ2xlRmllbGQnO1xuQ29uc3RhbnRzLlNvcnRFeHByZXNzaW9uTmFtZSA9ICdTb3J0JztcbkNvbnN0YW50cy5GaWx0ZXJFeHByZXNzaW9uTmFtZSA9ICdGaWx0ZXInO1xuQ29uc3RhbnRzLlNraXBFeHByZXNzaW9uTmFtZSA9ICdTa2lwJztcbkNvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWUgPSAnVGFrZSc7XG5Db25zdGFudHMuUGFyZW50UmVsYXRpb25GaWVsZE5hbWUgPSAnUGFyZW50UmVsYXRpb25GaWVsZCc7XG5Db25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQgPSAnSWQnO1xuQ29uc3RhbnRzLlRhcmdldFR5cGVOYW1lRmllbGROYW1lID0gJ1RhcmdldFR5cGVOYW1lJztcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdGFudHM7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gZ2V0IGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBwcm9jZXNzIGEgc2V0IG9mIHJlbGF0aW9ucy5cbiAqIEBwYXJhbSBwYXJlbnQgLSBBbiBFeGVjdXRpb25Ob2RlIGluc3RhbmNlIHVzZWQgdG8gc3VwcGx5IHRoZSB0cmVlIGxpa2UgZGF0YSBzdHJ1Y3R1cmUuXG4gKiBAcGFyYW0gcmVsYXRpb25Ob2RlIC0gVGhlIHJlbGF0aW9uIG5vZGUgdXNlZCB0byBjcmVhdGVkIHRoZSBFeGVjdXRpb25Ob2RlIGluc3RhbmNlIChFeGVjdXRpb25Ob2RlIGluc3RhbmNlIHNob3VsZCBjb250YWluIG9uZSBvciBtYW55IHJlbGF0aW9uc1xuICogaWYgdGhleSBjYW4gYmUgY29tYmluZWQgZm9yIGJhdGNoIGV4ZWN1dGlvbikuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV4ZWN1dGlvbk5vZGUgPSBmdW5jdGlvbiAocGFyZW50LCByZWxhdGlvbk5vZGUpIHtcbiAgICB2YXIgcGFyZW50UGF0aCA9ICcnO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50UGF0aCA9IHBhcmVudC5wYXRoO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFBhdGg7XG4gICAgdGhpcy5yZWxhdGlvbnMgPSBbcmVsYXRpb25Ob2RlLnBhdGhdO1xuICAgIHRoaXMubmFtZSA9IHJlbGF0aW9uTm9kZS5wYXRoO1xuICAgIHRoaXMudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XG4gICAgdGhpcy5jYW5BZGRPdGhlclJlbGF0aW9ucyA9ICFyZWxhdGlvbk5vZGUuZmlsdGVyRXhwcmVzc2lvbiAmJiAhcmVsYXRpb25Ob2RlLnNvcnRFeHByZXNzaW9uICYmICFyZWxhdGlvbk5vZGUudGFrZSAmJiAhcmVsYXRpb25Ob2RlLnNraXA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmVudFBhdGgpIHtcbiAgICAgICAgcGF0aCArPSBwYXJlbnRQYXRoICsgJy4nO1xuICAgIH1cbiAgICBwYXRoICs9IHJlbGF0aW9uTm9kZS50YXJnZXRUeXBlTmFtZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgUmVsYXRpb25Ob2RlIHRvIGFuIEV4ZWN1dGlvbk5vZGUuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIFJlbGF0aW9uIGluc3RhbmNlLlxuICovXG5FeGVjdXRpb25Ob2RlLnByb3RvdHlwZS5pbnNlcnRSZWxhdGlvbk5vZGUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcbiAgICB0aGlzLnJlbGF0aW9ucy5wdXNoKHJlbGF0aW9uLnBhdGgpO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgY2hpbGQgbm9kZSAod2hpY2ggcmVsYXRpb25zKSBkZXBlbmRzIGZyb20gcGFyZW50IG5vZGUgcmVzdWx0LlxuICogQHBhcmFtIGNoaWxkIC0gRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgY2hpbGQgbm9kZS5cbiAqL1xuRXhlY3V0aW9uTm9kZS5wcm90b3R5cGUuaW5zZXJ0Q2hpbGRyZW5Ob2RlID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkLm5hbWUpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRoYXQgY2hlY2tzIGlmIHNvbWUgcmVsYXRpb25zIGNvdWxkIGJlIGNvbWJpbmVkIChmb3IgZXhhbXBsZSBoYXZlIHNhbWUgVGFyZ2V0VHlwZSkuXG4gKiBAcGFyYW0gcmVsYXRpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5FeGVjdXRpb25Ob2RlLnByb3RvdHlwZS5jYW5Db21iaW5lV2l0aFJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmNhbkFkZE90aGVyUmVsYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50YXJnZXRUeXBlTmFtZSA9PT0gcmVsYXRpb24udGFyZ2V0VHlwZU5hbWUgJiYgIXJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gJiYgIXJlbGF0aW9uLnNvcnRFeHByZXNzaW9uICYmICFyZWxhdGlvbi50YWtlICYmICFyZWxhdGlvbi5za2lwO1xufTtcblxuLyoqIEV4ZWN1dGlvblRyZWVcbiAqIENsYXNzIHRoYXQgYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBhbiBleGVjdXRpb24gdHJlZSBmcm9tIGEgcmVsYXRpb25UcmVlLiBVc2VkIHRvIHByb2Nlc3MgYWxsIHF1ZXJpZXMgKG1hc3RlciBhbmQgY2hpbGQpIGluIGEgY29ycmVjdCBvcmRlci5cbiAqIEBwYXJhbSByZWxhdGlvblRyZWUgLSBBbiBpbnN0YW5jZSBvZiByZWxhdGlvbiB0cmVlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFeGVjdXRpb25UcmVlID0gZnVuY3Rpb24gKHJlbGF0aW9uVHJlZSkge1xuICAgIHRoaXMuX3JlbGF0aW9uVHJlZSA9IHJlbGF0aW9uVHJlZTtcbiAgICB0aGlzLl9tYXAgPSB7fTtcbn07XG5cbi8qKlxuICogQWRkcyBleGVjdXRpb24gbm9kZSB0byB0aGUgRXhlY3V0aW9uVHJlZS5cbiAqIEBwYXJhbSBleGVjdXRpb25Ob2RlXG4gKi9cbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmFkZEV4ZWN1dGlvbk5vZGUgPSBmdW5jdGlvbiAoZXhlY3V0aW9uTm9kZSkge1xuICAgIHRoaXMuX21hcFtleGVjdXRpb25Ob2RlLm5hbWVdID0gZXhlY3V0aW9uTm9kZTtcbn07XG5cbi8qKlxuICogRmluZHMgdGhlIEV4ZWN1dGlvbk5vZGUgd2hpY2ggY29udGFpbnMgdGhlIHJlcXVlc3RlZCByZWxhdGlvbi5cbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgUmVsYXRpb24gaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0RXhlY3V0aW9uTm9kZU9mUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcbiAgICBmb3IgKHZhciBleGVjTm9kZSBpbiB0aGlzLl9tYXApIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcC5oYXNPd25Qcm9wZXJ0eShleGVjTm9kZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXBbZXhlY05vZGVdLnJlbGF0aW9ucy5pbmRleE9mKHJlbGF0aW9uKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcFtleGVjTm9kZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEZpbmRzIGEgUmVsYXRpb25Ob2RlIHdpdGhpbiB0aGUgUmVsYXRpb25UcmVlLlxuICogQHBhcmFtIHJlbGF0aW9uIC0gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVsYXRpb24gd2l0aGluIHRoZSBSZWxhdGlvblRyZWUgKGZvciBleGFtcGxlOiBBY3Rpdml0aWVzLkxpa2VzLlJvbGUpLlxuICogQHJldHVybnMgeyp9XG4gKi9cbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldFJlbGF0aW9uTm9kZSA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuICAgIGlmIChyZWxhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRpb25UcmVlW3JlbGF0aW9uXSB8fCBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldFJvb3RSZWxhdGlvbk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbGF0aW9uVHJlZVt0aGlzLl9yZWxhdGlvblRyZWUuJHJvb3RdIHx8IG51bGw7XG59O1xuLyoqXG4gKiBCdWlsZHMgdGhlIEV4ZWN1dGlvblRyZWUgZnJvbSBhIFJlbGF0aW9uVHJlZS5cbiAqL1xuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9idWlsZCBiZWdpbm5pbmcgZnJvbSB0aGUgcm9vdFxuICAgIHZhciByZWxhdGlvblJvb3QgPSB0aGlzLmdldFJlbGF0aW9uTm9kZSh0aGlzLl9yZWxhdGlvblRyZWUuJHJvb3QpO1xuICAgIC8vU2V0dXAgdGhlIHJvb3Qgb2YgdGhlIGV4ZWN1dGlvbiB0cmVlLlxuICAgIHZhciByb290RXhlY3V0aW9uTm9kZSA9IG5ldyBFeGVjdXRpb25Ob2RlKG51bGwsIHJlbGF0aW9uUm9vdCk7Ly9ubyBwYXJlbnQgbm9kZVxuICAgIHRoaXMuYWRkRXhlY3V0aW9uTm9kZShyb290RXhlY3V0aW9uTm9kZSk7XG4gICAgdGhpcy5idWlsZEludGVybmFsKHJlbGF0aW9uUm9vdCk7XG59O1xuXG4vKipcbiAqIFRyYXZlcnNlIHRoZSByZWxhdGlvbiB0cmVlIGFuZCBidWlsZCB0aGUgZXhlY3V0aW9uIHRyZWUuXG4gKiBAcGFyYW0gcmVsYXRpb25Sb290IC0gVGhlIHJvb3Qgbm9kZSBvZiB0aGUgUmVsYXRpb25UcmVlLlxuICovXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5idWlsZEludGVybmFsID0gZnVuY3Rpb24gKHJlbGF0aW9uUm9vdCkge1xuICAgIHJlbGF0aW9uUm9vdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRSZWxhdGlvbk5vZGUgPSB0aGlzLmdldFJlbGF0aW9uTm9kZShjaGlsZCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0UmVsYXRpb25Ob2RlSW5FeGVjdXRpb25UcmVlKGNoaWxkUmVsYXRpb25Ob2RlKTtcbiAgICAgICAgdGhpcy5idWlsZEludGVybmFsKGNoaWxkUmVsYXRpb25Ob2RlKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIHJlbGF0aW9uIG5vZGUgd2l0aGluIHRoZSBleGVjdXRpb24gdHJlZSAoYmFzZWQgb24gaXRzIGRlcGVuZGVuY2llcykuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGluc2VydGVkLlxuICovXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5pbnNlcnRSZWxhdGlvbk5vZGVJbkV4ZWN1dGlvblRyZWUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcbiAgICB2YXIgcm9vdEV4ZWN1dGlvbk5vZGUgPSB0aGlzLmdldEV4ZWN1dGlvbk5vZGVPZlJlbGF0aW9uKHJlbGF0aW9uLnBhcmVudCk7XG4gICAgdmFyIGNoaWxkVG9Db21iaW5lID0gdGhpcy50cnlHZXRDaGlsZE5vZGVUb0NvbWJpbmUocm9vdEV4ZWN1dGlvbk5vZGUsIHJlbGF0aW9uKTtcbiAgICBpZiAoY2hpbGRUb0NvbWJpbmUpIHsvL2lmIHRoZXJlIGlzIGEgY2hpbGQgdGhhdCB3ZSBjb21iaW5lIHRoZSByZWxhdGlvblxuICAgICAgICBjaGlsZFRvQ29tYmluZS5pbnNlcnRSZWxhdGlvbk5vZGUocmVsYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdFeGVjdXRpb25Ob2RlID0gbmV3IEV4ZWN1dGlvbk5vZGUocm9vdEV4ZWN1dGlvbk5vZGUsIHJlbGF0aW9uKTsvL2NyZWF0ZSBhIHNlcGFyYXRlIGV4ZWN1dGlvbiBub2RlIHRoYXQgd2lsbCBob3N0IHRoZSByZWxhdGlvblxuICAgICAgICByb290RXhlY3V0aW9uTm9kZS5pbnNlcnRDaGlsZHJlbk5vZGUobmV3RXhlY3V0aW9uTm9kZSk7XG4gICAgICAgIHRoaXMuYWRkRXhlY3V0aW9uTm9kZShuZXdFeGVjdXRpb25Ob2RlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyaWVzIHRvIGZpbmQgYW4gRXhlY3V0aW9uTm9kZSB3aGljaCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIGEgcmVsYXRpb24uXG4gKiBAcGFyYW0gcm9vdEV4ZWN1dGlvbk5vZGUgLSBUaGUgcm9vdCBub2RlIG9mIHRoZSBFeGVjdXRpb25UcmVlLlxuICogQHBhcmFtIHJlbGF0aW9uIC0gUmVsYXRpb24gdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBFeGVjdXRpb25UcmVlLlxuICogQHJldHVybnMgeyp9XG4gKi9cbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLnRyeUdldENoaWxkTm9kZVRvQ29tYmluZSA9IGZ1bmN0aW9uIChyb290RXhlY3V0aW9uTm9kZSwgcmVsYXRpb24pIHtcbiAgICBpZiAocm9vdEV4ZWN1dGlvbk5vZGUuY2FuQ29tYmluZVdpdGhSZWxhdGlvbihyZWxhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RFeGVjdXRpb25Ob2RlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRyZW4gPSByb290RXhlY3V0aW9uTm9kZS5jaGlsZHJlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX21hcFtjaGlsZHJlbltpXV07XG4gICAgICAgIHZhciBjaGlsZFRvQ29tYmluZSA9IHRoaXMudHJ5R2V0Q2hpbGROb2RlVG9Db21iaW5lKGNoaWxkLCByZWxhdGlvbik7XG4gICAgICAgIGlmIChjaGlsZFRvQ29tYmluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkVG9Db21iaW5lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBmcm9tIGFsbCByZWxhdGlvbnMgaW5zaWRlIGFuIEV4ZWN1dGlvbk5vZGUuXG4gKiBAcGFyYW0gZXhlY3V0aW9uTm9kZSAtIFRoZSBFeGVjdXRpb25Ob2RlIGluc3RhbmNlLlxuICogQHJldHVybnMge3t9fVxuICovXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRGaWx0ZXJGcm9tRXhlY3V0aW9uTm9kZSA9IGZ1bmN0aW9uIChleGVjdXRpb25Ob2RlLCBpbmNsdWRlQXJyYXlzKSB7XG4gICAgdmFyIGZpbHRlciA9IHt9O1xuICAgIHZhciBzdWJSZWxhdGlvbnNGaWx0ZXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4ZWN1dGlvbk5vZGUucmVsYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbm5lckZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyRnJvbVNpbmdsZVJlbGF0aW9uKHRoaXMuX3JlbGF0aW9uVHJlZVtleGVjdXRpb25Ob2RlLnJlbGF0aW9uc1tpXV0sIGluY2x1ZGVBcnJheXMpO1xuICAgICAgICBpZiAoaW5uZXJGaWx0ZXIpIHtcbiAgICAgICAgICAgIHN1YlJlbGF0aW9uc0ZpbHRlci5wdXNoKGlubmVyRmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdWJSZWxhdGlvbnNGaWx0ZXIubGVuZ3RoID4gMSkge1xuICAgICAgICBmaWx0ZXIuJG9yID0gc3ViUmVsYXRpb25zRmlsdGVyO1xuICAgIH0gZWxzZSBpZiAoc3ViUmVsYXRpb25zRmlsdGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmlsdGVyID0gc3ViUmVsYXRpb25zRmlsdGVyWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG59O1xuXG4vKipcbiAqIEdldHMgZmlsdGVyIGV4cHJlc3Npb24gZnJvbSBhIHNpbmdsZSByZWxhdGlvbi4gVHJhdmVyc2UgdGhlIHJlbGF0aW9uIHRyZWUgaW4gb3JkZXIgdG8gZ2V0IHRoZSBcIklkXCJzIGZyb20gdGhlIHJlc3VsdCBvZiBwYXJlbnQgcmVsYXRpb25cbiAqIGFsb25nIHdpdGggdXNlciBkZWZpbmVkIGZpbHRlcnMuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIFJlbGF0aW9uIGluc3RhbmNlLlxuICogQHJldHVybnMgeyp9XG4gKi9cbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldEZpbHRlckZyb21TaW5nbGVSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbiwgaW5jbHVkZUFycmF5cykge1xuICAgIHZhciB1c2VyRGVmaW5lZEZpbHRlciA9IHJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb247XG4gICAgdmFyIHBhcmVudFJlbGF0aW9uRmlsdGVyID0ge307XG4gICAgdmFyIHBhcmVudFJlbGF0aW9uSWRzID0gdGhpcy5nZXRSZWxhdGlvbkZpZWxkVmFsdWVzKHJlbGF0aW9uLCBpbmNsdWRlQXJyYXlzKTtcbiAgICB2YXIgcGFyZW50UmVsYXRpb25GaWVsZE5hbWUgPSAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uID8gcmVsYXRpb24ucmVsYXRpb25GaWVsZCA6IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCk7XG5cbiAgICBpZiAocGFyZW50UmVsYXRpb25JZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJlbnRSZWxhdGlvbkZpbHRlcltwYXJlbnRSZWxhdGlvbkZpZWxkTmFtZV0gPSB7JyRpbic6IHBhcmVudFJlbGF0aW9uSWRzfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodXNlckRlZmluZWRGaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgICAgICBmaWx0ZXJzLnB1c2gocGFyZW50UmVsYXRpb25GaWx0ZXIpO1xuICAgICAgICBmaWx0ZXJzLnB1c2godXNlckRlZmluZWRGaWx0ZXIpO1xuICAgICAgICByZXR1cm4geyckYW5kJzogZmlsdGVyc307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFJlbGF0aW9uRmlsdGVyO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHJlbGF0aW9uIGZpZWxkIHZhbHVlcyBvZiBwYXJlbnQgcmVsYXRpb24gaW4gb3JkZXIgdG8gY29uc3RydWN0IGEgcHJvcGVyIGZpbHRlciAodG8gY3JlYXRlIGEgcmVsYXRpb24pLlxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSByZWxhdGlvbiBpbnN0YW5jZSB3aGljaCB3aWxsIGdldCB0aGUgZmlsdGVyLlxuICogQHBhcmFtIGluY2x1ZGVBcnJheXMgLSBXaGV0aGVyIHRvIGluY2x1ZGUgYXJyYXkgdmFsdXMgb2YgdGhlIHBhcmVudCBpdGVtcyB3aGVuIGNhbGN1bGF0aW5nIHRoZSBpdGVtcyB0aGF0IHdpbGwgYmUgZXhwYW5kZWQgb24gdGhlIGN1cnJlbnQgbGV2ZWwuXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgcmVsYXRpb24gZmllbGQgdmFsdWVzLlxuICovXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRSZWxhdGlvbkZpZWxkVmFsdWVzID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBpbmNsdWRlQXJyYXlzKSB7XG4gICAgdmFyIHBhcmVudFJlbGF0aW9uSWRzID0gW107XG4gICAgdmFyIHBhcmVudFJlbGF0aW9uID0gdGhpcy5fcmVsYXRpb25UcmVlW3JlbGF0aW9uLnBhcmVudF07XG4gICAgLy8gcGFyZW50UmVsYXRpb25SZXN1bHQgYWN0dWFsbHkgaXMgYW4gQWN0aXZpdHkgb3IgQXJyYXkgb2YgQWN0aXZpdGllc1xuICAgIHZhciBwYXJlbnRSZWxhdGlvblJlc3VsdCA9IEFycmF5LmlzQXJyYXkocGFyZW50UmVsYXRpb24ucmVzdWx0KSA/IHBhcmVudFJlbGF0aW9uLnJlc3VsdCA6IFtwYXJlbnRSZWxhdGlvbi5yZXN1bHRdO1xuICAgIGlmIChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYXJlbnRSZWxhdGlvblJlc3VsdC5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgcGFyZW50UmVsYXRpb25JZHMucHVzaChwYXJlbnRSZWxhdGlvblJlc3VsdFtwXVtyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbkZpZWxkXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbGwgY29tbWVudHMgYXJlIHJlbGF0ZWQgdG8gZXhwYW5kIG9mIHR5cGUgY29udGVudCB0eXBlIEFjdGl2aXRpZXMgZXhwYW5kOiB7XCJMaWtlc1wiOiB0cnVlfVxuICAgICAgICBpZiAocGFyZW50UmVsYXRpb24gJiYgcGFyZW50UmVsYXRpb24ucmVzdWx0KSB7XG4gICAgICAgICAgICByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcyA9IHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzIHx8IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWxhdGlvblJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGl0ZW1Gcm9tUGFyZW50UmVsYXRpb24gaXMgc2luZ2xlIEFjdGl2aXR5XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Gcm9tUGFyZW50UmVsYXRpb24gPSBwYXJlbnRSZWxhdGlvblJlc3VsdFtpXTtcblxuICAgICAgICAgICAgICAgIC8vIHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSBpcyBBY3Rpdml0eS5MaWtlc1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUgPSBpdGVtRnJvbVBhcmVudFJlbGF0aW9uW3JlbGF0aW9uLnJlbGF0aW9uRmllbGRdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb24uaGFzQXJyYXlWYWx1ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUFycmF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtVG9FeHBhbmRJZCBpcyBjdXJyZW50IHZhbHVlIGluIEFjdGl2aXR5Lkxpa2VzIGFycmF5IG9yIGp1c3QgYSBzaW5nbGUgXCJJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ub0V4cGFuZElkID0gcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW1Ub0V4cGFuZElkICE9PSB1bmRlZmluZWQgJiYgaXRlbVRvRXhwYW5kSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVsYXRpb25JZHMucHVzaChpdGVtVG9FeHBhbmRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNldCBhbnkgdmFsdWUganVzdCB0byBjcmVhdGUgYSBtYXAgb2YgSWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzW2l0ZW1Ub0V4cGFuZElkXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocGFyZW50UmVsYXRpb25GaWVsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbklkcy5wdXNoKHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkc1twYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWVdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnRSZWxhdGlvbklkcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uVHJlZTtcbiIsIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIEV4cGFuZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSAnRXhwYW5kRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5FeHBhbmRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IEV4cGFuZEVycm9yOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgUmVsYXRpb25UcmVlQnVpbGRlciA9IHJlcXVpcmUoJy4vUmVsYXRpb25UcmVlQnVpbGRlcicpO1xudmFyIEV4ZWN1dGlvblRyZWUgPSByZXF1aXJlKCcuL0V4ZWN1dGlvblRyZWUnKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xudmFyIEV4cGFuZEVycm9yID0gcmVxdWlyZSgnLi9FeHBhbmRFcnJvcicpO1xuXG5mdW5jdGlvbiBQcm9jZXNzb3Iob3B0aW9ucykge1xuICAgIHRoaXMuX2V4ZWN1dGlvbk5vZGVGdW5jdGlvbiA9IG9wdGlvbnMuZXhlY3V0aW9uTm9kZUZ1bmN0aW9uO1xuICAgIHRoaXMuX21ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiA9IG9wdGlvbnMubWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uO1xufVxuXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9nZXRFeGVjdXRpb25UcmVlUm9vdCA9IGZ1bmN0aW9uIChleGVjdXRpb25UcmVlKSB7XG4gICAgdmFyIGV4ZWN1dGlvblRyZWVSb290ID0gbnVsbDtcbiAgICBmb3IgKHZhciBleE5vZGUgaW4gZXhlY3V0aW9uVHJlZSkge1xuICAgICAgICBpZiAoZXhlY3V0aW9uVHJlZS5oYXNPd25Qcm9wZXJ0eShleE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoZXhlY3V0aW9uVHJlZVtleE5vZGVdLnBhcmVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb25UcmVlUm9vdCA9IGV4ZWN1dGlvblRyZWVbZXhOb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhlY3V0aW9uVHJlZVJvb3Q7XG59O1xuXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9jcmVhdGVFeGVjdXRlTm9kZUV4ZWN1dG9yID0gZnVuY3Rpb24gKHJlbGF0aW9uc1RyZWUsIGV4ZWN1dGlvblRyZWUsIGV4ZWN1dGlvbk5vZGUsIGV4cGFuZENvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlbGF0aW9uc1RyZWVNYXAgPSByZWxhdGlvbnNUcmVlLm1hcDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IGV4ZWN1dGlvblRyZWUuZ2V0UmVsYXRpb25Ob2RlKGV4ZWN1dGlvbk5vZGUucmVsYXRpb25zWzBdKTsvL2dldCB0aGUgcmVsYXRpb24gbm9kZSBmb3IgdGhlIG9ubHkgcmVsYXRpb24gb2YgdGhlIGV4ZWN1dGlvbiBub2RlLlxuICAgICAgICB2YXIgcGFyZW50UmVsYXRpb25Ob2RlID0gZXhlY3V0aW9uVHJlZS5nZXRSZWxhdGlvbk5vZGUocmVsYXRpb25Ob2RlLnBhcmVudCk7XG4gICAgICAgIHZhciBpbmNsdWRlQXJyYXlzID0gIShwYXJlbnRSZWxhdGlvbk5vZGUucGFyZW50ICYmIHBhcmVudFJlbGF0aW9uTm9kZS5oYXNBcnJheVZhbHVlcyk7IC8vb25seSBleHBhbmQgYXJyYXkgZmllbGRzIGlmIHRoZSBwYXJlbnQgcmVsYXRpb24gaXMgbm90IGFuIGFycmF5LiBUaGlzIG1lYW5zIHRoYXQgaWYgd2UgaGF2ZSBleHBhbmRlZCBhIExpa2VzIChtdWx0aXBsZSB0byBVc2VycyksIHdlIHdvbid0IGV4cGFuZCBhbnkgYXJyYXkgcmVsYXRpb25zIHRoYXQgYXJlIG5lc3RlZCBpbiBpdCBzdWNoIGFzIHRoZSBVc2VyQ29tbWVudHMgKG11bHRpcGxlIHJlbGF0aW9uIHRvIENvbW1lbnRzKS5cbiAgICAgICAgdmFyIGZpbHRlciA9IGV4ZWN1dGlvblRyZWUuZ2V0RmlsdGVyRnJvbUV4ZWN1dGlvbk5vZGUoZXhlY3V0aW9uTm9kZSwgaW5jbHVkZUFycmF5cyk7XG5cbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IHJlbGF0aW9uc1RyZWUudmFsaWRhdGVTaW5nbGVSZWxhdGlvbihyZWxhdGlvbk5vZGUpO1xuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShuZXcgRXhwYW5kRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHN1Y2ggb3B0aW9ucyBleGVjdXRpb25Ob2RlIHNob3VsZCBoYXZlIG9ubHkgb25lIHJlbGF0aW9uLlxuICAgICAgICB2YXIgbm9kZSA9IHt9O1xuICAgICAgICBub2RlLnNlbGVjdCA9IHJlbGF0aW9uTm9kZS5maWVsZHNFeHByZXNzaW9uO1xuICAgICAgICBub2RlLnNvcnQgPSByZWxhdGlvbk5vZGUuc29ydEV4cHJlc3Npb247XG4gICAgICAgIG5vZGUuc2tpcCA9IHJlbGF0aW9uTm9kZS5za2lwO1xuICAgICAgICBub2RlLnRha2UgPSByZWxhdGlvbk5vZGUudGFrZTtcbiAgICAgICAgbm9kZS5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIG5vZGUudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XG5cbiAgICAgICAgc2VsZi5fZXhlY3V0aW9uTm9kZUZ1bmN0aW9uLmNhbGwobnVsbCwgbm9kZSwgZXhwYW5kQ29udGV4dCwgZnVuY3Rpb24gb25Qcm9jZXNzRXhlY3V0aW9uTm9kZShlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSZWxhdGlvbiA9IHJlbGF0aW9uc1RyZWVNYXBbZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnNbaV1dO1xuICAgICAgICAgICAgICAgIGNoaWxkUmVsYXRpb24ucmVzdWx0ID0gc2VsZi5fZXh0cmFjdFJlc3VsdEZvclJlbGF0aW9uKHJlbGF0aW9uc1RyZWVNYXBbZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnNbaV1dLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0aW9uTm9kZS5yZXN1bHQgPSBjaGlsZFJlbGF0aW9uLnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXhlY3V0aW9uTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBleGVjdXRpb25UcmVlTWFwID0gZXhlY3V0aW9uVHJlZS5fbWFwO1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKHNlbGYuX2NyZWF0ZUV4ZWN1dGVOb2RlRXhlY3V0b3IocmVsYXRpb25zVHJlZSwgZXhlY3V0aW9uVHJlZSwgZXhlY3V0aW9uVHJlZU1hcFtleGVjdXRpb25Ob2RlLmNoaWxkcmVuW2pdXSwgZXhwYW5kQ29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMucGFyYWxsZWwoYXJyLCBkb25lKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cblByb2Nlc3Nvci5wcm90b3R5cGUuX2dldFNpbmdsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCByZWxhdGlvbiwgc2luZ2xlT2JqZWN0KSB7XG4gICAgaWYgKCFzaW5nbGVPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkUmVsYXRpb247XG4gICAgdmFyIGNoaWxkSXRlbTtcblxuICAgIC8vIGlmIHJlbGF0aW9uIGhhcyBzaW5nbGVGaWVsZE5hbWUgb3B0aW9uIHdlIGp1c3QgcmVwbGFjZSB0aGUgcGFyZW50IGlkIHdpdGggYSBzaW5nbGUgdmFsdWVcbiAgICBpZiAocmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XG4gICAgICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbiAmJiByZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjaGlsZFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZVtyZWxhdGlvbi5jaGlsZHJlblswXV07XG4gICAgICAgICAgICBjaGlsZEl0ZW0gPSB0aGlzLl9nZXRPYmplY3RCeUlkRnJvbUFycmF5KGNoaWxkUmVsYXRpb24ucmVzdWx0LCBzaW5nbGVPYmplY3RbcmVsYXRpb24uc2luZ2xlRmllbGROYW1lXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbmdsZU9iamVjdFtyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWVdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgcGFzc2VkUHJvcGVydGllcyA9IHt9O1xuXG4gICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuICYmIHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWxhdGlvbi5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY2hpbGRSZWxhdGlvbiA9IHJlbGF0aW9uc1RyZWVbcmVsYXRpb24uY2hpbGRyZW5bal1dO1xuICAgICAgICAgICAgdmFyIGNoaWxkUmVsYXRpb25GaWVsZCA9IGNoaWxkUmVsYXRpb24ucmVsYXRpb25GaWVsZDtcbiAgICAgICAgICAgIHZhciB1c2VyRGVmaW5lZFJlbE5hbWUgPSBjaGlsZFJlbGF0aW9uLnVzZXJEZWZpbmVkTmFtZTtcbiAgICAgICAgICAgIGlmICghY2hpbGRSZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXNzZWRQcm9wZXJ0aWVzW2NoaWxkUmVsYXRpb25GaWVsZF0gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5uZXJSZWxhdGlvblJlc3VsdCA9IGNoaWxkUmVsYXRpb24ucmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRSZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGlubmVyUmVsYXRpb25SZXN1bHQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheShyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBpbm5lclJlbGF0aW9uUmVzdWx0W2tdLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSA9IGNoaWxkUmVsYXRpb24uaXNBcnJheSgpID8gW10gOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkUmVsYXRpb24uc29ydEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNvcnRpbmcgd2UgcmVwbGFjZSBpdGVtcyB1c2luZyBvcmRlciBvZiB0aGUgcXVlcnkgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBpbm5lclJlbGF0aW9uUmVzdWx0Lmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXS5pbmRleE9mKGlubmVyUmVsYXRpb25SZXN1bHRbcF0uSWQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IGlubmVyUmVsYXRpb25SZXN1bHRbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTaW5nbGVSZXN1bHRUb1BhcmVudEFycmF5KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IHJlcGxhY2UgaXRlbXMgZ2V0dGluZyB0aGVtIGJ5IGlkIHdoaWNoIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkoaW5uZXJSZWxhdGlvblJlc3VsdCwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF1baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTaW5nbGVSZXN1bHRUb1BhcmVudEFycmF5KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkoaW5uZXJSZWxhdGlvblJlc3VsdCwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0gPSB0aGlzLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBhbGwgb3RoZXIgZmllbGRzIHRvIHRoZSByZXN1bHQgKGV4Y2VwdCB0aGUgcmVsYXRpb24gZmllbGRzIHdoaWNoIHdlIGhhdmUgYWxyZWFkeSByZXBsYWNlZCkuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzaW5nbGVPYmplY3QpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5U2hvdWxkQmVBZGRlZFRvUmVzdWx0ID0gc2luZ2xlT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApICYmICFwYXNzZWRQcm9wZXJ0aWVzW3Byb3BdICYmXG4gICAgICAgICAgICB0aGlzLl9maWVsZEV4aXN0SW5GaWVsZHNFeHByZXNzaW9uKHByb3AsIHJlbGF0aW9uLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChwcm9wZXJ0eVNob3VsZEJlQWRkZWRUb1Jlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc2luZ2xlT2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblByb2Nlc3Nvci5wcm90b3R5cGUuX2FkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSkge1xuICAgIHZhciBzaW5nbGVSZXN1bHQgPSB0aGlzLl9nZXRTaW5nbGVSZXN1bHQocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtKTtcbiAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSA9IHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdIHx8IFtdO1xuICAgIGlmIChzaW5nbGVSZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0ucHVzaChzaW5nbGVSZXN1bHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZmllbGQgd2lsbCBiZSByZXR1cm5lZCB2aWEgZ2l2ZW4gZmllbGRzIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gZmllbGQgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQuXG4gKiBAcGFyYW0gZmllbGRzRXhwcmVzc2lvbiAtIFRoZSBGaWVsZHMgZXhwcmVzc2lvbiB3aGljaCBpcyBjaGVja2VkLlxuICogQHJldHVybnMgeyp9XG4gKi9cblByb2Nlc3Nvci5wcm90b3R5cGUuX2ZpZWxkRXhpc3RJbkZpZWxkc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoZmllbGQsIGZpZWxkc0V4cHJlc3Npb24pIHtcbiAgICBpZiAoZmllbGRzRXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKGZpZWxkc0V4cHJlc3Npb24pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGQgPT09IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCkge1xuICAgICAgICBpZiAoZmllbGRzRXhwcmVzc2lvbltmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkc0V4cHJlc3Npb25bZmllbGRdO1xuICAgIH1cblxuICAgIHZhciBpc0V4Y2x1c2l2ZSA9IFJlbGF0aW9uVHJlZUJ1aWxkZXIuZ2V0SXNGaWVsZHNFeHByZXNzaW9uRXhjbHVzaXZlKGZpZWxkc0V4cHJlc3Npb24pO1xuXG4gICAgaWYgKGlzRXhjbHVzaXZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XG4gICAgICAgIHJldHVybiAhZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkc0V4cHJlc3Npb24uaGFzT3duUHJvcGVydHkoZmllbGQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIHJlc3VsdCBmb3IgYSBzaW5nbGUgcmVsYXRpb24gKGluIGNhc2VzIHdoZW4gRXhlY3V0aW9uTm9kZSBjb250YWlucyBtb3JlIHRoYW4gb25lIHJlbGF0aW9ucykuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgcmVsYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHF1ZXJ5UmVzdWx0IC0gUmVzdWx0IG9mIHRoZSBjb21iaW5lZCBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuUHJvY2Vzc29yLnByb3RvdHlwZS5fZXh0cmFjdFJlc3VsdEZvclJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBxdWVyeVJlc3VsdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5UmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcykge1xuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzLmhhc093blByb3BlcnR5KHF1ZXJ5UmVzdWx0W2ldLklkKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHF1ZXJ5UmVzdWx0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChxdWVyeVJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBvYmplY3Qgd2l0aCBhIGdpdmVuIElkIGZyb20gQXJyYXkuXG4gKiBAcGFyYW0gYXJyYXlcbiAqIEBwYXJhbSBpZFxuICogQHJldHVybnMgeyp9XG4gKi9cblByb2Nlc3Nvci5wcm90b3R5cGUuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGlkKSB7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheVtpXS5JZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uXG4gKiBAcGFyYW0gbWFpblR5cGVOYW1lXG4gKiBAcGFyYW0gaXNBcnJheVxuICogQHBhcmFtIGZpZWxkc0V4cHJlc3Npb25cbiAqIEBwYXJhbSBtYXhUYWtlVmFsdWVcbiAqIEBwYXJhbSBwcmVwYXJlQ29udGV4dFxuICogQHBhcmFtIGRvbmVcbiAqL1xuUHJvY2Vzc29yLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24sIG1haW5UeXBlTmFtZSwgaXNBcnJheSwgZmllbGRzRXhwcmVzc2lvbiwgbWF4VGFrZVZhbHVlLCBwcmVwYXJlQ29udGV4dCwgZG9uZSkge1xuICAgIHZhciBydGIgPSBuZXcgUmVsYXRpb25UcmVlQnVpbGRlcihleHBhbmRFeHByZXNzaW9uLCBtYWluVHlwZU5hbWUsIGlzQXJyYXksIGZpZWxkc0V4cHJlc3Npb24sIG1heFRha2VWYWx1ZSwgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uLCBwcmVwYXJlQ29udGV4dCk7XG4gICAgcnRiLmJ1aWxkKGZ1bmN0aW9uIChlcnIsIG1hcCkge1xuICAgICAgICB2YXIgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbiA9IG1hcFttYXAuJHJvb3RdLmZpZWxkc0V4cHJlc3Npb247XG4gICAgICAgICAgICB2YXIgcHJlcGFyZVJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNUcmVlOiBydGIsXG4gICAgICAgICAgICAgICAgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbjogbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbmUoZXJyLCBwcmVwYXJlUmVzdWx0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHJlbGF0aW9uc1RyZWVcbiAqIEBwYXJhbSBtYWluUXVlcnlSZXN1bHRcbiAqIEBwYXJhbSBleHBhbmRDb250ZXh0XG4gKiBAcGFyYW0gZG9uZVxuICovXG5Qcm9jZXNzb3IucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChyZWxhdGlvbnNUcmVlLCBtYWluUXVlcnlSZXN1bHQsIGV4cGFuZENvbnRleHQsIGRvbmUpIHtcbiAgICB2YXIgcmVsYXRpb25zVHJlZU1hcCA9IHJlbGF0aW9uc1RyZWUubWFwO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZXhlY3V0aW9uVHJlZSA9IG5ldyBFeGVjdXRpb25UcmVlKHJlbGF0aW9uc1RyZWVNYXApO1xuICAgIGV4ZWN1dGlvblRyZWUuYnVpbGQoKTtcbiAgICByZWxhdGlvbnNUcmVlTWFwW3JlbGF0aW9uc1RyZWVNYXAuJHJvb3RdLnJlc3VsdCA9IG1haW5RdWVyeVJlc3VsdDtcbiAgICB2YXIgZXhlY3V0aW9uVHJlZU1hcCA9IGV4ZWN1dGlvblRyZWUuX21hcDtcblxuICAgIHZhciBleGVjdXRpb25UcmVlUm9vdCA9IHRoaXMuX2dldEV4ZWN1dGlvblRyZWVSb290KGV4ZWN1dGlvblRyZWVNYXApO1xuXG4gICAgdmFyIG1heFF1ZXJpZXNDb3VudCA9IDIwO1xuICAgIGlmIChPYmplY3Qua2V5cyhleGVjdXRpb25UcmVlTWFwKS5sZW5ndGggPiBtYXhRdWVyaWVzQ291bnQpIHtcbiAgICAgICAgZG9uZShuZXcgRXhwYW5kRXJyb3IoJ0V4cGFuZCBleHByZXNzaW9uIHJlc3VsdHMgaW4gbW9yZSB0aGFuICcgKyBtYXhRdWVyaWVzQ291bnQgKyAnIGlubmVyIHF1ZXJpZXMhJykpO1xuICAgIH1cblxuICAgIGlmIChleGVjdXRpb25UcmVlUm9vdCkge1xuICAgICAgICB2YXIgZXhlY0Z1bmNzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhlY3V0aW9uVHJlZVJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4ZWNGdW5jcy5wdXNoKHRoaXMuX2NyZWF0ZUV4ZWN1dGVOb2RlRXhlY3V0b3IocmVsYXRpb25zVHJlZSwgZXhlY3V0aW9uVHJlZSwgZXhlY3V0aW9uVHJlZU1hcFtleGVjdXRpb25UcmVlUm9vdC5jaGlsZHJlbltpXV0sIGV4cGFuZENvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleGVjRnVuY3MgYXJlIGZ1bmN0aW9ucyBjcmVhdGVkIGZvciBldmVyeSBzaW5nbGUgZXhlY3V0aW9uIG5vdGVcbiAgICAgICAgLy8gd2UgZXhlY3V0ZSB0aGVtIGluIGFzeW5jLCBzaW5jZSB0aGUgcmVzdWx0IG9mIHRoZSBwYXJlbnQgcmVsYXRpb24gaXMgdXNlZCB0byBnZXQgY29ycmVjdCBmaWx0ZXIuXG4gICAgICAgIGFzeW5jLnNlcmllcyhleGVjRnVuY3MsIGZ1bmN0aW9uIG9uUHJvY2Vzc0V4ZWN1dGlvblRyZWUoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0O1xuICAgICAgICAgICAgICAgIHZhciByb290UmVsYXRpb24gPSByZWxhdGlvbnNUcmVlTWFwW3JlbGF0aW9uc1RyZWVNYXAuJHJvb3RdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1haW5RdWVyeVJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFpblF1ZXJ5UmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUmVzdWx0ID0gc2VsZi5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWVNYXAsIHJvb3RSZWxhdGlvbiwgbWFpblF1ZXJ5UmVzdWx0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzaW5nbGVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gc2VsZi5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWVNYXAsIHJvb3RSZWxhdGlvbiwgbWFpblF1ZXJ5UmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCBvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5Qcm9jZXNzb3IuQ29uc3RhbnRzID0gQ29uc3RhbnRzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgRXhwYW5kRXJyb3IgPSByZXF1aXJlKCcuL0V4cGFuZEVycm9yJyk7XG5cbmZ1bmN0aW9uIFJlbGF0aW9uTm9kZShvcHRpb25zKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLnJlbGF0aW9uRmllbGQgPSBvcHRpb25zLnJlbGF0aW9uRmllbGQ7XG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8IG9wdGlvbnMucGFyZW50ICsgJy4nICsgb3B0aW9ucy5yZWxhdGlvbkZpZWxkO1xuICAgIHRoaXMuZmllbGRzRXhwcmVzc2lvbiA9IG9wdGlvbnMuZmllbGRzRXhwcmVzc2lvbiB8fCB7fTtcbiAgICB0aGlzLnRhcmdldFR5cGVOYW1lID0gb3B0aW9ucy50YXJnZXRUeXBlTmFtZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5pc0ludmVydGVkUmVsYXRpb24gPSBvcHRpb25zLmlzSW52ZXJ0ZWRSZWxhdGlvbjtcbiAgICB0aGlzLmlzQXJyYXlSb290ID0gb3B0aW9ucy5pc0FycmF5Um9vdDsgLy91c2VkIGZvciB2YWxpZGF0aW9uIG9mIGNhc2VzIHdoZXJlIHZhcmlvdXMgZXhwYW5kIGZlYXR1cmVzIGFyZSBkaXNhYmxlZCBmb3IgYSBHZXRBbGwgc2NlbmFyaW8uXG4gICAgdGhpcy5oYXNBcnJheVZhbHVlcyA9IGZhbHNlOy8vc2V0IHdoZW4gd2UgaGF2ZSBleGVjdXRlZCB0aGUgcXVlcnkuIFVzZWQgaW4gdmFsaWRhdGlvbiBzY2VuYXJpb3Mgd2hlcmUgd2UgZG8gbm90IGhhdmUgbWV0YWRhdGEgYWJvdXQgd2hldGhlciB0aGUgcmVsYXRpb24gaXMgYW4gYXJyYXkgb3Igbm90LlxuXG4gICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSBvcHRpb25zLmV4cGFuZEV4cHJlc3Npb24gfHwge307XG5cbiAgICB0aGlzLnBhcmVudFJlbGF0aW9uRmllbGQgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5QYXJlbnRSZWxhdGlvbkZpZWxkTmFtZV0gfHwgQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50O1xuICAgIHZhciByZWxhdGlvbkZpZWxkID0gdGhpcy5pc0ludmVydGVkUmVsYXRpb24gPyB0aGlzLnBhdGggOiB0aGlzLnJlbGF0aW9uRmllbGQ7IC8vaW52ZXJ0ZWQgcmVsYXRpb25zIGFwcGVhciB3aXRoIHRoZSBmdWxsIHBhdGggLSBDb250ZW50VHlwZS5GaWVsZCAtIGluIHRoZSByZXN1bHQgd2hlbiBleHBhbmRpbmcuXG4gICAgdGhpcy51c2VyRGVmaW5lZE5hbWUgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5SZXR1cm5Bc0ZpZWxkTmFtZV0gfHwgcmVsYXRpb25GaWVsZDtcbiAgICBfLmV4dGVuZCh0aGlzLmZpZWxkc0V4cHJlc3Npb24sIGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLkZpZWxkc0V4cHJlc3Npb25OYW1lXSk7XG4gICAgdGhpcy5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24gPSB7fTtcbiAgICBfLmV4dGVuZCh0aGlzLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgdGhpcy5maWVsZHNFeHByZXNzaW9uKTtcbiAgICB0aGlzLnNpbmdsZUZpZWxkTmFtZSA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWVdO1xuICAgIHRoaXMuZmlsdGVyRXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLkZpbHRlckV4cHJlc3Npb25OYW1lXTtcbiAgICB0aGlzLnNvcnRFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lXTtcbiAgICB0aGlzLnNraXAgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5Ta2lwRXhwcmVzc2lvbk5hbWVdO1xuICAgIHRoaXMudGFrZSA9IHRoaXMuX2dldFRha2VMaW1pdChleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWVdLCBvcHRpb25zLm1heFRha2VWYWx1ZSk7XG59XG5cblxuLyoqXG4gKiBHZXRzIHRoZSB0YWtlIGxpbWl0IGRlcGVuZGluZyBvbiB0aGUgYXBwbGljYXRpb24gYW5kIHRoZSB0YWtlIHZhbHVlIHRoYXQgdGhlIHVzZXIgaGFzIHByb3ZpZGVkLlxuICogQHBhcmFtIGNsaWVudFRha2VWYWx1ZVxuICogQHBhcmFtIG1heFRha2VWYWx1ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuUmVsYXRpb25Ob2RlLnByb3RvdHlwZS5fZ2V0VGFrZUxpbWl0ID0gZnVuY3Rpb24gKGNsaWVudFRha2VWYWx1ZSwgbWF4VGFrZVZhbHVlKSB7XG4gICAgbWF4VGFrZVZhbHVlID0gbWF4VGFrZVZhbHVlIHx8IENvbnN0YW50cy5EZWZhdWx0VGFrZUl0ZW1zQ291bnQ7XG4gICAgaWYgKGNsaWVudFRha2VWYWx1ZSkge1xuICAgICAgICBpZiAoY2xpZW50VGFrZVZhbHVlID4gbWF4VGFrZVZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhwYW5kRXJyb3IoJ1RoZSBtYXhpbXVtIGFsbG93ZWQgdGFrZSB2YWx1ZSB3aGVuIGV4cGFuZGluZyByZWxhdGlvbnMgaXMgJyArIG1heFRha2VWYWx1ZSArICchJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudFRha2VWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF4VGFrZVZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQW55b25lIHVzaW5nIHRoZSBicy1leHBhbmQtcHJvY2Vzc29yIG1vZHVsZSBjYW4gc2V0IHdoZXRoZXIgdGhlIHJlbGF0aW9uIGlzIGEgbXVsdGlwbGUgcmVsYXRpb24gaW4gdGhlIHByZXBhcmUgcGhhc2UuXG4gKiBUaGlzIHdpbGwgYWxsb3cgZm9yIGNlcnRhaW4gcmVzdHJpY3Rpb25zIHRvIGJlIGVuZm9yY2VkIGRpcmVjdGx5IG9uIHRoZSBwcmVwYXJlIHBoYXNlIGluc3RlYWQgb2YgdGhlIGV4ZWN1dGlvbiBwaGFzZS5cbiAqL1xuUmVsYXRpb25Ob2RlLnByb3RvdHlwZS5zZXRJc0FycmF5RnJvbU1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNBcnJheUZyb21NZXRhZGF0YSA9IHRydWU7XG59O1xuXG5SZWxhdGlvbk5vZGUucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgY2FuIGZpbmQgb3V0IGlmIGEgcmVsYXRpb24gaXMgYW4gYXJyYXkgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvLyBGcm9tIG1ldGFkYXRhIGluIHRoZSBBUEkgU2VydmVyLlxuICAgIC8vIEFsbCBpbnZlcnRlZCByZWxhdGlvbnMgYXJlIGFycmF5LlxuICAgIC8vIE9uY2UgdmFsdWVzIGhhdmUgYmVlbiByZWNlaXZlZCB3ZSBjYW4gZmluZCBvdXQuIFRoaXMgaXMgdXNlZCBmb3Igc2NlbmFyaW9zIHdoZXJlIHdlIGRvIG5vdCBoYXZlIG1ldGFkYXRhIGFib3V0IHRoZSByZWxhdGlvbiAob2ZmbGluZSBzdG9yYWdlIGluIFNESykuXG4gICAgcmV0dXJuIHRoaXMuaXNBcnJheUZyb21NZXRhZGF0YSB8fCB0aGlzLmlzSW52ZXJ0ZWRSZWxhdGlvbiB8fCB0aGlzLmhhc0FycmF5VmFsdWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvbk5vZGU7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgUmVsYXRpb25Ob2RlID0gcmVxdWlyZSgnLi9SZWxhdGlvbk5vZGUnKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4vQ29uc3RhbnRzJyk7XG52YXIgRXhwYW5kRXJyb3IgPSByZXF1aXJlKCcuL0V4cGFuZEVycm9yJyk7XG5cbi8vdmFyIHJlbGF0aW9uRmllbGRQcm9wZXJ0eU5hbWUgPSBDb25zdGFudHMuUmVsYXRpb25FeHByZXNzaW9uTmFtZTtcblxudmFyIHBvc3NpYmxlRXhwYW5kT3B0aW9ucyA9IFtcbiAgICBDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWUsXG4gICAgQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lLFxuICAgIENvbnN0YW50cy5GaWVsZHNFeHByZXNzaW9uTmFtZSxcbiAgICBDb25zdGFudHMuU2luZ2xlRmllbGRFeHByZXNzaW9uTmFtZSxcbiAgICBDb25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lLFxuICAgIENvbnN0YW50cy5GaWx0ZXJFeHByZXNzaW9uTmFtZSxcbiAgICBDb25zdGFudHMuU2tpcEV4cHJlc3Npb25OYW1lLFxuICAgIENvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWUsXG4gICAgQ29uc3RhbnRzLlBhcmVudFJlbGF0aW9uRmllbGROYW1lLFxuICAgIENvbnN0YW50cy5UYXJnZXRUeXBlTmFtZUZpZWxkTmFtZVxuXTtcblxuXG4vKipcbiAqIEEgY2xhc3MgdXNlZCB0byBwYXJzZSBFeHBhbmQgZXhwcmVzc2lvbiBhbmQgYnVpbGQgYSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uIHRyZWUuXG4gKiBJbiBhIHByb2Nlc3Mgb2YgY3JlYXRpbmcgdGhlIHJlbGF0aW9uIHRyZWUgYXJlIHBlcmZvcm1lZCBzZXZlcmFsIGNoZWNrcyBpbiBvcmRlciB0byBmb3JjZSBzb21lIGxpbWl0YXRpb25zIC1cbiAqIDUwIGl0ZW1zIGJvdGggZm9yIG1hc3RlciBhbmQgY2hpbGQgcXVlcmllcyBhbmQgZW50aXJlIGFtb3VudCBvZiBhbGwgcXVlcmllcyBsaW1pdGVkIHRvIDIwLlxuICogQ2hlY2tzIGlmIHRoZSByZWxhdGlvbiBmaWVsZCBnaXZlbiBieSB0aGUgY3VzdG9tZXIgaXMgdmFsaWQgKGZvciBleGFtcGxlOiB1c2VyIGdpdmVzIFwiTGlrZVwiIHdoaWxlIHRoZSByZWxhdGlvbiBmaWVsZCBpcyBcIkxpa2VzXCIpLlxuICogQ2hlY2tzIGZvciBwb3NzaWJsZSBleHBhbmQgb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVsYXRpb25UcmVlQnVpbGRlciA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uLCBtYWluVHlwZU5hbWUsIGlzQXJyYXksIGZpZWxkc0V4cHJlc3Npb24sIG1heFRha2VWYWx1ZSwgbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5tYXhUYWtlVmFsdWUgPSBtYXhUYWtlVmFsdWU7XG4gICAgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uID0gbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5leHBhbmRFeHByZXNzaW9uID0gdGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihleHBhbmRFeHByZXNzaW9uKTtcbiAgICAvLyBtYXJrIHRoZSBtYWluIHF1ZXJ5IGluIG9yZGVyIHRvIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gaXNzdWVzLlxuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5tYXBbbWFpblR5cGVOYW1lXSA9IG5ldyBSZWxhdGlvbk5vZGUoe1xuICAgICAgICB0YXJnZXRUeXBlTmFtZTogbWFpblR5cGVOYW1lLFxuICAgICAgICBpc0FycmF5Um9vdDogaXNBcnJheSxcbiAgICAgICAgZmllbGRzRXhwcmVzc2lvbjogZmllbGRzRXhwcmVzc2lvbixcbiAgICAgICAgdmFsaWRhdGVkOiB0cnVlLFxuICAgICAgICBwYXRoOiBtYWluVHlwZU5hbWUsXG4gICAgICAgIG1heFRha2VWYWx1ZTogbWF4VGFrZVZhbHVlXG4gICAgfSk7XG4gICAgdGhpcy5tYXBbbWFpblR5cGVOYW1lXS5vcmlnaW5hbEZpZWxkc0V4cHJlc3Npb24gPSB7fTtcbiAgICBfLmV4dGVuZCh0aGlzLm1hcFttYWluVHlwZU5hbWVdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgZmllbGRzRXhwcmVzc2lvbik7XG4gICAgdGhpcy5tYXAuJHJvb3QgPSBtYWluVHlwZU5hbWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgZnVsbHkgcXVhbGlmaWVkIGV4cGFuZCBleHByZXNzaW9uIGZyb20gc2hvcnRoYW5kIHVzYWdlczpcbiAqIHtcIkxpa2VzXCI6IHRydWV9IC0+IHtcIkxpa2VzXCI6IHtcIlJldHVybkFzXCI6IFwiTGlrZXNcIn19XG4gKiB7XCJMaWtlc1wiOiBcIkxpa2VzRXhwYW5kZWRcIn0gLT4ge1wiTGlrZXNcIjoge1wiUmV0dXJuQXNcIjogXCJMaWtlc0V4cGFuZGVkXCJ9fVxuICogQHBhcmFtIGV4cGFuZEV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHsqfVxuICovXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXhwYW5kRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZXhwYW5kRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID0ge307XG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV1bQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25GaWVsZCA9IGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID0ge307XG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV1bQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lXSA9IHJlbGF0aW9uRmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZEV4cHJlc3Npb247XG59O1xuXG4vKipcbiAqIEJ1aWxkcyB0aGUgcmVsYXRpb24gdHJlZS5cbiAqIEBwYXJhbSBkb25lXG4gKi9cblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLmJ1aWxkTWFwSW50ZXJuYWwodGhpcy5leHBhbmRFeHByZXNzaW9uLCB0aGlzLm1hcC4kcm9vdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZG9uZShlKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlcXVpcmUoJ2FzeW5jJykuc2VyaWVzKFtcbiAgICAgICAgdGhpcy5jb25maWd1cmVSZWxhdGlvblRyZWUuYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlbGF0aW9uVHJlZS5iaW5kKHRoaXMpXG4gICAgXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkb25lKGVyciwgc2VsZi5tYXApO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHJlbGF0aW9uTmFtZSAtIEEgcGF0aCB0byB0aGUgZXh0ZXJuYWwgcmVsYXRpb24gY29sbGVjdGlvbiAoQ29tbWVudHMuQWN0aXZpdHlJZClcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uIC0gVGhlIGV4cGFuZCBleHByZXNzaW9uIHRoYXQgY29udGFpbnMgYWxsIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWxhdGlvblxuICogQHBhcmFtIHJvb3ROYW1lIC0gTmFtZSBvZiB0aGUgcGFyZW50IHJlbGF0aW9uLlxuICogQHJldHVybnMge1JlbGF0aW9uTm9kZX1cbiAqL1xuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlSW52ZXJ0ZWRSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbk5hbWUsIGV4cGFuZEV4cHJlc3Npb24sIHJvb3ROYW1lKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgcmVsYXRpb25OYW1lUGFydHMgPSByZWxhdGlvbk5hbWUuc3BsaXQoJy4nKTtcbiAgICBvcHRpb25zLnBhcmVudCA9IHJvb3ROYW1lO1xuICAgIG9wdGlvbnMucmVsYXRpb25GaWVsZCA9IHJlbGF0aW9uTmFtZVBhcnRzWzFdO1xuICAgIG9wdGlvbnMuaXNJbnZlcnRlZFJlbGF0aW9uID0gdHJ1ZTtcbiAgICBvcHRpb25zLnRhcmdldFR5cGVOYW1lID0gcmVsYXRpb25OYW1lUGFydHNbMF07XG4gICAgb3B0aW9ucy5leHBhbmRFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbjtcbiAgICBvcHRpb25zLnBhdGggPSByZWxhdGlvbk5hbWU7XG4gICAgb3B0aW9ucy5tYXhUYWtlVmFsdWUgPSB0aGlzLm1heFRha2VWYWx1ZTtcbiAgICBvcHRpb25zLnZhbGlkYXRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5ldyBSZWxhdGlvbk5vZGUob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEFuIGludGVybmFsIG1ldGhvZCB3aGljaCBwYXJzZXMgdGhlIGV4cGFuZCBleHByZXNzaW9uIGFuZCBwcm9kdWNlcyBhIGJhc2ljIHJlbGF0aW9uIHRyZWUgKG9ubHkgbmFtZXMgYW5kIHBhcmVudCByZWxhdGlvbnMpLlxuICogQHBhcmFtIGV4cGFuZEV4cHJlc3Npb24gLSBUaGUgZXhwYW5kIGV4cHJlc3Npb24gd2hpY2ggd2lsbCBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0gcm9vdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcm9vdCByZWxhdGlvbiAobWFzdGVyIHF1ZXJ5KSB1c3VhbGx5IHRoZSBuYW1lIG9mIHRoZSByZXF1ZXN0ZWQgY29udGVudCB0eXBlIChBY3Rpdml0aWVzKS5cbiAqL1xuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRNYXBJbnRlcm5hbCA9IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uLCByb290TmFtZSkge1xuICAgIGZvciAodmFyIHJlbGF0aW9uTmFtZSBpbiBleHBhbmRFeHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChleHBhbmRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KHJlbGF0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RXhwcmVzc2lvbiA9IGV4cGFuZEV4cHJlc3Npb25bcmVsYXRpb25OYW1lXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIGN1cnJlbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgcG9zc2libGVFeHBhbmRPcHRpb25zLmluZGV4T2Yob3B0aW9uKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4cGFuZEVycm9yKCdcXFwiJyArIG9wdGlvbiArICdcXFwiJyArICcgaXMgbm90IGEgdmFsaWQgb3B0aW9uIGZvciBFeHBhbmQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uTmFtZS5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnZlcnRlZFJlbGF0aW9uID0gdGhpcy5jcmVhdGVJbnZlcnRlZFJlbGF0aW9uKHJlbGF0aW9uTmFtZSwgY3VycmVudEV4cHJlc3Npb24sIHJvb3ROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtpbnZlcnRlZFJlbGF0aW9uLnBhdGhdID0gaW52ZXJ0ZWRSZWxhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtpbnZlcnRlZFJlbGF0aW9uLnBhcmVudF0uY2hpbGRyZW4ucHVzaChpbnZlcnRlZFJlbGF0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIC8vIGFkZHMgYSBmaWVsZCBleHByZXNzaW9uIGluIHRoZSBvcmlnaW5hbCBmaWVsZHMgZXhwcmVzc2lvbiBpbiBvcmRlciB0byBnZXQgdGhlIHJlc3VsdCBmb3IgdGhhdCBmaWVsZFxuICAgICAgICAgICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24odGhpcy5tYXBbaW52ZXJ0ZWRSZWxhdGlvbi5wYXJlbnRdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgaW52ZXJ0ZWRSZWxhdGlvbi51c2VyRGVmaW5lZE5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEV4cHJlc3Npb25bcmVsYXRpb25OYW1lXVtDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRFeHBhbmRFeHByZXNzaW9uID0gdGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV1bQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRNYXBJbnRlcm5hbChwcm9jZXNzZWRFeHBhbmRFeHByZXNzaW9uLCBpbnZlcnRlZFJlbGF0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlbGF0aW9uRmllbGQgPSByZWxhdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnQgPSByb290TmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4cGFuZEV4cHJlc3Npb24gPSBjdXJyZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heFRha2VWYWx1ZSA9IHRoaXMubWF4VGFrZVZhbHVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0VHlwZU5hbWUgPSBjdXJyZW50RXhwcmVzc2lvbltDb25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbk5vZGUgPSBuZXcgUmVsYXRpb25Ob2RlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5tYXBbb3B0aW9ucy5wYXJlbnRdO1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4ucHVzaChyZWxhdGlvbk5vZGUucGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXBbcmVsYXRpb25Ob2RlLnBhdGhdID0gcmVsYXRpb25Ob2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KENvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjdXJyZW50RXhwcmVzc2lvbltDb25zdGFudHMuRXhwYW5kRXhwcmVzc2lvbk5hbWVdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRNYXBJbnRlcm5hbCh0aGlzLnByb2Nlc3NFeHBhbmRFeHByZXNzaW9uKGN1cnJlbnRFeHByZXNzaW9uLkV4cGFuZCksIHJlbGF0aW9uTm9kZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHBhbmRFcnJvcihyZWxhdGlvbk5vZGUucGF0aCArICcuRXhwYW5kIG11c3QgYmUgYSB2YWxpZCBleHBhbmQgZXhwcmVzc2lvbiEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQWRkcyBhZGRpdGlvbmFsIG1ldGFkYXRhIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBleGVjdXRlIGEgcXVlcnkuXG4gKiBOYW1lIG9mIHRoZSBjb250ZW50IHR5cGUgb2YgdGhlIGNoaWxkIHJlbGF0aW9uIGdldCB2aWEgcmVsYXRpb24gZmllbGQuXG4gKiBAcGFyYW0gZG9uZVxuICovXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jb25maWd1cmVSZWxhdGlvblRyZWUgPSBmdW5jdGlvbiAoZG9uZSkge1xuICAgIGlmICh0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlbGF0aW9uTmFtZXMgPSBbXTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIHJlbCBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KHJlbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBbcmVsXS5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25OYW1lcy5wdXNoKHRoaXMubWFwW3JlbF0ucmVsYXRpb25GaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uKHJlbGF0aW9uTmFtZXMsIHRoaXMubWFwLCB0aGlzLmNvbnRleHQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgc2V2ZXJhbCBjaGVja3MgbGlrZTpcbiAqIFZhbGlkaXR5IG9mIHRoZSByZWxhdGlvbiBmaWVsZC5cbiAqIFRvIG5vdCB1c2UgZmlsdGVyIG9yIHNvcnRpbmcgZXhwcmVzc2lvbiB3aXRoaW4gYSBcIkdldEJ5RmlsdGVyXCIgc2NlbmFyaW8uXG4gKiBEb2VzIG5vdCBhbGxvdyB0byBuZXN0IChleHBhbmQgbXVsdGlwbGUgcmVsYXRpb24gZmllbGQpIGFmdGVyIGEgbXVsdGlwbGUgcmVsYXRpb24uXG4gKiBEb2VzIG5vdCBhbGxvdyB0byB1c2UgYm90aCBcIkZpZWxkc1wiIGFuZCBcIlNpbmdsZUZpZWxkXCIgb3B0aW9ucy5cbiAqIEBwYXJhbSBkb25lXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUudmFsaWRhdGVSZWxhdGlvblRyZWUgPSBmdW5jdGlvbiAoZG9uZSkge1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcbiAgICB2YXIgRU9MID0gJ1xcclxcbic7XG4gICAgZm9yICh2YXIgcmVsYXRpb25QYXRoIGluIHRoaXMubWFwKSB7XG4gICAgICAgIGlmIChyZWxhdGlvblBhdGggIT09ICckcm9vdCcgJiYgdGhpcy5tYXAuaGFzT3duUHJvcGVydHkocmVsYXRpb25QYXRoKSkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5tYXBbcmVsYXRpb25QYXRoXTtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSB0aGlzLnZhbGlkYXRlU2luZ2xlUmVsYXRpb24ocmVsYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVGaWVsZHNFeHByZXNzaW9uc0ZvclJlbGF0aW9uKHJlbGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3JNZXNzYWdlICE9PSAnJykge1xuICAgICAgICB2YXIgZmluYWxFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2Uuc3Vic3RyKDAsIGVycm9yTWVzc2FnZS5sYXN0SW5kZXhPZihFT0wpKTtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4cGFuZEVycm9yKGZpbmFsRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCByZWxhdGlvbiBmaWVsZHMgdG8gcGFyZW50IHJlbGF0aW9uIGZpZWxkcyBleHByZXNzaW9uIGlmIG5lZWRlZCAob3RoZXJ3aXNlIHJlbGF0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZCkuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIHJlbGF0aW9uIHdoaWNoIHdpbGwgYmUgY29uZmlndXJlZC5cbiAqL1xuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY29uZmlndXJlRmllbGRzRXhwcmVzc2lvbnNGb3JSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuICAgIGlmIChyZWxhdGlvbi5wYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiA9IHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0uZmllbGRzRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xuICAgICAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihwYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uRmllbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihwYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24sIHJlbGF0aW9uLnJlbGF0aW9uRmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcbiAgICAgICAgUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbihyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uLCByZWxhdGlvbi5yZWxhdGlvbkZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24sIENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCk7XG4gICAgfVxuICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRqdXN0UGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uKHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0sIHJlbGF0aW9uKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgc2luZ2xlIHJlbGF0aW9uIGZvciBhbGwgYnVpbGQtaW4gbGltaXRhdGlvbnMuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBBIHJlbGF0aW9uIHdoaWNoIHdpbGwgYmUgdmFsaWRhdGVkLlxuICogQHJldHVybnMge3N0cmluZ30gLSBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCBhbGwgZXJyb3JzIG9yIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBpcyBubyBlcnJvcnMuXG4gKi9cblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLnZhbGlkYXRlU2luZ2xlUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgdmFyIEVPTCA9ICdcXHJcXG4nO1xuICAgIHZhciBpc0dldEJ5RmlsdGVyUXVlcnkgPSB0aGlzLm1hcFt0aGlzLm1hcC4kcm9vdF0uaXNBcnJheVJvb3Q7XG5cbiAgICBpZiAocmVsYXRpb24ucGF0aCA9PT0gcmVsYXRpb24ucGFyZW50KSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSArPSByZWxhdGlvbi5wYXRoICsgJyBoYXMgc2FtZSBwYXJlbnQgd2hpY2ggd2lsbCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLicgKyBFT0w7XG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG4gICAgfVxuXG4gICAgaWYgKHJlbGF0aW9uLmlzQXJyYXkoKSkge1xuICAgICAgICB2YXIgbXVsdGlwbGVRdWVyaWVzQ291bnQgPSB0aGlzLmdldFBhcmVudE11bHRpcGxlUmVsYXRpb25zQ291bnQocmVsYXRpb24pO1xuICAgICAgICBpZiAobXVsdGlwbGVRdWVyaWVzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZCBleHByZXNzaW9uIGhhcyBtdWx0aXBsZSByZWxhdGlvbiBcXFwiJyArIHJlbGF0aW9uLnBhdGggKyAnXFxcIiBpbnNpZGUgYSBtdWx0aXBsZSByZWxhdGlvbi4nO1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1hcFtyZWxhdGlvbi5wYXJlbnRdID09PSB0aGlzLm1hcFt0aGlzLm1hcC4kcm9vdF0gJiZcbiAgICAgICAgICAgIGlzR2V0QnlGaWx0ZXJRdWVyeSAmJlxuICAgICAgICAgICAgKHJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gfHwgcmVsYXRpb24uc29ydEV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0ZpbHRlciBhbmQgU29ydCBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aCBHZXRCeUZpbHRlciBzY2VuYXJpby4nO1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0dldEJ5RmlsdGVyUXVlcnkgJiYgcmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZGluZyBhbiBleHRlcm5hbCBjb250ZW50IHR5cGUgaXMgbm90IGFsbG93ZWQgd2l0aCBHZXRCeUZpbHRlciBzY2VuYXJpby4nO1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlbGF0aW9uLnRhcmdldFR5cGVOYW1lKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSArPSAnRXhwYW5kaW5nIHJlbGF0aW9uIFxcXCInICsgcmVsYXRpb24ucmVsYXRpb25GaWVsZCArICdcXFwiIGhhcyBubyB0YXJnZXQgdHlwZSBuYW1lIHNwZWNpZmllZC4gWW91IHNob3VsZCB1c2UgXFxcIlRhcmdldFR5cGVOYW1lXFxcIiB0byBzcGVjaWZ5IGl0Lic7XG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XG4gICAgfVxuICAgIGlmIChyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uICYmIE9iamVjdC5rZXlzKHJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24pLmxlbmd0aCAmJiByZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IHJlbGF0aW9uLnBhdGggKyAnICc7XG4gICAgICAgIGVycm9yTWVzc2FnZSArPSAnZXhwYW5kIGV4cHJlc3Npb24gY29udGFpbnMgYm90aCBcXFwiRmllbGRzXFxcIiBhbmQgXFxcIlNpbmdsZUZpZWxkXFxcIiBleHByZXNzaW9ucy4nO1xuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xuICAgIH1cbiAgICBpZiAocmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XG4gICAgICAgIGlmIChyZWxhdGlvbi5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gcmVsYXRpb24ucGF0aCArICcgaGFzIG11bHRpcGxlIGV4cGFuZCBleHByZXNzaW9ucyB3aXRoIGEgc2luZ2xlIGZpZWxkIG9wdGlvbi4nICsgRU9MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hcFtyZWxhdGlvbi5jaGlsZHJlblswXV0ucmVsYXRpb25GaWVsZCAhPT0gcmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdFeHBhbmQgZXhwcmVzc2lvbiAnICsgcmVsYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJyBzaW5nbGUgZmllbGQgXFxcIicgKyByZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUgKyAnXFxcIic7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgZG9lcyBub3QgbWF0Y2ggY2hpbGQgcmVsYXRpb24gZmllbGQgXFxcIicgKyB0aGlzLm1hcFtyZWxhdGlvbi5jaGlsZHJlblswXV0ucmVsYXRpb25GaWVsZCArICdcXFwiLic7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGNvdW50IG9mIHBhcmVudCBtdWx0aXBsZSByZWxhdGlvbnMuXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBTdGFydGluZyByZWxhdGlvbi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gY291bnQgb2YgYWxsIHBhcmVudCBtdWx0aXBsZSByZWxhdGlvbnNcbiAqL1xuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0UGFyZW50TXVsdGlwbGVSZWxhdGlvbnNDb3VudCA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciByZWxhdGlvbkZvckxvb3AgPSByZWxhdGlvbjtcbiAgICB3aGlsZSAocmVsYXRpb25Gb3JMb29wLnBhcmVudCkge1xuICAgICAgICB2YXIgcGFyZW50UmVsYXRpb24gPSB0aGlzLm1hcFtyZWxhdGlvbkZvckxvb3AucGFyZW50XTtcbiAgICAgICAgaWYgKHBhcmVudFJlbGF0aW9uLmlzQXJyYXkoKSAmJiBwYXJlbnRSZWxhdGlvbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aW9uRm9yTG9vcCA9IHBhcmVudFJlbGF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIEFkanVzdHMgZmllbGRzIGV4cHJlc3Npb24gb2YgdGhlIHBhcmVudCByZWxhdGlvbiBiYXNlZCBvbiBwYWdpbmcgc2V0dGluZyBvZiBhIHJlbGF0aW9uIChza2lwLCB0YWtlKS5cbiAqIEluIHRoYXQgY2FzZSB3ZSBwdXQgYSBcIiRzbGljZVwiIG9wdGlvbiB3aXRoaW4gdGhlIHBhcmVudCByZWxhdGlvbiBmaWVsZHMgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBwYXJlbnRSZWxhdGlvblxuICogQHBhcmFtIHJlbGF0aW9uXG4gKi9cblJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRqdXN0UGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uID0gZnVuY3Rpb24gKHBhcmVudFJlbGF0aW9uLCByZWxhdGlvbikge1xuICAgIGlmICghcmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uICYmIHJlbGF0aW9uLnRha2UgJiYgdHlwZW9mIHJlbGF0aW9uLnRha2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIHdoZW4gcmVsYXRpb24gaGFzIGZpbHRlciBvciBzb3J0aW5nIHNraXAgYW5kIHRha2Ugc2hvdWxkIG5vdCBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGFyZW50IHJlbGF0aW9uIGFzICRzbGljZS5cbiAgICAgICAgdmFyIHNob3VsZFRyYW5zZmVyUGFnaW5nVG9QYXJlbnRSZWxhdGlvbiA9IHJlbGF0aW9uLmlzQXJyYXkoKSAmJiAhcmVsYXRpb24uZmlsdGVyRXhwcmVzc2lvbiAmJiAhcmVsYXRpb24uc29ydEV4cHJlc3Npb24gJiYgcGFyZW50UmVsYXRpb247XG4gICAgICAgIGlmIChzaG91bGRUcmFuc2ZlclBhZ2luZ1RvUGFyZW50UmVsYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWxhdGlvbi5za2lwICYmIHR5cGVvZiByZWxhdGlvbi5za2lwID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb24ucmVsYXRpb25GaWVsZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICckc2xpY2UnOiBbcmVsYXRpb24uc2tpcCwgcmVsYXRpb24udGFrZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uW3JlbGF0aW9uLnJlbGF0aW9uRmllbGRdID0ge1xuICAgICAgICAgICAgICAgICAgICAnJHNsaWNlJzogcmVsYXRpb24udGFrZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWxhdGlvbi50YWtlID0gbnVsbDtcbiAgICAgICAgICAgIHJlbGF0aW9uLnNraXAgPSBudWxsO1xuICAgICAgICAgICAgcmVsYXRpb24ubW92ZWRTa2lwVGFrZUFzU2xpY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGZpZWxkIHRvIHBhcmVudCByZWxhdGlvbiBmaWVsZHMgZXhwcmVzc2lvbi4gRm9yIGV4YW1wbGUgaWYgdGhlIHJlbGF0aW9uIGZpZWxkIGlzIGV4Y2x1ZGVkIGZyb20gdGhlIG1hc3RlciByZXF1ZXN0LlxuICogQHBhcmFtIGZpZWxkc0V4cHJlc3Npb24gLSBGaWVsZHMgZXhwcmVzc2lvbiBvZiB0aGUgcGFyZW50IHJlbGF0aW9uLlxuICogQHBhcmFtIHJlbGF0aW9uRmllbGQgLSBOYW1lIG9mIHRoZSBmaWVsZCB3aGljaCBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKi9cblJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoZmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb25GaWVsZCkge1xuICAgIGlmIChmaWVsZHNFeHByZXNzaW9uID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoZmllbGRzRXhwcmVzc2lvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlzRXhjbHVzaXZlID0gUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUoZmllbGRzRXhwcmVzc2lvbik7XG5cbiAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNFeHByZXNzaW9uW3JlbGF0aW9uRmllbGRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkc0V4cHJlc3Npb25bcmVsYXRpb25GaWVsZF0gPSAxO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0cyBpZiB0aGUgZmllbGRzIGV4cHJlc3Npb24gaXMgZXhjbHVzaXZlIChcIkZpZWxkTmFtZVwiIDogMClcbiAqIEBwYXJhbSBmaWVsZHNFeHByZXNzaW9uIC0gRmllbGRzIGV4cHJlc3Npb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuUmVsYXRpb25UcmVlQnVpbGRlci5nZXRJc0ZpZWxkc0V4cHJlc3Npb25FeGNsdXNpdmUgPSBmdW5jdGlvbiAoZmllbGRzRXhwcmVzc2lvbikge1xuICAgIHZhciBpc0V4Y2x1c2l2ZTtcbiAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzRXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZmllbGROYW1lICE9PSBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQgJiYgZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZHNFeHByZXNzaW9uW2ZpZWxkTmFtZV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXNFeGNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkc0V4cHJlc3Npb25bZmllbGROYW1lXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzRXhwcmVzc2lvbltmaWVsZE5hbWVdID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V4Y2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzRXhjbHVzaXZlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvblRyZWVCdWlsZGVyO1xuIiwiLyohXG4gKiBhc3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKmpzaGludCBvbmV2YXI6IGZhbHNlLCBpbmRlbnQ6NCAqL1xuLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9tYXAgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvcih4LCBpLCBhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBpZiAoYXJyLnJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pO1xuICAgICAgICB9XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG5cbiAgICB2YXIgX2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXG5cbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICEocHJvY2Vzcy5uZXh0VGljaykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZG9uZSkgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICB2YXIgcmVtYWluaW5nVGFza3MgPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tXG4gICAgICAgICAgICBfZWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBmaW5hbCBjYWxsYmFjayBmcm9tIGNhbGxpbmcgaXRzZWxmIGlmIGl0IGVycm9yc1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgICAgICB0aGVDYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gX2lzQXJyYXkodGFza3Nba10pID8gdGFza3Nba106IFt0YXNrc1trXV07XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5yZXRyeSA9IGZ1bmN0aW9uKHRpbWVzLCB0YXNrLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XG4gICAgICAgIHZhciBhdHRlbXB0cyA9IFtdO1xuICAgICAgICAvLyBVc2UgZGVmYXVsdHMgaWYgdGltZXMgbm90IHBhc3NlZFxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2s7XG4gICAgICAgICAgICB0YXNrID0gdGltZXM7XG4gICAgICAgICAgICB0aW1lcyA9IERFRkFVTFRfVElNRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRpbWVzIGlzIGEgbnVtYmVyXG4gICAgICAgIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB2YXIgd3JhcHBlZFRhc2sgPSBmdW5jdGlvbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgcmV0cnlBdHRlbXB0ID0gZnVuY3Rpb24odGFzaywgZmluYWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2soIWVyciB8fCBmaW5hbEF0dGVtcHQsIHtlcnI6IGVyciwgcmVzdWx0OiByZXN1bHR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChyZXRyeUF0dGVtcHQodGFzaywgISh0aW1lcy09MSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jLnNlcmllcyhhdHRlbXB0cywgZnVuY3Rpb24oZG9uZSwgZGF0YSl7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAod3JhcHBlZENhbGxiYWNrIHx8IGNhbGxiYWNrKShkYXRhLmVyciwgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHJ1biB0aGlzIGFzIGEgY29udHJvbGwgZmxvd1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB3cmFwcGVkVGFzaygpIDogd3JhcHBlZFRhc2tcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICh0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICghdGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvVW50aWwoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcS5kcmFpbiA9IG51bGw7XG4gICAgICAgICAgICAgIHEudGFza3MgPSBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IHRydWUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcbiAgICBcbiAgICBhc3luYy5wcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XG4gICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xuICAgICAgICAgIHZhciBiZWcgPSAtMSxcbiAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGJlZyA9IG1pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiZWc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xuICAgICAgICBcbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICAgICAgcS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XG5cbiAgICAgICAgdmFyIGNhcmdvID0ge1xuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBkcmFpbmVkOiB0cnVlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluICYmICFjYXJnby5kcmFpbmVkKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCwgdGFza3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9XSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICAvLyBOb2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG4iLCJ2YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBQbGF0Zm9ybSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuUGxhdGZvcm07XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBqc3R6ID0gY29tbW9uLmpzdHo7XG52YXIgXyA9IGNvbW1vbi5fO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNsYXNzIEN1cnJlbnREZXZpY2VcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gcHVzaEhhbmRsZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ3VycmVudERldmljZSA9IGZ1bmN0aW9uIChwdXNoSGFuZGxlcikge1xuICAgICAgICB0aGlzLl9wdXNoSGFuZGxlciA9IHB1c2hIYW5kbGVyO1xuICAgICAgICB0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdEVycm9yQ2FsbGJhY2sgPSBudWxsO1xuXG4gICAgICAgIC8vU3VmZml4IGZvciB0aGUgZ2xvYmFsIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl9nbG9iYWxGdW5jdGlvblN1ZmZpeCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLnB1c2hUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5lbXVsYXRvck1vZGUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ3VycmVudERldmljZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zLiBUaGlzIG1ldGhvZCByZXF1ZXN0cyBhIHB1c2ggdG9rZW4gZnJvbSB0aGUgZGV2aWNlIHZlbmRvciBhbmQgZW5hYmxlcyB0aGUgcHVzaCBub3RpZmljYXRpb24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgZGV2aWNlLiBPbmNlIHRoaXMgaXMgZG9uZSwgeW91IGNhbiByZWdpc3RlciB0aGUgZGV2aWNlIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNpbmcgdGhlIHJlZ2lzdGVyKCkgbWV0aG9kLlxuICAgICAgICAgKiBAbWV0aG9kIGVuYWJsZU5vdGlmaWNhdGlvbnNcbiAgICAgICAgICogQG5hbWUgZW5hYmxlTm90aWZpY2F0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtQdXNoU2V0dGluZ3N9IHB1c2hTZXR0aW5ncyBBbiBvYmplY3Qgc3BlY2lmeWluZyB2YXJpb3VzIHNldHRpbmdzIGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYSBwdXNoIHRva2VuIGZyb20gdGhlIGRldmljZSB2ZW5kb3IgYW5kIGVuYWJsZXMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS4gT25jZSB0aGlzIGlzIGRvbmUsIHlvdSBjYW4gcmVnaXN0ZXIgdGhlIGRldmljZSBpbiBFdmVybGl2ZSB1c2luZyB0aGUgcmVnaXN0ZXIoKSBtZXRob2QuXG4gICAgICAgICAqIEBtZXRob2QgZW5hYmxlTm90aWZpY2F0aW9uc1xuICAgICAgICAgKiBAbmFtZSBlbmFibGVOb3RpZmljYXRpb25zXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1B1c2hTZXR0aW5nc30gcHVzaFNldHRpbmdzIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHZhcmlvdXMgc2V0dGluZ3MgZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIChwdXNoU2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IHRoaXMuX2NsZWFuUGxhdGZvcm1zUHVzaFNldHRpbmdzKHB1c2hTZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXy5iaW5kKHRoaXMuX2luaXRpYWxpemUsIHRoaXMpLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXG4gICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU5vdGlmaWNhdGlvbnNcbiAgICAgICAgICogQG5hbWUgZGlzYWJsZU5vdGlmaWNhdGlvbnNcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSBjdXJyZW50IGRldmljZS4gVGhpcyBtZXRob2QgaW52YWxpZGF0ZXMgYW55IHB1c2ggdG9rZW5zIHRoYXQgd2VyZSBvYnRhaW5lZCBmb3IgdGhlIGRldmljZSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uLlxuICAgICAgICAgKiBAbWV0aG9kIGRpc2FibGVOb3RpZmljYXRpb25zXG4gICAgICAgICAqIEBuYW1lIGRpc2FibGVOb3RpZmljYXRpb25zXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnJlZ2lzdGVyKCkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbXVsYXRvck1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXNoTm90aWZpY2F0aW9uID0gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVucmVnaXN0ZXJPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gc2VsZi5fZ2V0UGxhdGZvcm1UeXBlKGRldmljZS5wbGF0Zm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLldpbmRvd3NQaG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck9wdGlvbnMgPSB7J2NoYW5uZWxOYW1lJzogc2VsZi5wdXNoU2V0dGluZ3Mud3A4LmNoYW5uZWxOYW1lfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnVucmVnaXN0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcHVzaCByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX2dldERldmljZUlkKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hIYW5kbGVyLmRldmljZXMuZ2V0QnlJZCgnSGFyZHdhcmVJZC8nICsgZGV2aWNlSWQsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb25seSBhZnRlciBbZW5hYmxlTm90aWZpY2F0aW9ucygpXXtAbGluayBjdXJyZW50RGV2aWNlLmVuYWJsZU5vdGlmaWNhdGlvbnN9IGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCByZWdpc3RlclxuICAgICAgICAgKiBAbmFtZSByZWdpc3RlclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgW2VuYWJsZU5vdGlmaWNhdGlvbnMoKV17QGxpbmsgY3VycmVudERldmljZS5lbmFibGVOb3RpZmljYXRpb25zfSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKGN1c3RvbVBhcmFtZXRlcnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGFyYW1ldGVycyA9IGN1c3RvbVBhcmFtZXRlcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3B1bGF0ZVJlZ2lzdHJhdGlvbk9iamVjdChkZXZpY2VSZWdpc3RyYXRpb24pLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVzaEhhbmRsZXIuZGV2aWNlcy5jcmVhdGUoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlcnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZyb20gcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIEFmdGVyIHRoaXMgY2FsbCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LCB7e3NpdGUuYnN9fSB3aWxsIG5vIGxvbmdlciBzZW5kIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2UuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHByZXZlbnQgdGhlIGRldmljZSBmcm9tIHJlY2VpdmluZyBub3RpZmljYXRpb25zIGFuZCBkb2VzIG5vdCBpbnZhbGlkYXRlIHB1c2ggdG9rZW5zLlxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmcm9tIHB1c2ggbm90aWZpY2F0aW9ucyBpbiB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBBZnRlciB0aGlzIGNhbGwgY29tcGxldGVzIHN1Y2Nlc3NmdWxseSwge3tzaXRlLmJzfX0gd2lsbCBubyBsb25nZXIgc2VuZCBub3RpZmljYXRpb25zIHRvIHRoaXMgZGV2aWNlLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBkZXZpY2UgZnJvbSByZWNlaXZpbmcgbm90aWZpY2F0aW9ucyBhbmQgZG9lcyBub3QgaW52YWxpZGF0ZSBwdXNoIHRva2Vucy5cbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxuICAgICAgICAgKiBAbmFtZSB1bnJlZ2lzdGVyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UudXVpZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEhhbmRsZXIuZGV2aWNlcy5kZXN0cm95U2luZ2xlKHtJZDogJ0hhcmR3YXJlSWQvJyArIGRldmljZUlkfSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIGN1cnJlbnQgZGV2aWNlLlxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVSZWdpc3RyYXRpb25cbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB1bmRlZmluZWQsIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVSZWdpc3RyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHVuZGVmaW5lZCwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoY3VzdG9tUGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBhcmFtZXRlcnMgPSBjdXN0b21QYXJhbWV0ZXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9wdWxhdGVSZWdpc3RyYXRpb25PYmplY3QoZGV2aWNlUmVnaXN0cmF0aW9uKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLklkID0gJ0hhcmR3YXJlSWQvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VSZWdpc3RyYXRpb24uSGFyZHdhcmVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wdXNoSGFuZGxlci5kZXZpY2VzLnVwZGF0ZVNpbmdsZShkZXZpY2VSZWdpc3RyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0aWFsaXplSW50ZXJhY3RpdmVQdXNoOiBmdW5jdGlvbiAoaU9TU2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgcHVzaFBsdWdpbiA9IHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb247XG5cbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGl2ZVNldHRpbmdzID0gaU9TU2V0dGluZ3MuaW50ZXJhY3RpdmVTZXR0aW5ncztcbiAgICAgICAgICAgIHZhciBub3RpZmljYXRpb25UeXBlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGlPU1NldHRpbmdzLmFsZXJ0KSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZXMucHVzaChwdXNoUGx1Z2luLlVzZXJOb3RpZmljYXRpb25UeXBlcy5BbGVydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaU9TU2V0dGluZ3MuYmFkZ2UpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25UeXBlcy5wdXNoKHB1c2hQbHVnaW4uVXNlck5vdGlmaWNhdGlvblR5cGVzLkJhZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpT1NTZXR0aW5ncy5zb3VuZCkge1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblR5cGVzLnB1c2gocHVzaFBsdWdpbi5Vc2VyTm90aWZpY2F0aW9uVHlwZXMuU291bmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2V0QWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gXy5maW5kKGludGVyYWN0aXZlU2V0dGluZ3MuYWN0aW9ucywgZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmlkZW50aWZpZXIgPT09IGFjdGlvbklkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzID0gXy5tYXAoaW50ZXJhY3RpdmVTZXR0aW5ncy5jYXRlZ29yaWVzLCBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBjYXRlZ29yeS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRm9yRGVmYXVsdENvbnRleHQ6IF8ubWFwKGNhdGVnb3J5LmFjdGlvbnNGb3JEZWZhdWx0Q29udGV4dCwgZ2V0QWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Zvck1pbmltYWxDb250ZXh0OiBfLm1hcChjYXRlZ29yeS5hY3Rpb25zRm9yTWluaW1hbENvbnRleHQsIGdldEFjdGlvbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHVzaFBsdWdpbi5yZWdpc3RlclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3VjY2VzcyBjYWxsYmFjayB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHJldHVybiAoQVBOcyBpcyBub3QgY29udGFjdGVkIGZvciB0aGlzKVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIGluIGNhc2UgdGhlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0XG4gICAgICAgICAgICAgICAgZXJyb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNraW5nIHBlcm1pc3Npb24gZm9yIHRoZXNlIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiBub3RpZmljYXRpb25UeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGhlc2UgY2F0ZWdvcmllc1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL0luaXRpYWxpemVzIHRoZSBwdXNoIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS5cbiAgICAgICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdQdXNoIG5vdGlmaWNhdGlvbnMgYXJlIGN1cnJlbnRseSBpbml0aWFsaXppbmcuJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmVtdWxhdG9yTW9kZSAmJiAoIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbikpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignVGhlIGdsb2JhbGl6YXRpb24gcGx1Z2luIGlzIG5vdCBpbml0aWFsaXplZC4nKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW11bGF0b3JNb2RlICYmICghd2luZG93LnBsdWdpbnMgfHwgIXdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBwdXNoIG5vdGlmaWNhdGlvbnMgcGx1Z2luIGlzIG5vdCBpbml0aWFsaXplZC4nKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrID0gc3VjY2VzcztcbiAgICAgICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrID0gZXJyb3I7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHRoaXMucHVzaFRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmVtdWxhdG9yTW9kZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MoJ2Zha2VfcHVzaF90b2tlbicpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAxMDAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gdGhpcy5fZ2xvYmFsRnVuY3Rpb25TdWZmaXg7XG4gICAgICAgICAgICBpZiAoIXN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxGdW5jdGlvblN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xuXG4gICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gdGhpcy5fZ2V0UGxhdGZvcm1UeXBlKGRldmljZS5wbGF0Zm9ybSk7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5pT1MpIHtcbiAgICAgICAgICAgICAgICAvL0luaXRpYWxpemUgZ2xvYmFsIEFQTiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhciBhcG5DYWxsYmFja05hbWUgPSAnYXBuQ2FsbGJhY2tfJyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW2FwbkNhbGxiYWNrTmFtZV0gPSBfLmJpbmQodGhpcy5fb25Ob3RpZmljYXRpb25BUE4sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSBpT1Mgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICB2YXIgYXBuUmVnaXN0cmF0aW9uT3B0aW9ucyA9IHRoaXMucHVzaFNldHRpbmdzLmlPUztcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUlPU1NldHRpbmdzKGFwblJlZ2lzdHJhdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIGFwbkNhbGxiYWNrTmFtZTtcblxuICAgICAgICAgICAgICAgIC8vUmVnaXN0ZXIgZm9yIEFQTlxuICAgICAgICAgICAgICAgIHB1c2hOb3RpZmljYXRpb24ucmVnaXN0ZXIoXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzZnVsUmVnaXN0cmF0aW9uQVBOLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX2ZhaWxlZFJlZ2lzdHJhdGlvbkFQTiwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLkFuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAvL0luaXRpYWxpemUgZ2xvYmFsIEdDTSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhciBnY21DYWxsYmFja05hbWUgPSAnZ2NtQ2FsbGJhY2tfJyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW2djbUNhbGxiYWNrTmFtZV0gPSBfLmJpbmQodGhpcy5fb25Ob3RpZmljYXRpb25HQ00sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSB0aGUgQW5kcm9pZCBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIHZhciBnY21SZWdpc3RyYXRpb25PcHRpb25zID0gdGhpcy5wdXNoU2V0dGluZ3MuYW5kcm9pZDtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUFuZHJvaWRTZXR0aW5ncyhnY21SZWdpc3RyYXRpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICBnY21SZWdpc3RyYXRpb25PcHRpb25zLmVjYiA9ICdFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzLicgKyBnY21DYWxsYmFja05hbWU7XG5cbiAgICAgICAgICAgICAgICAvL1JlZ2lzdGVyIGZvciBHQ01cbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25HQ00sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZXJyb3JTZW50UmVnaXN0cmF0aW9uR0NNLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgZ2NtUmVnaXN0cmF0aW9uT3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uV2luZG93c1Bob25lKSB7XG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBXUDggY2FsbGJhY2tzLlxuICAgICAgICAgICAgICAgIHZhciB3cDhDYWxsYmFja05hbWUgPSAnd3A4Q2FsbGJhY2tfJyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrTmFtZSA9ICd3cDhSZWdpc3RyYXRpb25TdWNjZXNzQ2FsbGJhY2tfJyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja05hbWUgPSAnd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja18nICsgc3VmZml4O1xuXG4gICAgICAgICAgICAgICAgRXZlcmxpdmUuUHVzaENhbGxiYWNrc1t3cDhDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX29uTm90aWZpY2F0aW9uV1A4LCB0aGlzKTtcbiAgICAgICAgICAgICAgICBFdmVybGl2ZS5QdXNoQ2FsbGJhY2tzW3dwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3NXUCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgRXZlcmxpdmUuUHVzaENhbGxiYWNrc1t3cDhSZWdpc3RyYXRpb25FcnJvckNhbGxiYWNrTmFtZV0gPSBfLmJpbmQodGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkLCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vQ29uc3RydWN0IHJlZ2lzdHJhdGlvbiBvcHRpb25zIG9iamVjdCBhbmQgdmFsaWRhdGUgdGhlIFdQOCAgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uT3B0aW9ucyA9IHRoaXMucHVzaFNldHRpbmdzLndwODtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVdQOFNldHRpbmdzKHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOENhbGxiYWNrTmFtZTtcbiAgICAgICAgICAgICAgICB3cDhSZWdpc3RyYXRpb25PcHRpb25zLnVjY2IgPSAnRXZlcmxpdmUuUHVzaENhbGxiYWNrcy4nICsgd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrTmFtZTtcbiAgICAgICAgICAgICAgICB3cDhSZWdpc3RyYXRpb25PcHRpb25zLmVycmNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOFJlZ2lzdHJhdGlvbkVycm9yQ2FsbGJhY2tOYW1lO1xuXG5cbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25XUDgsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZXJyb3JTZW50UmVnaXN0cmF0aW9uV1A4LCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBjdXJyZW50IHBsYXRmb3JtIGlzIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkZXZpY2UucGxhdGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzV1A6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MocmVzdWx0LnVyaSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3ZhbGlkYXRlQW5kcm9pZFNldHRpbmdzOiBmdW5jdGlvbiAoYW5kcm9pZFNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoIWFuZHJvaWRTZXR0aW5ncy5zZW5kZXJJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZW5kZXIgSUQgKHByb2plY3QgbnVtYmVyKSBpcyBub3Qgc2V0IGluIHRoZSBhbmRyb2lkIHNldHRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVXUDhTZXR0aW5nczogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ2NoYW5uZWxOYW1lIGlzIG5vdCBzZXQgaW4gdGhlIFdQOCBzZXR0aW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdmFsaWRhdGVJT1NTZXR0aW5nczogZnVuY3Rpb24gKGlPU1NldHRpbmdzKSB7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYW5QbGF0Zm9ybXNQdXNoU2V0dGluZ3M6IGZ1bmN0aW9uIChwdXNoU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBjbGVhblNldHRpbmdzID0ge307XG4gICAgICAgICAgICBwdXNoU2V0dGluZ3MgPSBwdXNoU2V0dGluZ3MgfHwge307XG5cbiAgICAgICAgICAgIHZhciBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtID0gZnVuY3Rpb24gYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShuZXdTZXR0aW5nc09iamVjdCwgcGxhdGZvcm0sIGFsbG93ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXB1c2hTZXR0aW5nc1twbGF0Zm9ybV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXSA9IG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGxhdGZvcm1TZXR0aW5ncyA9IHB1c2hTZXR0aW5nc1twbGF0Zm9ybV07XG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gbmV3U2V0dGluZ3NPYmplY3RbcGxhdGZvcm1dO1xuICAgICAgICAgICAgICAgIF8uZWFjaChhbGxvd2VkRmllbGRzLCBmdW5jdGlvbiAoYWxsb3dlZEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdQbGF0Zm9ybVNldHRpbmdzLmhhc093blByb3BlcnR5KGFsbG93ZWRGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2FsbG93ZWRGaWVsZF0gPSBuZXdQbGF0Zm9ybVNldHRpbmdzW2FsbG93ZWRGaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0oY2xlYW5TZXR0aW5ncywgJ2lPUycsIFsnYmFkZ2UnLCAnc291bmQnLCAnYWxlcnQnLCAnaW50ZXJhY3RpdmVTZXR0aW5ncyddKTtcbiAgICAgICAgICAgIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0oY2xlYW5TZXR0aW5ncywgJ2FuZHJvaWQnLCBbJ3NlbmRlcklEJywgJ3Byb2plY3ROdW1iZXInXSk7XG4gICAgICAgICAgICBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKGNsZWFuU2V0dGluZ3MsICd3cDgnLCBbJ2NoYW5uZWxOYW1lJ10pO1xuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tGaWVsZHMgPSBbJ25vdGlmaWNhdGlvbkNhbGxiYWNrQW5kcm9pZCcsICdub3RpZmljYXRpb25DYWxsYmFja0lPUycsICdub3RpZmljYXRpb25DYWxsYmFja1dQOCddO1xuICAgICAgICAgICAgXy5lYWNoKGNhbGxiYWNrRmllbGRzLCBmdW5jdGlvbiAoY2FsbGJhY2tGaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHB1c2hTZXR0aW5nc1tjYWxsYmFja0ZpZWxkXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBcIicgKyBjYWxsYmFja0ZpZWxkICsgJ1wiIG9mIHRoZSBwdXNoIHNldHRpbmdzIHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjbGVhblNldHRpbmdzW2NhbGxiYWNrRmllbGRdID0gcHVzaFNldHRpbmdzW2NhbGxiYWNrRmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocHVzaFNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBjbGVhblNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnMgPSBwdXNoU2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsZWFuU2V0dGluZ3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0OiBmdW5jdGlvbiAoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYucHVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignUHVzaCB0b2tlbiBpcyBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2V0TG9jYWxlTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGV2aWNlSWQgPSBzZWxmLl9nZXREZXZpY2VJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXJkd2FyZU1vZGVsID0gZGV2aWNlLm1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBzZWxmLl9nZXRQbGF0Zm9ybVR5cGUoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVpvbmUgPSBqc3R6LmRldGVybWluZSgpLm5hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVzaFRva2VuID0gc2VsZi5wdXNoVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gbG9jYWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVZlcnNpb24gPSBkZXZpY2UudmVyc2lvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkhhcmR3YXJlTW9kZWwgPSBoYXJkd2FyZU1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QbGF0Zm9ybVR5cGUgPSBwbGF0Zm9ybVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBsYXRmb3JtVmVyc2lvbiA9IHBsYXRmb3JtVmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uVGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUHVzaFRva2VuID0gcHVzaFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5Mb2NhbGUgPSBsYW5ndWFnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0TG9jYWxlTmFtZTogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbXVsYXRvck1vZGUpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHt2YWx1ZTogJ2VuX1VTJ30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbi5nZXRMb2NhbGVOYW1lKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbi5nZXRMb2NhbGVOYW1lKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0RGV2aWNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2UudXVpZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvL1JldHVybnMgdGhlIEV2ZXJsaXZlIGRldmljZSBwbGF0Zm9ybSBjb25zdGFudCBnaXZlbiBhIHZhbHVlIGFxdWlyZWQgZnJvbSBjb3Jkb3ZhJ3MgZGV2aWNlLnBsYXRmb3JtLlxuICAgICAgICBfZ2V0UGxhdGZvcm1UeXBlOiBmdW5jdGlvbiAocGxhdGZvcm1TdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBwc0xvd2VyID0gcGxhdGZvcm1TdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHNMb3dlcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2lvcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaXBob25lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcGFkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLmlPUztcbiAgICAgICAgICAgICAgICBjYXNlICdhbmRyb2lkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLkFuZHJvaWQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2luY2UnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uV2luZG93c1Bob25lO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbjMybnQnOiAvLyByZWFsIHdwOCBkZXZpY2VzIHJldHVybiB0aGlzIHN0cmluZyBhcyBwbGF0Zm9ybSBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uV2luZG93c1Bob25lO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5Vbmtub3duO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQ6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbml0RXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrKHtlcnJvcjogZXJyb3J9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2VzczogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3VjY2Vzc0NhbGxiYWNrKHt0b2tlbjogdG9rZW59KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvL09jY3VycyB3aGVuIHRoZSBkZXZpY2UgcmVnaXN0cmF0aW9uIGluIEFQTiBzdWNjZWVkc1xuICAgICAgICBfc3VjY2Vzc2Z1bFJlZ2lzdHJhdGlvbkFQTjogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3MuaU9TICYmIHRoaXMucHVzaFNldHRpbmdzLmlPUy5pbnRlcmFjdGl2ZVNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUludGVyYWN0aXZlUHVzaChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3MuaU9TLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBpbnRlcmFjdGl2ZSBwdXNoIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0OiAnICsgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3ModG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vT2NjdXJzIGlmIHRoZSBkZXZpY2UgcmVnaXN0cmF0aW9uIGluIEFQTiBmYWlsc1xuICAgICAgICBfZmFpbGVkUmVnaXN0cmF0aW9uQVBOOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9PY2N1cnMgd2hlbiBkZXZpY2UgcmVnaXN0cmF0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50IHRvIEdDTVxuICAgICAgICBfc3VjY2Vzc1NlbnRSZWdpc3RyYXRpb25HQ006IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBzZW50IHJlcXVlc3QgZm9yIHJlZ2lzdGVyaW5nIHdpdGggR0NNLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBkZXZpY2UgcmVnaXN0cmF0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzZW50IGZvciBXUDhcbiAgICAgICAgX3N1Y2Nlc3NTZW50UmVnaXN0cmF0aW9uV1A4OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgc2VudCByZXF1ZXN0IGZvciByZWdpc3RlcmluZyBXUDggLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBhbiBlcnJvciBvY2N1cmVkIHdoZW4gc2VuZGluZyByZWdpc3RyYXRpb24gcmVxdWVzdCBmb3IgV1A4XG4gICAgICAgIF9lcnJvclNlbnRSZWdpc3RyYXRpb25XUDg6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkKGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL09jY3VycyB3aGVuIGFuIGVycm9yIG9jY3VyZWQgd2hlbiBzZW5kaW5nIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IHRvIEdDTVxuICAgICAgICBfZXJyb3JTZW50UmVnaXN0cmF0aW9uR0NNOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gQVBOXG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbkFQTjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRJT1MoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vVGhpcyBmdW5jdGlvbiByZWNlaXZlcyBhbGwgbm90aWZpY2F0aW9uIGV2ZW50cyBmb3IgV1A4XG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbldQODogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRXUDgoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9UaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIGFsbCBub3RpZmljYXRpb24gZXZlbnRzIGZyb20gR0NNXG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbkdDTTogZnVuY3Rpb24gb25Ob3RpZmljYXRpb25HQ00oZSkge1xuICAgICAgICAgICAgc3dpdGNoIChlLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnaXN0ZXJlZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlZ2lkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MoZS5yZWdpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wdXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRBbmRyb2lkKGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudElPUzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0lPUykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudFdQODogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja1dQOCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBDdXJyZW50RGV2aWNlO1xufSgpKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KG9iaikge1xuICAgIG9iai5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIG9iai5fZW1pdHRlclByb3h5ID0gZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XG4gICAgICAgIG9iai5fZW1pdHRlcltldmVudF0uYXBwbHkob2JqLl9lbWl0dGVyLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgb2JqLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYmouX2VtaXR0ZXJQcm94eSgnYWRkTGlzdGVuZXInLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBvYmoub24gPSBvYmouYWRkTGlzdGVuZXI7XG5cbiAgICBvYmoucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iai5fZW1pdHRlclByb3h5KCdyZW1vdmVMaXN0ZW5lcicsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIG9iai5vZmYgPSBvYmoucmVtb3ZlTGlzdGVuZXI7XG5cbiAgICBvYmoub25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JqLl9lbWl0dGVyUHJveHkoJ29uY2UnLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBvYmoucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYmouX2VtaXR0ZXJQcm94eSgncmVtb3ZlQWxsTGlzdGVuZXJzJywgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXBwbHk6IGFwcGx5XG59OyIsInZhciBTZXR1cCA9IHJlcXVpcmUoJy4vU2V0dXAnKTtcbnZhciBEYXRhID0gcmVxdWlyZSgnLi90eXBlcy9EYXRhJyk7XG52YXIgdXNlcnNNb2R1bGUgPSByZXF1aXJlKCcuL3R5cGVzL1VzZXJzJyk7XG52YXIgZmlsZXNNb2R1bGUgPSByZXF1aXJlKCcuL3R5cGVzL0ZpbGVzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBidWlsZEF1dGhIZWFkZXIgPSB1dGlscy5idWlsZEF1dGhIZWFkZXI7XG52YXIgUHVzaCA9IHJlcXVpcmUoJy4vUHVzaCcpO1xudmFyIEF1dGhlbnRpY2F0aW9uID0gcmVxdWlyZSgnLi9hdXRoL0F1dGhlbnRpY2F0aW9uJyk7XG52YXIgb2ZmbGluZU1vZHVsZSA9IHJlcXVpcmUoJy4vb2ZmbGluZS9vZmZsaW5lJyk7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xudmFyIF8gPSBjb21tb24uXztcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3JzO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvaGVscGVycycpO1xudmFyIEV2ZW50RW1pdHRlclByb3h5ID0gcmVxdWlyZSgnLi9FdmVudEVtaXR0ZXJQcm94eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3Igb2YgRXZlcmxpdmUgaW5zdGFuY2VzLlxuICAgIC8vIFRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFNESy5cblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBFdmVybGl2ZVxuICAgICAqIEBjbGFzc2Rlc2MgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB7e3NpdGUuYnN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLLiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFNESy5cbiAgICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBTZXR1cCBvYmplY3QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gcGFzcyBhIHN0cmluZyByZXByZXNlbnRpbmcgeW91ciBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFwaUtleSAtIFlvdXIgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXJsPS8vYXBpLmV2ZXJsaXZlLmNvbS92MS9dIC0gVGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gVVJMLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b2tlbl0gLSBBbiBhdXRoZW50aWNhdGlvbiB0b2tlbi4gVGhlIGluc3RhbmNlIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwcmV2aW91c2x5IG9idGFpbmVkIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b2tlblR5cGU9YmVhcmVyXSAtIFRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0aGF0IGlzIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY2hlbWU9aHR0cF0gLSBUaGUgVVJJIHNjaGVtZSB1c2VkIHRvIG1ha2UgcmVxdWVzdHMuIFN1cHBvcnRlZCB2YWx1ZXM6IGh0dHAsIGh0dHBzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cz1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIFNESyB3aWxsIHBhcnNlIG9ubHkgY29tcGxldGUgZGF0ZSBzdHJpbmdzIChhY2NvcmRpbmcgdG8gdGhlIElTTyA4NjAxIHN0YW5kYXJkKS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVtdWxhdG9yTW9kZT1mYWxzZV0gLSBTZXQgdGhpcyBvcHRpb24gdG8gdHJ1ZSB0byBzZXQgdGhlIFNESyBpbiBlbXVsYXRvciBtb2RlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlXSAtIFNldCB0aGlzIG9wdGlvbiB0byB0cnVlIHRvIHVzZSB0aGUgZGVmYXVsdCBvZmZsaW5lIHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuaXNPbmxpbmU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBzdG9yYWdlIGlzIGluIG9ubGluZSBtb2RlIGluaXRpYWxseS5cbiAgICAgKiBAcGFyYW0ge0NvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5fGZ1bmN0aW9ufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5jb25mbGljdHMuc3RyYXRlZ3k9Q29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2luc10gLSBBIGNvbnN0YW50IHNwZWNpZnlpbmcgdGhlIGNvbmZsaWN0IHJlc29sdXRpb24gc3RyYXRlZ3kgb3IgYSBmdW5jdGlvbiB1c2VkIHRvIHJlc29sdmUgdGhlIGNvbmZsaWN0cy5cbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2VQcm92aWRlcnxvYmplY3R9IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLnN0b3JhZ2UucHJvdmlkZXI9U3RvcmFnZVByb3ZpZGVyLkxvY2FsU3RvcmFnZV0gLSBBbiBvYmplY3Qgc3BlY2lmeWluZyBzZXR0aW5ncyBmb3IgdGhlIG9mZmxpbmUgc3RvcmFnZSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2Uuc3RvcmFnZS5zdG9yYWdlUGF0aD1lbF9zdG9yZV0gLSBBIHJlbGF0aXZlIHBhdGggc3BlY2lmeWluZyB3aGVyZSB0aGUgZmlsZXMgd2lsbCBiZSBzYXZlZCBpZiBmaWxlIHN5c3RlbSBpcyB1c2VkIGZvciBwZXJzaXN0ZW5jZSBmb3IgaXRlbSBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2Uuc3RvcmFnZS5yZXF1ZXN0ZWRRdW90YT0xMDQ4NTc2MF0gLSBIb3cgbXVjaCBtZW1vcnkgKGluIGJ5dGVzKSB0byBiZSByZXF1ZXN0ZWQgd2hlbiB1c2luZyB0aGUgZmlsZSBzeXN0ZW0gZm9yIHBlcnNpc3RlbmNlLiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBDaHJvbWUgYXMgdGhlIG90aGVyIHBsYXRmb3JtcyB1c2UgYWxsIHRoZSBhdmFpbGFibGUgc3BhY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLmVuY3J5cHRpb24ua2V5XSAtIEEga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEgc3RvcmVkIG9mZmxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLmZpbGVzLnN0b3JhZ2VQYXRoPWVsX2ZpbGVfc3RvcmVdIC0gQSByZWxhdGl2ZSBwYXRoIHNwZWNpZnlpbmcgd2hlcmUgdGhlIGZpbGVzIHdpbGwgYmUgc2F2ZWQgaWYgZmlsZSBzeXN0ZW0gaXMgdXNlZCBmb3IgcGVyc2lzdGVuY2Ugb2YgZmlsZXMgaW4gb2ZmbGluZSBtb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5maWxlcy5tZXRhUGF0aD1lbF9maWxlX21hcHBpbmddIC0gQSByZWxhdGl2ZSBwYXRoIHNwZWNpZnlpbmcgd2hlcmUgdGhlIG1ldGFkYXRhIGZpbGUgd2lsbCBiZSBzYXZlZCBpZiBmaWxlIHN5c3RlbSBpcyB1c2VkIGZvciBwZXJzaXN0ZW5jZSBvZiBmaWxlcyBpbiBvZmZsaW5lIG1vZGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuZmlsZXNdIC0gU2V0IHRoaXMgb3B0aW9uIHRvIHRydWUgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIGZpbGVzIGluIG9mZmxpbmUgbW9kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dGhlbnRpY2F0aW9uLnBlcnNpc3Q9ZmFsc2VdIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlcidzIGF1dGhlbnRpY2F0aW9uIHdpbGwgYmUgcGVyc2lzdGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmF1dGhlbnRpY2F0aW9uLm9uQXV0aGVudGljYXRpb25SZXF1aXJlZF0gLSBJbnZva2VkIHdoZW4gdGhlIHVzZXIncyBjcmVkZW50aWFscyBoYXZlIGV4cGlyZWQuIEFsbG93aW5nIHlvdSB0byBwZXJmb3JtIGN1c3RvbSBsb2dpYy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVscGVyc10gLSBBbiBvYmplY3QgaG9sZGluZyBvcHRpb25zIGZvciBhbGwgRXZlcmxpdmUgaGVscGVyIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbF0gLSBIVE1MIEhlbHBlciBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwucHJvY2Vzc09uTG9hZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHByb2Nlc3MgYWxsIEhUTUwgZWxlbWVudHMgd2hlbiB0aGUgd2luZG93IGxvYWRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGVscGVycy5odG1sLnByb2Nlc3NPblJlc2l6ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHByb2Nlc3MgYWxsIEhUTUwgZWxlbWVudHMgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5sb2FkaW5nSW1hZ2VVcmxdIC0gVGhlIGltYWdlIHRvIGJlIGRpc3BsYXllZCB3aGlsZSB0aGUgb3JpZ2luYWwgaW1hZ2UgaXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuZXJyb3JJbWFnZVVybF0gLSBUaGUgaW1hZ2UgdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG9yaWdpbmFsIGltYWdlIHByb2Nlc3NpbmcgZmFpbHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzXSAtIEhUTUwgSGVscGVyIGF0dHJpYnV0ZXMgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzLmxvYWRpbmdJbWFnZT1kYXRhLWxvYWRpbmctaW1hZ2VdIC0gQSBjdXN0b20gbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZSB0byBiZSB1c2VkIHRvIHNldCBhIGxvYWRpbmcgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzLmVycm9ySW1hZ2U9ZGF0YS1lcnJvci1pbWFnZV0gLSBBIGN1c3RvbSBuYW1lIGZvciB0aGUgYXR0cmlidXRlIHRvIGJlIHVzZWQgdG8gc2V0IGFuIGVycm9yIGltYWdlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuYXR0cmlidXRlcy5kcGk9ZGF0YS1kcGldIC0gQSBjdXN0b20gbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZSB0byBiZSB1c2VkIHRvIHNwZWNpZnkgRFBJIHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5oZWxwZXJzLmh0bWwuYXR0cmlidXRlcy5pbWFnZVNvdXJjZT1kYXRhLXNyY10gLSBBIGN1c3RvbSBuYW1lIGZvciB0aGUgYXR0cmlidXRlIHRvIGJlIHVzZWQgdG8gc2V0IHRoZSBpbWFnZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzLmZpbGVTb3VyY2U9ZGF0YS1ocmVmXSAtIEEgY3VzdG9tIG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUgdG8gYmUgdXNlZCB0byBzZXQgdGhlIGFuY2hvciBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlbHBlcnMuaHRtbC5hdHRyaWJ1dGVzLmVuYWJsZU9mZmxpbmU9ZGF0YS1vZmZsaW5lXSAtIEEgY3VzdG9tIG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUgdG8gYmUgdXNlZCB0byBjb250cm9sIG9mZmxpbmUgcHJvY2Vzc2luZy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVscGVycy5odG1sLmF0dHJpYnV0ZXMuZW5hYmxlUmVzcG9uc2l2ZT1kYXRhLXJlc3BvbnNpdmVdIC0gQSBjdXN0b20gbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZSB0byBiZSB1c2VkIHRvIGNvbnRyb2wgUmVzcG9uc2l2ZSBJbWFnZXMgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVybGl2ZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXR1cCA9IG5ldyBTZXR1cChvcHRpb25zKTtcbiAgICAgICAgXy5lYWNoKGluaXRpYWxpemF0aW9ucywgZnVuY3Rpb24gKGluaXQpIHtcbiAgICAgICAgICAgIGluaXQuZnVuYy5jYWxsKHNlbGYsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoRXZlcmxpdmUuJCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgRXZlcmxpdmUuJCA9IHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudEVtaXR0ZXJQcm94eS5hcHBseSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBTREsuXG4gICAgICogQG1ldGhvZCBhZGRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHdoaWNoIHRvIHN1YnNjcmliZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudExpc3RlbmVyIEFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHJhaXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBTREsuXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHdoaWNoIHRvIHN1YnNjcmliZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudExpc3RlbmVyIEFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoIHdpbGwgYmUgY2FsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHJhaXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIFNESyBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAbWV0aG9kIHJlbW92ZUxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50TGlzdGVuZXIgVGhlIGV2ZW50IGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIFNESyBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50TGlzdGVuZXJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBTREsgd2hpY2ggd2lsbCBiZSBjYWxsZWQgb25seSB0aGUgZmlyc3QgdGltZSB0aGUgZXZlbnQgaXMgZW1pdHRlZC5cbiAgICAgKiBAbWV0aG9kIG9uY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB3aGljaCB0byBzdWJzY3JpYmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRMaXN0ZW5lciBBbiBldmVudCBsaXN0ZW5lciB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbmNlIHRoZSBldmVudCBpcyByYWlzZWQuXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgU0RLIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCByZW1vdmVBbGxMaXN0ZW5lcnNcbiAgICAgKi9cblxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLLlxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxuICAgICAqIEB0eXBlIHtFdmVybGl2ZX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgRXZlcmxpdmUuJCA9IG51bGw7XG4gICAgRXZlcmxpdmUuaWRGaWVsZCA9IGNvbnN0YW50cy5pZEZpZWxkO1xuXG5cbiAgICAvLyBBbiBhcnJheSBrZWVwaW5nIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9ucyBjYWxsZWQgYnkgdGhlIEV2ZXJsaXZlIGNvbnN0cnVjdG9yLlxuICAgIC8vIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIEV2ZXJsaXZlIGluc3RhbmNlLlxuICAgIHZhciBpbml0aWFsaXphdGlvbnMgPSBbXTtcblxuICAgIC8qKiBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgaW52b2tlZCBkdXJpbmcgaW5zdGFudGlhdGlvbiBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLLlxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbltdfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZXJsaXZlLmluaXRpYWxpemF0aW9ucyA9IGluaXRpYWxpemF0aW9ucztcblxuICAgIEV2ZXJsaXZlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBFdmVybGl2ZS4kID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVybGl2ZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgRGF0YX0gY2xhc3MuXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZSBUaGUgbmFtZSBvZiB0aGUgY29sbGVjdGlvbiB0byBiZSB1c2VkLlxuICAgICAqIEByZXR1cm5zIHtEYXRhfVxuICAgICAqL1xuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YSh0aGlzLnNldHVwLCBjb2xsZWN0aW9uTmFtZSwgdGhpcy5vZmZsaW5lU3RvcmFnZSwgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCB0byB0aGUge3tzaXRlLmJzfX0gYXBwbGljYXRpb24gZW5kcG9pbnQgdGhhdCB0aGUgU0RLIHVzZXMuXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgYnVpbGRVcmxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZ2VuZXJhdGVkIFVSTC5cbiAgICAgKi9cbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYnVpbGRVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFVybCh0aGlzLnNldHVwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlcnMgdGhhdCBhcmUgdXNlZCBieSB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLIHRvIG1ha2UgcmVxdWVzdHMgdG8gdGhlIHt7c2l0ZS5ic319IHNlcnZlcnMuXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXG4gICAgICogQHJldHVybnMge09iamVjdH0gQXV0aG9yaXphdGlvbkhlYWRlcnMgVGhlIGdlbmVyYXRlZCBBdXRob3JpemF0aW9uIGhlYWRlcnMgb2JqZWN0LlxuICAgICAqL1xuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5idWlsZEF1dGhIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBidWlsZEF1dGhIZWFkZXIodGhpcy5zZXR1cCk7XG4gICAgfTtcblxuICAgIEV2ZXJsaXZlLmRpc2FibGVSZXF1ZXN0Q2FjaGUgPSB1dGlscy5kaXNhYmxlUmVxdWVzdENhY2hlO1xuXG4gICAgRXZlcmxpdmUuQXV0aFN0YXR1cyA9IGNvbnN0YW50cy5BdXRoU3RhdHVzO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgYXV0aEluZm9cbiAgICAgKiBAbmFtZSBhdXRoSW5mb1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSB7QGxpbmsgQXV0aGVudGljYXRpb24uZ2V0QXV0aGVudGljYXRpb25TdGF0dXN9XG4gICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0byB0aGUgYXV0aGVudGljYXRpb24gc3RhdHVzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gc3RhdHVzIG9mIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGF1dGhJbmZvXG4gICAgICogQG5hbWUgYXV0aEluZm9cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzZWUge0BsaW5rIEF1dGhlbnRpY2F0aW9uLmdldEF1dGhlbnRpY2F0aW9uU3RhdHVzfVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuYXV0aEluZm8gPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNldHVwID0gc2VsZi5zZXR1cDtcbiAgICAgICAgICAgIGlmIChzZXR1cC5tYXN0ZXJLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLm1hc3RlcktleX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNldHVwLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy51bmF1dGhlbnRpY2F0ZWR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuYXV0aGVudGljYXRpb24gJiYgc2VsZi5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGluZ30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLlVzZXJzXG4gICAgICAgICAgICAgICAgLnNraXBBdXRoKHRydWUpXG4gICAgICAgICAgICAgICAgLmN1cnJlbnRVc2VyKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IEV2ZXJsaXZlLkF1dGhTdGF0dXMuYXV0aGVudGljYXRlZCwgdXNlcjogcmVzLnJlc3VsdH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYXV0aGVudGljYXRpb24gJiYgc2VsZi5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmludmFsaWRSZXF1ZXN0LmNvZGUgfHwgZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmV4cGlyZWRUb2tlbi5jb2RlKSB7IC8vIGludmFsaWQgcmVxdWVzdCwgaS5lLiB0aGUgYWNjZXNzIHRva2VuIGlzIGludmFsaWQgb3IgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogRXZlcmxpdmUuQXV0aFN0YXR1cy5pbnZhbGlkQXV0aGVudGljYXRpb259KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIHJlcXVlc3QgdG8gdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXG4gICAgICogQG1ldGhvZCByZXF1ZXN0XG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9iamVjdCB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZW5kcG9pbnRdIFRoZSBlbmRwb2ludCBvZiB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBBUEkgcmVsYXRpdmUgdG8gdGhlIEFQSSBrZXkgc2VjdGlvbi4gKEZvciBleGFtcGxlLCBvcHRpb25zLmVuZHBvaW50ID0gTXlUeXBlIHdpbGwgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIE15VHlwZSB0eXBlLilcbiAgICAgKiBAcGFyYW0ge0h0dHBNZXRob2R9IFtvcHRpb25zLm1ldGhvZF0gSFRUUCByZXF1ZXN0IG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZGF0YV0gRGF0YSB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc10gU3VjY2VzcyBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMgc3VjY2Vzc2Z1bGx5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSBFcnJvciBjYWxsYmFjayB0byBiZSBjYWxsZWQgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyc10gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7UXVlcnl8b2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJdIFRoaXMgaXMgZWl0aGVyIGEge0BsaW5rIFF1ZXJ5fSBvciBhIFtmaWx0ZXJdKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBleHByZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0aEhlYWRlcnM9dHJ1ZV0gV2hlbiBzZXQgdG8gZmFsc2UsIG5vIEF1dGhvcml6YXRpb24gaGVhZGVycyB3aWxsIGJlIHNlbnQgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IFRoZSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzZW5kYCBmdW5jdGlvbiB0aGF0IHNlbmRzIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMuc2V0dXAsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcm90ZWN0T2ZmbGluZUVuYWJsZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1lvdSBoYXZlIGluc3RhbnRpYXRlZCB0aGUgU0RLIHdpdGhvdXQgc3VwcG9ydCBmb3Igb2ZmbGluZSBzdG9yYWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNldHVwLm9mZmxpbmVTdG9yYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBTREsgdG8gd29yayBpbiBvZmZsaW5lIG1vZGUuXG4gICAgICogQG1ldGhvZCBvZmZsaW5lXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzT2ZmbGluZSA9IHRydWVdIEJvb2xlYW4gcGFyYW1ldGVyIGZvciBzZXR0aW5nIHRoZSBTREsgdG8gb25saW5lIG9yIG9mZmxpbmUgbW9kZS5cbiAgICAgKi9cbiAgICBFdmVybGl2ZS5wcm90b3R5cGUub2ZmbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGlzT2ZmbGluZTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlzT2ZmbGluZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc09mZmxpbmUgPSBhcmd1bWVudHNbMF0gPT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlLl9zZXRPZmZsaW5lKGlzT2ZmbGluZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFNESyB0byB3b3JrIGluIG9ubGluZSBtb2RlLlxuICAgICAqIEBtZXRob2Qgb25saW5lXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzT25saW5lID0gdHJ1ZV0gQm9vbGVhbiBwYXJhbWV0ZXIgZm9yIHNldHRpbmcgdGhlIFNESyB0byBvbmxpbmUgb3Igb2ZmbGluZSBtb2RlLlxuICAgICAqL1xuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5vbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb3RlY3RPZmZsaW5lRW5hYmxlZC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBpc09ubGluZTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlzT25saW5lID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzT25saW5lID0gYXJndW1lbnRzWzBdID09IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZsaW5lU3RvcmFnZS5fc2V0T2ZmbGluZSghaXNPbmxpbmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgU0RLIGlzIGluIG9mZmxpbmUgbW9kZS5cbiAgICAgKiBAbWV0aG9kIGlzT2ZmbGluZVxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBTREsgaXMgaW4gb2ZmbGluZSBtb2RlLlxuICAgICAqL1xuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5pc09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb3RlY3RPZmZsaW5lRW5hYmxlZC5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNPbmxpbmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIFNESyBpcyBpbiBvbmxpbmUgbW9kZS5cbiAgICAgKiBAbWV0aG9kIGlzT25saW5lXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIFNESyBpcyBpbiBvbmxpbmUgbW9kZS5cbiAgICAgKi9cbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb3RlY3RPZmZsaW5lRW5hYmxlZC5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIHN5bmNocm9uaXphdGlvbiBwcm9jZWR1cmUuIEVtaXRzIHRoZSAnc3luY1N0YXJ0JyBldmVudCB3aGVuIHN0YXJ0ZWQgYW5kIHRoZSAnc3luY0VuZCcgZXZlbnQgd2hlbiB0aGUgcHJvY2VkdXJlIGZpbmlzaGVzLiAnc3luY0VuZCcgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbXBsZXRlZCBzeW5jIG9wZXJhdGlvbiB0aGF0IHlvdSBjYW4gdXNlIHRvIGZpbmQgb3V0IGhvdyBtYW55IGl0ZW1zIHdlcmUgc3luY2hyb25pemVkLlxuICAgICAqIEBtZXRob2Qgc3luY1xuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLnN5bmMuYXBwbHkodGhpcy5vZmZsaW5lU3RvcmFnZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgdmFyIGluaXREZWZhdWx0ID0gZnVuY3Rpb24gaW5pdERlZmF1bHQoKSB7XG4gICAgICAgIHZhciB1c2VycyA9IHRoaXMuZGF0YSgnVXNlcnMnKTtcbiAgICAgICAgdXNlcnNNb2R1bGUuYWRkVXNlcnNGdW5jdGlvbnModXNlcnMsIHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEV2ZXJsaXZlLnVzZXJzfVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtVc2Vyc117QGxpbmsgVXNlcnN9IGNsYXNzIGZvciB3b3JraW5nIHdpdGggdXNlcnMuXG4gICAgICAgICAqIEBtZW1iZXIge1VzZXJzfSBVc2Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5Vc2VycyA9IHVzZXJzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbnN0YW5jZSBvZiB0aGUgW1VzZXJzXXtAbGluayBVc2Vyc30gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB1c2Vycy5cbiAgICAgICAgICogQG1lbWJlciB7VXNlcnN9IHVzZXJzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJzID0gdXNlcnM7XG5cbiAgICAgICAgdmFyIGZpbGVzID0gdGhpcy5kYXRhKCdGaWxlcycpO1xuICAgICAgICBmaWxlc01vZHVsZS5hZGRGaWxlc0Z1bmN0aW9ucyhmaWxlcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGV2ZXJsaXZlLmZpbGVzIGluc3RlYWRcbiAgICAgICAgICogQHNlZSB7QGxpbmsgRXZlcmxpdmUuZmlsZXN9XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbnN0YW5jZSBvZiB0aGUgW0ZpbGVzXXtAbGluayBGaWxlc30gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBmaWxlcy5cbiAgICAgICAgICogQG1lbWJlciB7RmlsZXN9IEZpbGVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLkZpbGVzID0gZmlsZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbRmlsZXNde0BsaW5rIEZpbGVzfSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIGZpbGVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtGaWxlc30gZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtQdXNoXXtAbGluayBQdXNofSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHB1c2ggbm90aWZpY2F0aW9ucy5cbiAgICAgICAgICogQG1lbWJlciB7UHVzaH0gcHVzaFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdXNoID0gbmV3IFB1c2godGhpcyk7XG4gICAgfTtcblxuICAgIHZhciBpbml0QXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiBpbml0QXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbnN0YW5jZSBvZiB0aGUgW0F1dGhlbnRpY2F0aW9uXXtAbGluayBBdXRoZW50aWNhdGlvbn0gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gb2YgdGhlIFNESy5cbiAgICAgICAgICogQG1lbWJlciB7QXV0aGVudGljYXRpb259IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uID0gbmV3IEF1dGhlbnRpY2F0aW9uKHRoaXMsIHRoaXMuc2V0dXAuYXV0aGVudGljYXRpb24pO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdGlhbGl6ZUhlbHBlcnMgPSBmdW5jdGlvbiBpbml0aWFsaXplSGVscGVycyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5oZWxwZXJzID0ge307XG5cbiAgICAgICAgXy5lYWNoKGhlbHBlcnMsIGZ1bmN0aW9uIChoZWxwZXIpIHtcbiAgICAgICAgICAgIHZhciBoZWxwZXJPcHRpb25zID0gb3B0aW9ucy5oZWxwZXJzID8gb3B0aW9ucy5oZWxwZXJzW2hlbHBlci5uYW1lXSA6IG51bGw7XG4gICAgICAgICAgICBzZWxmLmhlbHBlcnNbaGVscGVyLm5hbWVdID0gbmV3IGhlbHBlci5jdG9yKHNlbGYsIGhlbHBlck9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdvZmZsaW5lU3RvcmFnZScsIGZ1bmM6IG9mZmxpbmVNb2R1bGUuaW5pdE9mZmxpbmVTdG9yYWdlfSk7XG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdkZWZhdWx0JywgZnVuYzogaW5pdERlZmF1bHR9KTtcbiAgICBpbml0aWFsaXphdGlvbnMucHVzaCh7bmFtZTogJ2F1dGhlbnRpY2F0aW9uJywgZnVuYzogaW5pdEF1dGhlbnRpY2F0aW9ufSk7XG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdoZWxwZXJzJywgZnVuYzogaW5pdGlhbGl6ZUhlbHBlcnN9KTtcblxuXG4gICAgcmV0dXJuIEV2ZXJsaXZlO1xufSgpKTtcbiIsInZhciBFdmVybGl2ZUVycm9ycyA9IHtcbiAgICBpdGVtTm90Rm91bmQ6IHtcbiAgICAgICAgY29kZTogODAxLFxuICAgICAgICBtZXNzYWdlOiAnSXRlbSBub3QgZm91bmQuJ1xuICAgIH0sXG4gICAgc3luY0NvbmZsaWN0OiB7XG4gICAgICAgIGNvZGU6IDEwMDAxLFxuICAgICAgICBtZXNzYWdlOiAnQSBjb25mbGljdCBvY2N1cnJlZCB3aGlsZSBzeW5jaW5nIGRhdGEuJ1xuICAgIH0sXG4gICAgc3luY0Vycm9yOiB7XG4gICAgICAgIGNvZGU6IDEwMDAyLFxuICAgICAgICBtZXNzYWdlOiAnU3luY2hyb25pemF0aW9uIGZhaWxlZCBmb3IgaXRlbS4nXG4gICAgfSxcbiAgICBzeW5jSW5Qcm9ncmVzczoge1xuICAgICAgICBjb2RlOiAxMDAwMyxcbiAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiB3aGlsZSBzeW5jaHJvbml6YXRpb24gaXMgaW4gcHJvZ3Jlc3MnXG4gICAgfSxcbiAgICBzeW5jQ2FuY2VsbGVkQnlVc2VyOiB7XG4gICAgICAgIGNvZGU6IDEwMDA0LFxuICAgICAgICBtZXNzYWdlOiAnU3luY2hyb25pemF0aW9uIGNhbmNlbGxlZCBieSB1c2VyJ1xuICAgIH0sXG4gICAgZ2VuZXJhbERhdGFiYXNlRXJyb3I6IHtcbiAgICAgICAgY29kZTogMTA3LFxuICAgICAgICBtZXNzYWdlOiAnR2VuZXJhbCBkYXRhYmFzZSBlcnJvcidcbiAgICB9LFxuICAgIGludmFsaWRUb2tlbjoge1xuICAgICAgICBjb2RlOiAzMDEsXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGFjY2VzcyB0b2tlbidcbiAgICB9LFxuICAgIGV4cGlyZWRUb2tlbjoge1xuICAgICAgICBjb2RlOiAzMDIsXG4gICAgICAgIG1lc3NhZ2U6ICdFeHBpcmVkIGFjY2VzcyB0b2tlbidcbiAgICB9LFxuICAgIGludmFsaWRFeHBhbmRFeHByZXNzaW9uOiB7XG4gICAgICAgIGNvZGU6IDYxOCxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZXhwYW5kIGV4cHJlc3Npb24uJ1xuICAgIH0sXG4gICAgaW52YWxpZFJlcXVlc3Q6IHtcbiAgICAgICAgY29kZTogNjAxLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXF1ZXN0LidcbiAgICB9LFxuICAgIG1pc3NpbmdDb250ZW50VHlwZToge1xuICAgICAgICBjb2RlOiA3MDEsXG4gICAgICAgIG1lc3NhZ2U6ICdDb250ZW50VHlwZSBub3Qgc3BlY2lmaWVkLidcbiAgICB9LFxuICAgIG1pc3NpbmdPckludmFsaWRGaWxlQ29udGVudDoge1xuICAgICAgICBjb2RlOiA3MDIsXG4gICAgICAgIG1lc3NhZ2U6ICdNaXNzaW5nIG9yIGludmFsaWQgZmlsZSBjb250ZW50LidcbiAgICB9LFxuICAgIGN1c3RvbUZpbGVTeW5jTm90U3VwcG9ydGVkOiB7XG4gICAgICAgIGNvZGU6IDcwMyxcbiAgICAgICAgbWVzc2FnZTogJ0N1c3RvbSBDb25mbGljdFJlc29sdXRpb24gZm9yIGZpbGVzIGlzIG5vdCBhbGxvd2VkJ1xuICAgIH0sXG4gICAgY2Fubm90RG93bmxvYWRPZmZsaW5lOiB7XG4gICAgICAgIGNvZGU6IDcwNCxcbiAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBkb3dubG9hZCBhIGZpbGUgd2hpbGUgb2ZmbGluZSdcbiAgICB9XG59O1xuXG52YXIgRXZlcmxpdmVFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlcmxpdmVFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHZhciB0bXBFcnJvciA9IEVycm9yLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgIHRtcEVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0bXBFcnJvci5jb2RlID0gY29kZSB8fCAwO1xuICAgICAgICB0bXBFcnJvci5uYW1lID0gdGhpcy5uYW1lID0gJ0V2ZXJsaXZlRXJyb3InO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRtcEVycm9yLm1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdGFjaycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXBFcnJvci5zdGFja1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBFdmVybGl2ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBFdmVybGl2ZUVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gRXZlcmxpdmVFcnJvcjtcbn0oKSk7XG5cbnZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yVHlwZSwgbWVzc2FnZSwgYWRkaXRpb25hbEluZm9ybWF0aW9uKSB7XG4gICAgICAgIEV2ZXJsaXZlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lcnJvclR5cGUgPSBlcnJvclR5cGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChhZGRpdGlvbmFsSW5mb3JtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZGRpdGlvbmFsSW5mb3JtYXRpb24gPSBhZGRpdGlvbmFsSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVybGl2ZUVycm9yLnByb3RvdHlwZSk7XG5cbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tRXZlcmxpdmVFcnJvciA9IGZ1bmN0aW9uIChldmVybGl2ZUVycm9yKSB7XG4gICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcihEZXZpY2VSZWdpc3RyYXRpb25FcnJvclR5cGVzLkV2ZXJsaXZlRXJyb3IsIGV2ZXJsaXZlRXJyb3IubWVzc2FnZSwgZXZlcmxpdmVFcnJvcik7XG4gICAgICAgIHJldHVybiBkZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcbiAgICB9O1xuXG4gICAgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IuZnJvbVBsdWdpbkVycm9yID0gZnVuY3Rpb24gKGVycm9yT2JqKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0EgcGx1Z2luIGVycm9yIG9jY3VycmVkJztcbiAgICAgICAgaWYgKGVycm9yT2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yT2JqLmVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvck9iai5lcnJvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yT2JqLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yT2JqLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IoRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JUeXBlcy5QbHVnaW5FcnJvciwgbWVzc2FnZSwgZXJyb3JPYmopO1xuICAgICAgICByZXR1cm4gZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XG4gICAgfTtcblxuICAgIHZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvclR5cGVzID0ge1xuICAgICAgICBFdmVybGl2ZUVycm9yOiAxLFxuICAgICAgICBQbHVnaW5FcnJvcjogMlxuICAgIH07XG5cbiAgICByZXR1cm4gRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFdmVybGl2ZUVycm9yOiBFdmVybGl2ZUVycm9yLFxuICAgIEV2ZXJsaXZlRXJyb3JzOiBFdmVybGl2ZUVycm9ycyxcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcjogRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3Jcbn07IiwidmFyIFByb2Nlc3NvciA9IHJlcXVpcmUoJy4vY29tbW9uJykuUHJvY2Vzc29yO1xudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5Jyk7XG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb2Nlc3Nvcih7XG4gICAgICAgIGV4ZWN1dGlvbk5vZGVGdW5jdGlvbjogZnVuY3Rpb24gKG5vZGUsIGV4cGFuZENvbnRleHQsIGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogbm9kZS50YXJnZXRUeXBlTmFtZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG5ldyBRdWVyeShub2RlLmZpbHRlciwgbm9kZS5zZWxlY3QsIG5vZGUuc29ydCwgbm9kZS5za2lwLCBub2RlLnRha2UpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZXhwYW5kQ29udGV4dC5vZmZsaW5lTW9kdWxlLnByb2Nlc3NRdWVyeShxdWVyeSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfSwgZG9uZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbihvcGVyYXRvciwgb3BlcmFuZHMpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLm9wZXJhbmRzID0gb3BlcmFuZHMgfHwgW107XG4gICAgfVxuXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFkZE9wZXJhbmQ6IGZ1bmN0aW9uIChvcGVyYW5kKSB7XG4gICAgICAgICAgICB0aGlzLm9wZXJhbmRzLnB1c2gob3BlcmFuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEV4cHJlc3Npb247XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvL1RPRE8gYWRkIGEgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBkaXN0YW5jZXMgaW4gZ2Vvc3BhdGlhbCBxdWVyaWVzXG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NkZXNjIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgdmFsdWUgZm9yIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEdlb1BvaW50IGZpZWxkLlxuICAgICAqIEBjbGFzcyBHZW9Qb2ludFxuICAgICAqIEBwYXJhbSBsb25naXR1ZGUgTG9uZ2l0dWRlIG9mIHRoZSBHZW9Qb2ludCBpbiBkZWNpbWFsIGRlZ3JlZXMgKHJhbmdlOiAtMTgwIHRvIDE4MCkuIEV4YW1wbGU6IGAxMjMuMzIzOTQ2N2BcbiAgICAgKiBAcGFyYW0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgdGhlIEdlb1BvaW50IGluIGRlY2ltYWwgZGVncmVlcyAocmFuZ2U6IC05MCB0byA5MCkuIEV4YW1wbGU6IGA0Mi42OTU0MzIyYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdlb1BvaW50KGxvbmdpdHVkZSwgbGF0aXR1ZGUpIHtcbiAgICAgICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGUgfHwgMDtcbiAgICAgICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlIHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIEdlb1BvaW50O1xufSgpKTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYnVpbGRQcm9taXNlID0gdXRpbHMuYnVpbGRQcm9taXNlO1xudmFyIERldmljZVJlZ2lzdHJhdGlvblJlc3VsdCA9IHV0aWxzLkRldmljZVJlZ2lzdHJhdGlvblJlc3VsdDtcbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJyk7XG52YXIgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkRldmljZVJlZ2lzdHJhdGlvbkVycm9yO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3I7XG52YXIgQ3VycmVudERldmljZSA9IHJlcXVpcmUoJy4vQ3VycmVudERldmljZScpO1xudmFyIFBsYXRmb3JtID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKS5QbGF0Zm9ybTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjbGFzcyBQdXNoXG4gICAgICogQGNsYXNzZGVzYyBBIGNsYXNzIGZvciBtYW5hZ2luZyBwdXNoIG5vdGlmaWNhdGlvbnMgaW4geW91ciBhcHBsaWNhdGlvbi4gU3VwcG9ydGVkIGFyZSBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIGh5YnJpZCBhcHBzIG9uIEFuZHJvaWQgYW5kIGlPUy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIGVsIHtFdmVybGl2ZX0gRXZlcmxpdmUgT2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gUHVzaChlbCkge1xuICAgICAgICB0aGlzLl9lbCA9IGVsO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBlbC5kYXRhKCdQdXNoL05vdGlmaWNhdGlvbnMnKTtcbiAgICAgICAgdGhpcy5kZXZpY2VzID0gZWwuZGF0YSgnUHVzaC9EZXZpY2VzJyk7XG4gICAgfVxuXG4gICAgUHVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgVGVsZXJpayBQdXNoIE5vdGlmaWNhdGlvbnMgcGx1Zy1pbiBoYXMgYmVlbiBsb2FkZWQgYW5kIGlzIHJlYWR5IHRvIHVzZS4gQW4ge0V2ZXJsaXZlRXJyb3J9IGlzIHJldHVybmVkIGlmIHRoZSBwbHVnLWluIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAqIEBtZXRob2QgZW5zdXJlUHVzaElzQXZhaWxhYmxlXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZW5zdXJlUHVzaElzQXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNQdXNoTm90aWZpY2F0aW9uUGx1Z2luQXZhaWxhYmxlID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wbHVnaW5zICYmIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoIWlzUHVzaE5vdGlmaWNhdGlvblBsdWdpbkF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKFwiVGhlIHB1c2ggbm90aWZpY2F0aW9uIHBsdWdpbiBpcyBub3QgYXZhaWxhYmxlLiBFbnN1cmUgdGhhdCB0aGUgcHVzaE5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgaW5jbHVkZWQgXCIgK1xuICAgICAgICAgICAgICAgIFwiYW5kIHVzZSBhZnRlciBgZGV2aWNlcmVhZHlgIGV2ZW50IGhhcyBiZWVuIGZpcmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBzZW5kaW5nIHB1c2ggbm90aWZpY2F0aW9uc1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMi43XG4gICAgICAgICAqIEBzZWUgW1B1c2gucmVnaXN0ZXJde0BsaW5rIHB1c2gucmVnaXN0ZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIGN1cnJlbnREZXZpY2VcbiAgICAgICAgICogQG5hbWUgY3VycmVudERldmljZVxuICAgICAgICAgKiBAcGFyYW0gW2VtdWxhdG9yTW9kZV0ge0Jvb2xlYW59IElmIHNldCB0byB0cnVlLCBlbXVsYXRvciBtb2RlIGlzIGVuYWJsZWQgbWVhbmluZyB5b3UgY2Fubm90IHNlbmQgcHVzaCBub3RpZmljYXRpb25zLlxuICAgICAgICAgKiBAcmV0dXJucyB7Q3VycmVudERldmljZX0gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDdXJyZW50RGV2aWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudERldmljZTogZnVuY3Rpb24gKGVtdWxhdG9yTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBlbXVsYXRvck1vZGUgPSB0aGlzLl9lbC5zZXR1cC5fZW11bGF0b3JNb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0Vycm9yOiBjdXJyZW50RGV2aWNlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgaHlicmlkIG1vYmlsZSBhcHAsIGFmdGVyIFxcJ2RldmljZXJlYWR5XFwnIGV2ZW50IGhhcyBiZWVuIGZpcmVkLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnREZXZpY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RGV2aWNlID0gbmV3IEN1cnJlbnREZXZpY2UodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnREZXZpY2UuZW11bGF0b3JNb2RlID0gZW11bGF0b3JNb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudERldmljZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgb24gdGhlIGRldmljZSBhbmQgcmVnaXN0ZXJzIGl0IGZvciB0aGUgZmVhdHVyZSB3aXRoIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLiBJZiBpdCBoYXMgYmVlbiByZWdpc3RlcmVkLCB0aGUgcmVnaXN0cmF0aW9uIGRldGFpbHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBBbiBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gSXQgY2FuIGluY2x1ZGUgY3VzdG9tIHBhcmFtZXRlcnMgdG8gYmUgc3RvcmVkIGJ5IHt7c2l0ZS5ic319LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuaU9TPW51bGwgaU9TLXNwZWNpZmljIHNldHRpbmdzLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5hbGVydD10cnVlIElmIHNldCB0byB0cnVlLCB0aGUgcHVzaCBub3RpZmljYXRpb24gd2lsbCBkaXNwbGF5IGFzIGEgc3RhbmRhcmQgaU9TIGFsZXJ0LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNldHRpbmdzLmlPUy5iYWRnZT0nKzEnIFNwZWNpZmllcyB0aGUgYmFkZ2UgY291bnRlciB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGRldmljZS5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1MuY2xlYXJCYWRnZT1mYWxzZSBTcGVjaWZpZXMgd2hldGhlciB0byByZXNldCB0aGUgYmFkZ2UgY291bnQgdG8gMC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1Muc291bmQ9dHJ1ZSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGRldmljZSB3aWxsIHBsYXkgYSBub3RpZmljYXRpb24gc291bmQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5hbmRyb2lkPW51bGwgQW5kcm9pZC1zcGVjaWZpYyBzZXR0aW5ncy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ9bnVsbCBZb3VyIEdvb2dsZSBBUEkgcHJvamVjdCBudW1iZXIuIEl0IGlzIHJlcXVpcmVkIHdoZW4gb2J0YWluaW5nIGEgcHVzaCB0b2tlbiBmb3IgYW4gQW5kcm9pZCBkZXZpY2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5hbmRyb2lkLnByb2plY3ROdW1iZXI9bnVsbCBTeW5vbnltIGZvciBhbmRyb2lkLnNlbmRlcklELiBBdmFpbGFibGUgaW4gSmF2YVNjcmlwdCBTREsgdmVyc2lvbnMgMS4yLjcgYW5kIGxhdGVyLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3Mud3A4PW51bGwgV2luZG93cyBQaG9uZSBzcGVjaWZpYyBzZXR0aW5ncy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLndwOC5jaGFubmVsTmFtZT1udWxsIFRoZSBuYW1lIG9mIHRoZSBwdXNoIGNoYW5uZWwgdGhhdCB0aGUgZGV2aWNlIGlzIHJlZ2lzdGVyaW5nIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0lPUyBTcGVjaWZpZXMgYSBjdXN0b20gY2FsbGJhY2sgdG8gYmUgdXNlZCB3aGVuIGEgcHVzaCBub3RpZmljYXRpb24gaXMgcmVjZWl2ZWQgb24gaU9TLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQgU3BlY2lmaWVzIGEgY3VzdG9tIGNhbGxiYWNrIHRvIGJlIHVzZWQgd2hlbiBhIHB1c2ggbm90aWZpY2F0aW9uIGlzIHJlY2VpdmVkIG9uIEFuZHJvaWQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4IFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBXaW5kb3dzIFBob25lIDguXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzPW51bGwgU3BlY2lmaWVzIG9wdGlvbmFsIGN1c3RvbSByZWdpc3RyYXRpb24gcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2F2ZWQgaW4gVGVsZXJpayBCYWNrZW5kIFNlcnZpY2VzLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIG9uIHRoZSBkZXZpY2UgYW5kIHJlZ2lzdGVycyBpdCBmb3IgdGhlIGZlYXR1cmUgd2l0aCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC4gSWYgaXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCwgdGhlIHJlZ2lzdHJhdGlvbiBkZXRhaWxzIGFyZSB1cGRhdGVkLlxuICAgICAgICAgKiBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlxuICAgICAgICAgKiBJZiBpdCB3YXMgcmVnaXN0ZXJlZCB0aGUgcmVnaXN0cmF0aW9uIGRldGFpbHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBTZXR0aW5ncyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gQ2FuIGluY2x1ZGUgY3VzdG9tIHBhcmFtZXRlcnMgdG8gYmUgc2F2ZWQgaW4gYmFja2VuZCBzZXJ2aWNlcy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmlPUz1udWxsIGlPUyBzcGVjaWZpYyBzZXR0aW5nc1xuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5hbGVydD10cnVlIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkZXZpY2Ugd2lsbCBkaXNwbGF5IGFuIGFsZXJ0IG1lc3NhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gc2V0dGluZ3MuaU9TLmJhZGdlPScrMScgU3BlY2lmaWVzIHRoZSBiYWRnZSBjb3VudGVyIHRvIGJlIGRpc3BsYXllZCBvbiB0aGUgZGV2aWNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5jbGVhckJhZGdlPWZhbHNlIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJlc2V0IHRoZSBiYWRnZSBjb3VudCB0byAwLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5zb3VuZD10cnVlIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkZXZpY2Ugd2lsbCBwbGF5IGEgc291bmQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5hbmRyb2lkPW51bGwgQW5kcm9pZCBzcGVjaWZpYyBzZXR0aW5nc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ3MuYW5kcm9pZC5zZW5kZXJJRD1udWxsIFRoaXMgaXMgeW91ciBHb29nbGUgQVBJIHByb2plY3QgbnVtYmVyLiBJdCBpcyByZXF1aXJlZCB3aGVuIG9idGFpbmluZyBhIHB1c2ggdG9rZW4gZm9yIGFuIEFuZHJvaWQgZGV2aWNlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ3MuYW5kcm9pZC5wcm9qZWN0TnVtYmVyPW51bGwgU3lub255bSBmb3IgYW5kcm9pZC5zZW5kZXJJRC4gQXZhaWxhYmxlIGluIEphdmFTY3JpcHQgU0RLIHZlcnNpb25zIDEuMi43IGFuZCBsYXRlci5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLndwOD1udWxsIFdpbmRvd3MgUGhvbmUgc3BlY2lmaWMgc2V0dGluZ3NcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLndwOC5jaGFubmVsTmFtZT1udWxsIFRoZSBuYW1lIG9mIHRoZSBwdXNoIGNoYW5uZWwgdGhhdCB0aGUgZGV2aWNlIGlzIHJlZ2lzdGVyaW5nIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0lPUyBTcGVjaWZpZXMgYSBjdXN0b20gY2FsbGJhY2sgdG8gYmUgdXNlZCB3aGVuIGEgcHVzaCBub3RpZmljYXRpb24gaXMgcmVjZWl2ZWQgb24gaU9TLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQgU3BlY2lmaWVzIGEgY3VzdG9tIGNhbGxiYWNrIHRvIGJlIHVzZWQgd2hlbiBhIHB1c2ggbm90aWZpY2F0aW9uIGlzIHJlY2VpdmVkIG9uIEFuZHJvaWQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrV1A4IFNwZWNpZmllcyBhIGN1c3RvbSBjYWxsYmFjayB0byBiZSB1c2VkIHdoZW4gYSBwdXNoIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZCBvbiBXaW5kb3dzIFBob25lIDguXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzPW51bGwgU3BlY2lmaWVzIG9wdGlvbmFsIGN1c3RvbSByZWdpc3RyYXRpb24gcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2F2ZWQgaW4gVGVsZXJpayBCYWNrZW5kIFNlcnZpY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChzZXR0aW5ncywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5kcm9pZCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQgPSBzZXR0aW5ncy5hbmRyb2lkLnByb2plY3ROdW1iZXIgfHwgc2V0dGluZ3MuYW5kcm9pZC5zZW5kZXJJRDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IERldmljZVJlZ2lzdHJhdGlvblJlc3VsdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uRXJyb3IgPSBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tRXZlcmxpdmVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlZ2lzdHJhdGlvbkVycm9yKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjbGVhckJhZGdlSWZOZWVkZWQgPSBmdW5jdGlvbiAodG9rZW4sIHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xuICAgICAgICAgICAgICAgIHZhciBwbGF0Zm9ybVR5cGUgPSBjdXJyZW50RGV2aWNlLl9nZXRQbGF0Zm9ybVR5cGUoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xlYXJCYWRnZSA9IHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uaU9TO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyQmFkZ2UgJiYgc2V0dGluZ3MuaU9TKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2UgPSBzZXR0aW5ncy5pT1MuY2xlYXJCYWRnZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyQmFkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhckJhZGdlTnVtYmVyKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodG9rZW4sIHN1Y2Nlc3NDYik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyLCBlcnJvckNiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRva2VuLCBzdWNjZXNzQ2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucyhzZXR0aW5ncywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHJlc3BvbnNlLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tUGFyYW1ldGVycyA9IHNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZ2V0UmVnaXN0cmF0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLnVwZGF0ZVJlZ2lzdHJhdGlvbihjdXN0b21QYXJhbWV0ZXJzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2VJZk5lZWRlZCh0b2tlbiwgc3VjY2Vzc0NiLCBlcnJvckNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyLCBlcnJvckNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDgwMSkgeyAvL05vdCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UucmVnaXN0ZXIoY3VzdG9tUGFyYW1ldGVycywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJCYWRnZUlmTmVlZGVkKHRva2VuLCBzdWNjZXNzQ2IsIGVycm9yQ2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVyciwgZXJyb3JDYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tUGx1Z2luRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYihkZXZpY2VSZWdpc3RyYXRpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uIFRoZSBkZXZpY2Ugd2lsbCBhbHNvIGJlIHVucmVnaXN0ZXJlZCBmcm9tIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxuICAgICAgICAgKiBAbmFtZSB1bnJlZ2lzdGVyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uIFRoZSBkZXZpY2Ugd2lsbCBhbHNvIGJlIHVucmVnaXN0ZXJlZCBmcm9tIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi5cbiAgICAgICAgICogVGhlIGRldmljZSB3aWxsIGFsc28gYmUgdW5yZWdpc3RlcmVkIGZyb20gVGVsZXJpayBCYWNrZW5kIFNlcnZpY2VzLlxuICAgICAgICAgKiBAbWV0aG9kIHVucmVnaXN0ZXJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZXZpY2UuZGlzYWJsZU5vdGlmaWNhdGlvbnMuYXBwbHkoY3VycmVudERldmljZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSBjdXJyZW50IGRldmljZS5cbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVSZWdpc3RyYXRpb25cbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gSWYge3VuZGVmaW5lZH0sIGN1c3RvbVBhcmFtZXRlcnMgYXJlIG5vdCB1cGRhdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVSZWdpc3RyYXRpb25cbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB7dW5kZWZpbmVkfSwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlUmVnaXN0cmF0aW9uOiBmdW5jdGlvbiAoY3VzdG9tUGFyYW1ldGVycywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudERldmljZSA9IHRoaXMuY3VycmVudERldmljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZXZpY2UudXBkYXRlUmVnaXN0cmF0aW9uLmFwcGx5KGN1cnJlbnREZXZpY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGJhZGdlIG51bWJlciBvbiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBzZXJ2ZXIuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QmFkZ2VOdW1iZXJcbiAgICAgICAgICogQG5hbWUgc2V0QmFkZ2VOdW1iZXJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gYmFkZ2UgVGhlIG51bWJlciB0byBiZSBzZXQgYXMgYSBiYWRnZS5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBiYWRnZSBudW1iZXIgb24gdGhlIHNlcnZlclxuICAgICAgICAgKiBAbWV0aG9kIHNldEJhZGdlTnVtYmVyXG4gICAgICAgICAqIEBuYW1lIHNldEJhZGdlTnVtYmVyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJhZGdlIFRoZSBudW1iZXIgdG8gYmUgc2V0IGFzIGEgYmFkZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QmFkZ2VOdW1iZXI6IGZ1bmN0aW9uIChiYWRnZSwgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xuXG4gICAgICAgICAgICBiYWRnZSA9IHBhcnNlSW50KGJhZGdlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihiYWRnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignVGhlIGJhZGdlIG11c3QgaGF2ZSBhIG51bWVyaWMgdmFsdWUnKSk7XG4gICAgICAgICAgICAgICAgfSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcbiAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGN1cnJlbnREZXZpY2UuX2dldERldmljZUlkKCk7XG4gICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uSWQgPSAnSGFyZHdhcmVJZC8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKTtcbiAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5CYWRnZUNvdW50ZXIgPSBiYWRnZTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3NDYiwgZXJyb3JDYikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuX3B1c2hIYW5kbGVyLmRldmljZXMudXBkYXRlU2luZ2xlKGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wbHVnaW5zICYmIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbi5zZXRBcHBsaWNhdGlvbkljb25CYWRnZU51bWJlcihzdWNjZXNzQ2IsIGVycm9yQ2IsIGJhZGdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3NDYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNiKVxuICAgICAgICAgICAgfSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBiYWRnZSBudW1iZXIgb24gdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gc2VydmVyIHRvIDAuXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJCYWRnZU51bWJlclxuICAgICAgICAgKiBAbmFtZSBjbGVhckJhZGdlTnVtYmVyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSBzZXJ2ZXIgYnkgc2V0dGluZyBpdCB0byAwXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJCYWRnZU51bWJlclxuICAgICAgICAgKiBAbmFtZSBjbGVhckJhZGdlTnVtYmVyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQmFkZ2VOdW1iZXI6IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEJhZGdlTnVtYmVyKDAsIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggbm90aWZpY2F0aW9ucyByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXG4gICAgICAgICAqIEBuYW1lIGdldFJlZ2lzdHJhdGlvblxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERldmljZS5nZXRSZWdpc3RyYXRpb24uYXBwbHkoY3VycmVudERldmljZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSBwdXNoIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICogQG1ldGhvZCBzZW5kXG4gICAgICAgICAqIEBuYW1lIHNlbmRcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gVGhlIHB1c2ggbm90aWZpY2F0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSBwdXNoIG1lc3NhZ2VcbiAgICAgICAgICogQG1ldGhvZCBzZW5kXG4gICAgICAgICAqIEBuYW1lIHNlbmRcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gVGhlIHB1c2ggbm90aWZpY2F0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIChub3RpZmljYXRpb24sIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9ucy5jcmVhdGUuYXBwbHkodGhpcy5ub3RpZmljYXRpb25zLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIGRpZmZlcmVudCBvcGVyYXRpb24gb24gZWFjaCBzdXBwb3J0ZWQgcGxhdGZvcm06XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gT24gaU9TOiBDaGVja3MgaWYgTm90aWZpY2F0aW9ucyBpcyBlbmFibGVkIGZvciB0aGlzIGFwcGxpY2F0aW9uIGluIHRoZSBkZXZpY2UncyBOb3RpZmljYXRpb24gQ2VudGVyLlxuICAgICAgICAgKiAtIE9uIFdpbmRvd3MgUGhvbmU6IENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGFuIGFjdGl2ZSBvcGVuIGNoYW5uZWwgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgTWljcm9zb2Z0IFB1c2ggTm90aWZpY2F0aW9uIFNlcnZpY2UuIFRoZSBvdXRjb21lIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgZGV2aWNlJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxuICAgICAgICAgKiAtIE9uIEFuZHJvaWQ6IENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGVzdGFibGlzaGVkIGEgY29ubmVjdGlvbiB3aXRoIEdvb2dsZSBDbG91ZCBNZXNzYWdpbmcuIFRoZSBvdXRjb21lIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgZGV2aWNlJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxuICAgICAgICAgKiBAbWV0aG9kIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXG4gICAgICAgICAqIEBuYW1lIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgcGFzc2VkIHRvIHRoZSBQdXNoIE5vdGlmaWNhdGlvbiBwbHVnaW4ncyBhcmVOb3RpZmljYXRpb25zRW5hYmxlZCBtZXRob2RcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpT1M6IENoZWNrcyBpZiB0aGUgTm90aWZpY2F0aW9ucyBhcmUgZW5hYmxlZCBmb3IgdGhpcyBBcHBsaWNhdGlvbiBpbiB0aGUgRGV2aWNlJ3MgTm90aWZpY2F0aW9uIENlbnRlci5cbiAgICAgICAgICogV2luZG93cyBQaG9uZTogQ2hlY2tzIGlmIHRoZSBBcHBsaWNhdGlvbiBoYXMgYW4gYWN0aXZlIG9wZW5lZCBDaGFubmVsIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBOb3QgcmVseWluZyBvbiB0aGUgZGV2aWNlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICAgICAgICogQW5kcm9pZDogQ2hlY2tzIGlmIHRoZSBBcHBsaWNhdGlvbiBoYXMgZXN0YWJsaXNoZWQgY29ubmVjdGlvbiB3aXRoIHRoZSBOb3RpZmljYXRpb24gU2VydmljZS4gTm90IHJlbHlpbmcgb24gdGhlIGRldmljZSBub3RpZmljYXRpb24gc2V0dGluZ3MuXG4gICAgICAgICAqIEBtZXRob2QgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcbiAgICAgICAgICogQG5hbWUgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCBwYXNzZWQgdG8gdGhlIFB1c2ggTm90aWZpY2F0aW9uIHBsdWdpbidzIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3NmdWwgY2hlY2suIFBhc3NlcyBhIHNpbmdsZSBib29sZWFuIHZhbHVlOiB0cnVlIG9yIGZhbHNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZXJyb3IgaW4gdGhlIHB1c2ggcGx1Z2luIGhhcyBvY2N1cnJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkOiBmdW5jdGlvbiAob3B0aW9ucywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xuXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBwdXNoTm90aWZpY2F0aW9uID0gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbjtcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XG4gICAgICAgICAgICAgICAgcHVzaE5vdGlmaWNhdGlvbi5hcmVOb3RpZmljYXRpb25zRW5hYmxlZChzdWNjZXNzQ2IsIGVycm9yQ2IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSwgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUHVzaDtcbn0oKSk7IiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHJzdnAgPSByZXF1aXJlKCcuL2NvbW1vbicpLnJzdnA7XG52YXIgYnVpbGRBdXRoSGVhZGVyID0gdXRpbHMuYnVpbGRBdXRoSGVhZGVyO1xudmFyIHBhcnNlVXRpbGl0aWVzID0gdXRpbHMucGFyc2VVdGlsaXRpZXM7XG52YXIgZ3VhcmRVbnNldCA9IHV0aWxzLmd1YXJkVW5zZXQ7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciByZXF3ZXN0ID0gY29tbW9uLnJlcXdlc3Q7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIEhlYWRlcnMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLkhlYWRlcnM7XG52YXIgaXNOb2RlanMgPSByZXF1aXJlKCcuL2V2ZXJsaXZlLnBsYXRmb3JtJykuaXNOb2RlanM7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3NlbGY7XG5cbiAgICAvLyBUaGUgUmVxdWVzdCB0eXBlIGlzIGFuIGFic3RyYWN0aW9uIG92ZXIgQWpheCBsaWJyYXJpZXNcbiAgICAvLyBBIFJlcXVlc3Qgb2JqZWN0IG5lZWRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBFdmVybGl2ZSBjb25uZWN0aW9uIGFuZCBpbml0aWFsaXphdGlvbiBvcHRpb25zXG5cbiAgICBmdW5jdGlvbiBSZXF1ZXN0KHNldHVwLCBvcHRpb25zKSB7XG4gICAgICAgIGd1YXJkVW5zZXQoc2V0dXAsICdzZXR1cCcpO1xuICAgICAgICBndWFyZFVuc2V0KG9wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBudWxsO1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIC8vIFRPRE8gc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzIHNob3VsZCBiZSB1bmlmb3JtZWQgZm9yIGFsbCBhamF4IGxpYnNcbiAgICAgICAgdGhpcy5zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2UgPSBSZXF1ZXN0LnBhcnNlcnMuc2ltcGxlO1xuXG4gICAgICAgIF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBfc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgUmVxdWVzdC5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIENhbGxzIHRoZSB1bmRlcmx5aW5nIEFqYXggbGlicmFyeVxuICAgICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LnNlbmRSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm5zIGFuIGF1dGhvcml6YXRpb24gaGVhZGVyIHVzZWQgYnkgdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbG9nZ2VkIGluIHVzZXIgZm9yIHRoZSBFdmVybGl2ZSBpbnN0YW5jZSB0aGVuIGhlci9oaXMgYXV0aGVudGljYXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAgICBidWlsZEF1dGhIZWFkZXI6IGJ1aWxkQXV0aEhlYWRlcixcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBVUkwgb2YgdGhlIHRhcmdldCBFdmVybGl2ZSBzZXJ2aWNlXG4gICAgICAgIGJ1aWxkVXJsOiBmdW5jdGlvbiBidWlsZFVybChzZXR1cCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHNldHVwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBxdWVyeSB0byByZXR1cm4gYXBwcm9wcmlhdGUgaGVhZGVycyB0byBiZSB1c2VkIGJ5IHRoZSByZXF1ZXN0XG4gICAgICAgIGJ1aWxkUXVlcnlIZWFkZXJzOiBmdW5jdGlvbiBidWlsZFF1ZXJ5SGVhZGVycyhxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3QucHJvdG90eXBlLl9idWlsZFF1ZXJ5SGVhZGVycyhxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVxdWVzdC5wcm90b3R5cGUuX2J1aWxkRmlsdGVySGVhZGVyKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIFJlcXVlc3Qgb2JqZWN0IGJ5IHVzaW5nIHRoZSBwYXNzZWQgb3B0aW9uc1xuICAgICAgICBfaW5pdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIF8uZXh0ZW5kKHRoaXMuaGVhZGVycywgdGhpcy5idWlsZEF1dGhIZWFkZXIodGhpcy5zZXR1cCwgb3B0aW9ucyksIHRoaXMuYnVpbGRRdWVyeUhlYWRlcnMob3B0aW9ucy5maWx0ZXIpLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUcmFuc2xhdGVzIGFuIEV2ZXJsaXZlLlF1ZXJ5IHRvIHJlcXVlc3QgaGVhZGVyc1xuICAgICAgICBfYnVpbGRRdWVyeUhlYWRlcnM6IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5idWlsZCgpO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChxdWVyeS4kd2hlcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZmlsdGVyXSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiR3aGVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkuJHNlbGVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy5zZWxlY3RdID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuJHNlbGVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkuJHNvcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc29ydF0gPSBKU09OLnN0cmluZ2lmeShxdWVyeS4kc29ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkuJHNraXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc2tpcF0gPSBxdWVyeS4kc2tpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWVyeS4kdGFrZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbSGVhZGVycy50YWtlXSA9IHF1ZXJ5LiR0YWtlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiRleHBhbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuZXhwYW5kXSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiRleHBhbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENyZWF0ZXMgYSBoZWFkZXIgZnJvbSBhIHNpbXBsZSBmaWx0ZXJcbiAgICAgICAgX2J1aWxkRmlsdGVySGVhZGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLmZpbHRlcl0gPSBKU09OLnN0cmluZ2lmeShmaWx0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcgPSBfc2VsZiAmJiBfc2VsZi5zZXR1cCAmJiBfc2VsZi5zZXR1cC5wYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lT2JqZWN0cztcblxuICAgIHZhciByZXZpdmVyID0gcGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcihwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nKTtcblxuICAgIFJlcXVlc3QucGFyc2VycyA9IHtcbiAgICAgICAgc2ltcGxlOiB7XG4gICAgICAgICAgICByZXN1bHQ6IHBhcnNlVXRpbGl0aWVzLnBhcnNlUmVzdWx0LmJpbmQobnVsbCwgcmV2aXZlciksXG4gICAgICAgICAgICBlcnJvcjogcGFyc2VVdGlsaXRpZXMucGFyc2VFcnJvci5iaW5kKG51bGwsIHJldml2ZXIpXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZToge1xuICAgICAgICAgICAgcmVzdWx0OiBwYXJzZVV0aWxpdGllcy5wYXJzZVNpbmdsZVJlc3VsdC5iaW5kKG51bGwsIHJldml2ZXIpLFxuICAgICAgICAgICAgZXJyb3I6IHBhcnNlVXRpbGl0aWVzLnBhcnNlRXJyb3IuYmluZChudWxsLCByZXZpdmVyKVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHJlc3VsdDogcGFyc2VVdGlsaXRpZXMucGFyc2VVcGRhdGVSZXN1bHQuYmluZChudWxsLCByZXZpdmVyKSxcbiAgICAgICAgICAgIGVycm9yOiBwYXJzZVV0aWxpdGllcy5wYXJzZUVycm9yLmJpbmQobnVsbCwgcmV2aXZlcilcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUT0RPIGJ1aWx0IGZvciByZXF1ZXN0XG4gICAgaWYgKHR5cGVvZiBSZXF1ZXN0LnNlbmRSZXF1ZXN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBSZXF1ZXN0LnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSByZXF1ZXN0LmJ1aWxkVXJsKHJlcXVlc3Quc2V0dXApICsgcmVxdWVzdC5lbmRwb2ludDtcbiAgICAgICAgICAgIHVybCA9IHV0aWxzLmRpc2FibGVSZXF1ZXN0Q2FjaGUodXJsLCByZXF1ZXN0Lm1ldGhvZCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kIHx8ICdHRVQnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgPyByZXF1ZXN0LmRhdGEgOiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpc05vZGVqcykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnN1Y2Nlc3MuY2FsbChyZXF1ZXN0LCByZXF1ZXN0LnBhcnNlLnJlc3VsdChkYXRhKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLmVycm9yID0gZnVuY3Rpb24gKGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZXJyb3IuY2FsbChyZXF1ZXN0LCByZXF1ZXN0LnBhcnNlLmVycm9yKGpxWEhSLnJlc3BvbnNlVGV4dCB8fCBqcVhIUi5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcy50eXBlID0gJ2pzb24nO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuY3Jvc3NPcmlnaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVxdWVzdC5wYXJzZS5yZXN1bHQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc3VjY2Vzcy5jYWxsKHJlcXVlc3QsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuZXJyb3IgPSBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHJlcXVlc3QucGFyc2UuZXJyb3IoanFYSFIucmVzcG9uc2VUZXh0IHx8IGpxWEhSLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmVycm9yLmNhbGwocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXdlc3QocmVxdWVzdFBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlcXVlc3Q7XG59KCkpOyIsInZhciBfID0gcmVxdWlyZSgnLi9jb21tb24nKS5fO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgQXV0aGVudGljYXRpb25TZXR1cCA9IHJlcXVpcmUoJy4vYXV0aC9BdXRoZW50aWNhdGlvblNldHVwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlcmxpdmVVcmwgPSBjb25zdGFudHMuZXZlcmxpdmVVcmw7XG5cbiAgICAvLyBBbiBvYmplY3QgdGhhdCBrZWVwcyBpbmZvcm1hdGlvbiBhYm91dCBhbiBFdmVybGl2ZSBjb25uZWN0aW9uXG4gICAgZnVuY3Rpb24gU2V0dXAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IGV2ZXJsaXZlVXJsO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG51bGw7XG4gICAgICAgIHRoaXMubWFzdGVyS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmluY2lwYWxJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NoZW1lID0gJ2h0dHAnOyAvLyBodHRwIG9yIGh0dHBzXG4gICAgICAgIHRoaXMucGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZU9iamVjdHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW11bGF0b3JNb2RlID0gb3B0aW9ucy5lbXVsYXRvck1vZGU7XG4gICAgICAgICAgICBfLmV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb24gPSBuZXcgQXV0aGVudGljYXRpb25TZXR1cCh0aGlzLCBvcHRpb25zLmF1dGhlbnRpY2F0aW9uKTtcbiAgICB9XG5cbiAgICBTZXR1cC5wcm90b3R5cGUuc2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXMgPSBmdW5jdGlvbiAodG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICAgICAgdGhpcy5wcmluY2lwYWxJZCA9IHByaW5jaXBhbElkO1xuICAgIH07XG5cbiAgICBTZXR1cC5wcm90b3R5cGUuZ2V0QXV0aG9yaXphdGlvblByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy50b2tlbixcbiAgICAgICAgICAgIHRva2VuVHlwZTogdGhpcy50b2tlblR5cGUsXG4gICAgICAgICAgICBwcmluY2lwYWxJZDogdGhpcy5wcmluY2lwYWxJZFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0dXA7XG5cbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xudmFyIEV2ZXJsaXZlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbnZhciB1c2Vyc0NvbGxlY3Rpb25OYW1lID0gJ1VzZXJzJztcbnZhciBidWlsZFByb21pc2UgPSB1dGlscy5idWlsZFByb21pc2U7XG52YXIgTG9jYWxTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3JhZ2VzL0xvY2FsU3RvcmUnKTtcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjbGFzcyBBdXRoZW50aWNhdGlvblxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyBmb3IgbWFuYWdpbmcgYXV0aGVudGljYXRpb24gb2YgYSB1c2VyIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSBlbCB7RXZlcmxpdmV9IEV2ZXJsaXZlIE9iamVjdFxuICAgICAqIEBwYXJhbSBzZXR1cCB7QXV0aFNldHVwfSB0aGUgYXV0aGVudGljYXRpb24gc2V0dXAgb2JqZWN0XG4gICAgICovXG4gICAgdmFyIEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKGVsLCBzZXR1cCkge1xuICAgICAgICB0aGlzLmF1dGhTZXR1cCA9IHNldHVwIHx8IHt9O1xuICAgICAgICB0aGlzLl9lbCA9IGVsO1xuICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmF1dGhTZXR1cC5wZXJzaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlID0gbmV3IExvY2FsU3RvcmUoZWwpO1xuICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmVLZXkgPSB0aGlzLl9nZXRMb2NhbFN0b3JlS2V5KCk7XG4gICAgICAgICAgICB2YXIgYXV0aE9wdGlvbnMgPSB0aGlzLl9sb2NhbFN0b3JlLmdldEl0ZW0obG9jYWxTdG9yZUtleSk7XG4gICAgICAgICAgICB2YXIgYXV0aEluZm87XG4gICAgICAgICAgICBpZiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBhdXRoSW5mbyA9IEpTT04ucGFyc2UodGhpcy5fbG9jYWxTdG9yZS5nZXRJdGVtKGxvY2FsU3RvcmVLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdXRoSW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsLnNldHVwLnNldEF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKGF1dGhJbmZvLnRva2VuLCBhdXRoSW5mby50b2tlblR5cGUsIGF1dGhJbmZvLnByaW5jaXBhbElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQgdG8gdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIEFsbCByZXF1ZXN0cyBpbml0aWF0ZWQgYnkgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2Ugd2lsbCBiZSBhdXRoZW50aWNhdGVkIHdpdGggdGhhdCB1c2VyJ3MgY3JlZGVudGlhbHMuXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5cbiAgICAgKiBAbmFtZSBsb2dpblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpblxuICAgICAqIEBuYW1lIGxvZ2luXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2dpblN1Y2Nlc3MuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbixcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdXNlcnNDb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBncmFudF90eXBlOiAncGFzc3dvcmQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NGdW5jLFxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2VsLlVzZXJzLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZyBvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQgaW4uXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9nb3V0XG4gICAgICogQG5hbWUgbG9nb3V0XG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxuICAgICAqIEBuYW1lIGxvZ291dFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2dvdXRTdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGVycm9yRnVuYyA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDMwMSkgeyAvL2ludmFsaWQgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhckF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9nb3V0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB1c2Vyc0NvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0Z1bmMsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JGdW5jXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2VsLlVzZXJzLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fZ2V0TG9jYWxTdG9yZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5BdXRoU3RvcmVLZXkgKyB0aGlzLl9lbC5zZXR1cC5hcGlLZXkgKyAnJGF1dGhlbnRpY2F0aW9uJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhGYWNlYm9va1xuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmxvZ2luV2l0aEZhY2Vib29rID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XG4gICAgICAgICAgICBQcm92aWRlcjogJ0ZhY2Vib29rJyxcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBBREZTIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhBREZTXG4gICAgICogQG5hbWUgbG9naW5XaXRoQURGU1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBREZTIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gQURGUyBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoQURGU1xuICAgICAqIEBuYW1lIGxvZ2luV2l0aEFERlNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhBREZTID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XG4gICAgICAgICAgICBQcm92aWRlcjogJ0FERlMnLFxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgTGl2ZUlEIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhMaXZlSURcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhMaXZlSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gTGl2ZUlEIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBMaXZlSUQgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxuICAgICAqIEBuYW1lIGxvZ2luV2l0aExpdmVJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBMaXZlSUQgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9naW5XaXRoTGl2ZUlEID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XG4gICAgICAgICAgICBQcm92aWRlcjogJ0xpdmVJRCcsXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2luV2l0aFByb3ZpZGVyKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBHb29nbGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEdvb2dsZVxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEdvb2dsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBHb29nbGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhHb29nbGUgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnR29vZ2xlJyxcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUd2l0dGVyIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aFR3aXR0ZXJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUubG9naW5XaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnVHdpdHRlcicsXG4gICAgICAgICAgICBUb2tlbjogdG9rZW4sXG4gICAgICAgICAgICBUb2tlblNlY3JldDogdG9rZW5TZWNyZXRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgdGhhdCB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyB3aWxsIHVzZSBmb3IgYXV0aG9yaXphdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBzZXRBdXRob3JpemF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhdXRob3JpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuVG9rZW5UeXBlfSB0b2tlblR5cGUgVG9rZW4gdHlwZS4gQ3VycmVudGx5IG9ubHkgJ2JlYXJlcicgdG9rZW4gaXMgc3VwcG9ydGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmluY2lwYWxJZCBUaGUgaWQgb2YgdGhlIHVzZXIgdGhhdCBpcyBsb2dnZWQgaW4uXG4gICAgICovXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLnNldEF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBzZXRBdXRob3JpemF0aW9uKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKSB7XG4gICAgICAgIHRoaXMuX2VsLnNldHVwLnNldEF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKTtcblxuICAgICAgICBpZiAodGhpcy5hdXRoU2V0dXAucGVyc2lzdCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmVLZXkgPSB0aGlzLl9nZXRMb2NhbFN0b3JlS2V5KCk7XG4gICAgICAgICAgICB2YXIgYXV0aG9yaXphdGlvblByb3BlcnRpZXMgPSB0aGlzLl9lbC5zZXR1cC5nZXRBdXRob3JpemF0aW9uUHJvcGVydGllcygpO1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdG9yZS5zZXRJdGVtKGxvY2FsU3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KGF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRoYXQgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGN1cnJlbnRseSB1c2VzLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBsb2dnaW5nIG91dCwgYmVjYXVzZSB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiB0aGF0IHdhcyB1c2VkLCB3aWxsIG5vdCBiZSBpbnZhbGlkYXRlZC5cbiAgICAgKiBAbWV0aG9kIGNsZWFyQXV0aG9yaXphdGlvblxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuY2xlYXJBdXRob3JpemF0aW9uID0gZnVuY3Rpb24gY2xlYXJBdXRob3JpemF0aW9uKCkge1xuICAgICAgICB0aGlzLnNldEF1dGhvcml6YXRpb24obnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMuY2xlYXJQZXJzaXN0ZWRBdXRoZW50aWNhdGlvbigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgcGVyc2lzdGVkIGF1dGhlbnRpY2F0aW9uIGZyb20gdGhlIGxvY2FsIHN0b3JlIGZvciB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gV2lsbCBub3QgbG9nb3V0IG9yIG1vZGlmeSB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBvZiB0aGUgSmF2YXNjcmlwdCBTREsuXG4gICAgICogQG1ldGhvZCBjbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jbGVhclBlcnNpc3RlZEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxTdG9yZSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmVLZXkgPSB0aGlzLl9nZXRMb2NhbFN0b3JlS2V5KCk7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlLnJlbW92ZUl0ZW0obG9jYWxTdG9yZUtleSk7XG4gICAgICAgICAgICB0aGlzLl9lbC5zZXR1cC5zZXRBdXRob3JpemF0aW9uUHJvcGVydGllcyhudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVtZW50IGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhbiBvbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgZnVuY3Rpb24gaXMgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5hdXRoU2V0dXAub25BdXRoZW50aWNhdGlvblJlcXVpcmVkID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICAvKiogRW5zdXJlcyB0aGF0IGF1dGhlbnRpY2F0aW9uIGlzIGNvbXBsZXRlZCBiZWZvcmUgY29udGludWluZy5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBhdXRoZW50aWNhdGlvbiBpcyBjb21wbGV0ZS4gU2VlIHt7QGxpbmsgRXZlcmxpdmUucHJvdG90eXBlLmNvbXBsZXRlQXV0aGVudGljYXRpb259fS5cbiAgICAgKiBAdGhyb3dzIHRocm93cyBhbiBlcnJvciBpZiBubyBvbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgaGFuZGxlciBpcyBwcm92aWRlZCB0byB0aGUgc2V0dXAuXG4gICAgICovXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLl9lbnN1cmVBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25BdXRoZW50aWNhdGlvblJlcXVpcmVkIG9wdGlvbiBvZiBFdmVybGl2ZS5TZXR1cC5BdXRoZW50aWNhdGlvbiBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0F1dGhlbnRpY2F0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcy5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhckF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgdGhpcy5hdXRoU2V0dXAub25BdXRoZW50aWNhdGlvblJlcXVpcmVkLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzID0gdXRpbHMuZ2V0Q2FsbGJhY2tzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcy5wcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gcmVzdWx0LlxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYXV0aGVudGljYXRpb24gYXV0aGVudGljYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gICAgICogQHBhcmFtIGF1dGhlbnRpY2F0aW9uLmFjY2Vzc190b2tlblxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbi50b2tlbl90eXBlXG4gICAgICogQHBhcmFtIGF1dGhlbnRpY2F0aW9uLnByaW5jaXBhbF9pZFxuICAgICAqL1xuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jb21wbGV0ZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKGF1dGhlbnRpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuX2VsLnNldEF1dGhvcml6YXRpb24oYXV0aGVudGljYXRpb24uYWNjZXNzX3Rva2VuLCBhdXRoZW50aWNhdGlvbi50b2tlbl90eXBlLCBhdXRoZW50aWNhdGlvbi5wcmluY2lwYWxfaWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgZ2V0QXV0aGVudGljYXRpb25TdGF0dXNcbiAgICAgKiBAbmFtZSBnZXRBdXRoZW50aWNhdGlvblN0YXR1c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdG8gdGhlIGF1dGhlbnRpY2F0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBnZXRBdXRoZW50aWNhdGlvblN0YXR1c1xuICAgICAqIEBuYW1lIGdldEF1dGhlbnRpY2F0aW9uU3RhdHVzXG4gICAgICogQHBhcmFtIHtFdmVybGl2ZS5DYWxsYmFja3MuYXV0aGVudGljYXRpb25TdGF0dXNTdWNjZXNzfSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmdldEF1dGhlbnRpY2F0aW9uU3RhdHVzID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzZXR1cCA9IHNlbGYuX2VsLnNldHVwO1xuICAgICAgICAgICAgaWYgKHNldHVwLm1hc3RlcktleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLm1hc3RlcktleX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNldHVwLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMudW5hdXRoZW50aWNhdGVkfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBjb25zdGFudHMuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGluZ30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9lbC5Vc2Vyc1xuICAgICAgICAgICAgICAgIC5za2lwQXV0aCh0cnVlKVxuICAgICAgICAgICAgICAgIC5jdXJyZW50VXNlcigpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBjb25zdGFudHMuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGVkLCB1c2VyOiByZXMucmVzdWx0fSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBjb25zdGFudHMuQXV0aFN0YXR1cy5hdXRoZW50aWNhdGluZ30pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkUmVxdWVzdC5jb2RlIHx8IGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkVG9rZW4uY29kZSkgeyAvLyBpbnZhbGlkIHJlcXVlc3QsIGkuZS4gdGhlIGFjY2VzcyB0b2tlbiBpcyBpbnZhbGlkIG9yIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmludmFsaWRBdXRoZW50aWNhdGlvbn0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5leHBpcmVkVG9rZW4uY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuZXhwaXJlZEF1dGhlbnRpY2F0aW9ufSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gaXMgY3VycmVudGx5IHdhaXRpbmcgZm9yIGF1dGhlbnRpY2F0aW9uIHRvIGJlIGNvbXBsZXRlZC4gU2VlIHt7QGxpbmsgRXZlcmxpdmUucHJvdG90eXBlLmNvbXBsZXRlQXV0aGVudGljYXRpb259fS5cbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmlzQXV0aGVudGljYXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzO1xuICAgIH07XG5cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2xvZ2luU3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhLnJlc3VsdDtcbiAgICAgICAgdGhpcy5zZXRBdXRob3JpemF0aW9uKHJlc3VsdC5hY2Nlc3NfdG9rZW4sIHJlc3VsdC50b2tlbl90eXBlLCByZXN1bHQucHJpbmNpcGFsX2lkKTtcbiAgICB9O1xuXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLl9sb2dvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyQXV0aG9yaXphdGlvbigpO1xuICAgIH07XG5cbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2xvZ2luV2l0aFByb3ZpZGVyID0gZnVuY3Rpb24gKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgdXNlciA9IHtcbiAgICAgICAgICAgIElkZW50aXR5OiBpZGVudGl0eVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgc3VjY2Vzc0Z1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fbG9naW5TdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHVzZXJzQ29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdXNlcixcbiAgICAgICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2tpcEF1dGg6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzRnVuYyxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlbGYuX2VsLlVzZXJzLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBBdXRoZW50aWNhdGlvbjtcbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEF1dGhlbnRpY2F0aW9uU2V0dXAgPSBmdW5jdGlvbiAoZXZlcmxpdmUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub25BdXRoZW50aWNhdGlvblJlcXVpcmVkID0gb3B0aW9ucy5vbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ7XG4gICAgICAgIHRoaXMucGVyc2lzdCA9IG9wdGlvbnMucGVyc2lzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF1dGhlbnRpY2F0aW9uU2V0dXA7XG59KCkpOyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tbW9uID0ge307XG4gICAgdmFyIGRlcGVuZGVuY3lTdG9yZSA9IHt9O1xuXG4gICAgdmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xuICAgIHZhciBpc05hdGl2ZVNjcmlwdCA9IHBsYXRmb3JtLmlzTmF0aXZlU2NyaXB0O1xuICAgIHZhciBpc05vZGVqcyA9IHBsYXRmb3JtLmlzTm9kZWpzO1xuXG4gICAgaWYgKCFpc05vZGVqcyAmJiAhaXNOYXRpdmVTY3JpcHQpIHtcbiAgICAgICAgZGVwZW5kZW5jeVN0b3JlLnJlcXdlc3QgPSByZXF1aXJlKCdyZXF3ZXN0Jyk7XG4gICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xuICAgICAgICBjb21tb24ucm9vdCA9IGdsb2JhbDtcbiAgICAgICAgZGVwZW5kZW5jeVN0b3JlLnJlcXdlc3QgPSByZXF1aXJlKCcuL3JlcXdlc3QubmF0aXZlc2NyaXB0Jyk7XG4gICAgfSBlbHNlIGlmIChpc05vZGVqcykge1xuICAgICAgICBjb21tb24ucm9vdCA9IGdsb2JhbDtcbiAgICAgICAgZGVwZW5kZW5jeVN0b3JlLnJlcXdlc3QgPSByZXF1aXJlKCcuL3JlcXdlc3Qubm9kZWpzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tb24ucm9vdCkge1xuICAgICAgICAvL2Jyb3dzZXIvcmVxdWlyZWpzL2NvcmRvdmFcbiAgICAgICAgY29tbW9uLnJvb3QgPSB3aW5kb3c7XG4gICAgfVxuXG4gICAgdmFyIGV4cG9ydERlcGVuZGVuY3kgPSBmdW5jdGlvbiBleHBvcnREZXBlbmRlbmN5KGdsb2JhbE5hbWUsIGxvY2FsTmFtZSkge1xuICAgICAgICBpZiAoIWxvY2FsTmFtZSkge1xuICAgICAgICAgICAgbG9jYWxOYW1lID0gZ2xvYmFsTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZm9yIHRoZSBldmVybGl2ZSBidW5kbGUgd2l0aG91dCBkZXBlbmRlbmNpZXMgaW5jbHVkZWQsIGJyb3dzZXJpZnkgcmVwbGFjZXMgdGhlbSB3aXRoIGVtcHR5IG9iamVjdHNcbiAgICAgICAgLy93ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXNlIGRlcGVuZGVuY2llcyBhcmUgbWFya2VkIGFzIHVuZGVmaW5lZFxuICAgICAgICBpZiAoZGVwZW5kZW5jeVN0b3JlW2xvY2FsTmFtZV0gJiZcbiAgICAgICAgICAgIHR5cGVvZiBkZXBlbmRlbmN5U3RvcmVbbG9jYWxOYW1lXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICFPYmplY3Qua2V5cyhkZXBlbmRlbmN5U3RvcmVbbG9jYWxOYW1lXSkubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGRlcGVuZGVuY3lTdG9yZVtsb2NhbE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbW1vbiwgbG9jYWxOYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jeVN0b3JlW2xvY2FsTmFtZV0gfHwgdGhpcy5yb290W2dsb2JhbE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZGVwZW5kZW5jeVN0b3JlLl8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgZXhwb3J0RGVwZW5kZW5jeSgnXycpO1xuXG4gICAgZGVwZW5kZW5jeVN0b3JlLmpzdHogPSByZXF1aXJlKCdqc3RpbWV6b25lZGV0ZWN0JykuanN0ejtcbiAgICBleHBvcnREZXBlbmRlbmN5KCdqc3R6Jyk7XG5cbiAgICBkZXBlbmRlbmN5U3RvcmUubW9uZ29RdWVyeSA9IHJlcXVpcmUoJ21vbmdvLXF1ZXJ5Jyk7XG4gICAgZXhwb3J0RGVwZW5kZW5jeSgnbW9uZ29RdWVyeScpO1xuXG4gICAgZGVwZW5kZW5jeVN0b3JlLk1pbmdvID0gcmVxdWlyZSgnbWluZ28nKTtcbiAgICBleHBvcnREZXBlbmRlbmN5KCdNaW5nbycpO1xuXG4gICAgZGVwZW5kZW5jeVN0b3JlLlByb2Nlc3NvciA9IHJlcXVpcmUoJy4uL3NjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3NvcicpO1xuICAgIGV4cG9ydERlcGVuZGVuY3koJ1Byb2Nlc3NvcicpO1xuXG4gICAgZGVwZW5kZW5jeVN0b3JlLkJhc2U2NCA9IHJlcXVpcmUoJ0Jhc2U2NCcpO1xuICAgIGV4cG9ydERlcGVuZGVuY3koJ0Jhc2U2NCcpO1xuXG4gICAgZGVwZW5kZW5jeVN0b3JlLnJzdnAgPSByZXF1aXJlKCdyc3ZwJyk7XG4gICAgZXhwb3J0RGVwZW5kZW5jeSgnUlNWUCcsICdyc3ZwJyk7XG5cbiAgICBleHBvcnREZXBlbmRlbmN5KCdyZXF3ZXN0Jyk7XG5cbiAgICByZXR1cm4gY29tbW9uO1xufSgpKTsiLCIvKipcbiAqIENvbnN0YW50cyB1c2VkIGJ5IHRoZSBTREtcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZXJsaXZlLkNvbnN0YW50c1xuICovXG5cbnZhciBjb25zdGFudHMgPSB7XG4gICAgaWRGaWVsZDogJ0lkJyxcbiAgICBndWlkRW1wdHk6ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnLFxuICAgIGV2ZXJsaXZlVXJsOiAnLy9hcGkuZXZlcmxpdmUuY29tL3YxLycsXG4gICAgLyoqXG4gICAgICogQSBjbGFzcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVnaWVzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDbGllbnRXaW5zXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFNlcnZlcldpbnNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ3VzdG9tXG4gICAgICogQHR5cGVkZWYge3N0cmluZ30gRXZlcmxpdmUuQ29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5XG4gICAgICovXG4gICAgQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3k6IHtcbiAgICAgICAgQ2xpZW50V2luczogJ2NsaWVudFdpbnMnLFxuICAgICAgICBTZXJ2ZXJXaW5zOiAnc2VydmVyV2lucycsXG4gICAgICAgIEN1c3RvbTogJ2N1c3RvbSdcbiAgICB9LFxuICAgIENvbmZsaWN0UmVzb2x1dGlvbjoge1xuICAgICAgICBLZWVwU2VydmVyOiAna2VlcFNlcnZlcicsXG4gICAgICAgIEtlZXBDbGllbnQ6ICdrZWVwQ2xpZW50JyxcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJyxcbiAgICAgICAgU2tpcDogJ3NraXAnXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBhdmFpbGFibGUgc3RvcmFnZSBwcm92aWRlcnMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IExvY2FsU3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBGaWxlU3lzdGVtXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IEN1c3RvbVxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLkNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXJcbiAgICAgKi9cbiAgICBTdG9yYWdlUHJvdmlkZXI6IHtcbiAgICAgICAgTG9jYWxTdG9yYWdlOiAnbG9jYWxTdG9yYWdlJyxcbiAgICAgICAgRmlsZVN5c3RlbTogJ2ZpbGVTeXN0ZW0nLFxuICAgICAgICBDdXN0b206ICdjdXN0b20nXG4gICAgfSxcblxuICAgIERlZmF1bHRTdG9yYWdlUGF0aDogJ2VsX3N0b3JlJyxcblxuICAgIC8vIHRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBzdG9yaW5nIGZpbGVzIG9mZmxpbmVcbiAgICBEZWZhdWx0RmlsZXNTdG9yYWdlUGF0aDogJ2VsX2ZpbGVfc3RvcmUvJyxcblxuICAgIC8vIHRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBzdG9yaW5nIG9mZmxpbmUgdG8gb25saW5lIGxvY2F0aW9uIG1hcFxuICAgIERlZmF1bHRGaWxlc01ldGFkYXRhUGF0aDogJ2VsX2ZpbGVfbWFwcGluZy8nLFxuXG4gICAgRW5jcnlwdGlvblByb3ZpZGVyOiB7XG4gICAgICAgIERlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJ1xuICAgIH0sXG5cbiAgICAvLyBUaGUgaGVhZGVycyB1c2VkIGJ5IHRoZSBFdmVybGl2ZSBzZXJ2aWNlc1xuICAgIEhlYWRlcnM6IHtcbiAgICAgICAgZmlsdGVyOiAnWC1FdmVybGl2ZS1GaWx0ZXInLFxuICAgICAgICBzZWxlY3Q6ICdYLUV2ZXJsaXZlLUZpZWxkcycsXG4gICAgICAgIHNvcnQ6ICdYLUV2ZXJsaXZlLVNvcnQnLFxuICAgICAgICBza2lwOiAnWC1FdmVybGl2ZS1Ta2lwJyxcbiAgICAgICAgdGFrZTogJ1gtRXZlcmxpdmUtVGFrZScsXG4gICAgICAgIGV4cGFuZDogJ1gtRXZlcmxpdmUtRXhwYW5kJyxcbiAgICAgICAgc2luZ2xlRmllbGQ6ICdYLUV2ZXJsaXZlLVNpbmdsZS1GaWVsZCcsXG4gICAgICAgIGluY2x1ZGVDb3VudDogJ1gtRXZlcmxpdmUtSW5jbHVkZS1Db3VudCcsXG4gICAgICAgIHBvd2VyRmllbGRzOiAnWC1FdmVybGl2ZS1Qb3dlci1GaWVsZHMnLFxuICAgICAgICBkZWJ1ZzogJ1gtRXZlcmxpdmUtRGVidWcnLFxuICAgICAgICBvdmVycmlkZVN5c3RlbUZpZWxkczogJ1gtRXZlcmxpdmUtT3ZlcnJpZGUtU3lzdGVtLUZpZWxkcydcbiAgICB9LFxuICAgIC8vQ29uc3RhbnRzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zIGluIEV2ZXJsaXZlXG4gICAgUGxhdGZvcm06IHtcbiAgICAgICAgV2luZG93c1Bob25lOiAxLFxuICAgICAgICBXaW5kb3dzOiAyLFxuICAgICAgICBBbmRyb2lkOiAzLFxuICAgICAgICBpT1M6IDQsXG4gICAgICAgIE9TWDogNSxcbiAgICAgICAgQmxhY2tiZXJyeTogNixcbiAgICAgICAgTm9raWE6IDcsXG4gICAgICAgIFVua25vd246IDEwMFxuICAgIH0sXG4gICAgT3BlcmF0b3JUeXBlOiB7XG4gICAgICAgIHF1ZXJ5OiAxLFxuXG4gICAgICAgIHdoZXJlOiAxMDAsXG4gICAgICAgIGZpbHRlcjogMTAxLFxuXG4gICAgICAgIGFuZDogMTEwLFxuICAgICAgICBvcjogMTExLFxuICAgICAgICBub3Q6IDExMixcblxuICAgICAgICBlcXVhbDogMTIwLFxuICAgICAgICBub3RfZXF1YWw6IDEyMSxcbiAgICAgICAgbHQ6IDEyMixcbiAgICAgICAgbHRlOiAxMjMsXG4gICAgICAgIGd0OiAxMjQsXG4gICAgICAgIGd0ZTogMTI1LFxuICAgICAgICBpc2luOiAxMjYsXG4gICAgICAgIG5vdGluOiAxMjcsXG4gICAgICAgIGFsbDogMTI4LFxuICAgICAgICBzaXplOiAxMjksXG4gICAgICAgIHJlZ2V4OiAxMzAsXG4gICAgICAgIGNvbnRhaW5zOiAxMzEsXG4gICAgICAgIHN0YXJ0c1dpdGg6IDEzMixcbiAgICAgICAgZW5kc1dpdGg6IDEzMyxcblxuICAgICAgICBuZWFyU2hwZXJlOiAxNDAsXG4gICAgICAgIHdpdGhpbkJveDogMTQxLFxuICAgICAgICB3aXRoaW5Qb2x5Z29uOiAxNDIsXG4gICAgICAgIHdpdGhpblNocGVyZTogMTQzLFxuXG4gICAgICAgIHNlbGVjdDogMjAwLFxuICAgICAgICBleGNsdWRlOiAyMDEsXG5cbiAgICAgICAgb3JkZXI6IDMwMCxcbiAgICAgICAgb3JkZXJfZGVzYzogMzAxLFxuXG4gICAgICAgIHNraXA6IDQwMCxcbiAgICAgICAgdGFrZTogNDAxLFxuICAgICAgICBleHBhbmQ6IDQwMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5hdXRoZW50aWNhdGVkIEluZGljYXRlcyB0aGF0IG5vIHVzZXIgaXMgYXV0aGVudGljYXRlZC5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWFzdGVyS2V5IEluZGljYXRlcyB0aGF0IGEgbWFzdGVyIGtleSBhdXRoZW50aWNhdGlvbiBpcyB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnZhbGlkQXV0aGVudGljYXRpb24gSW5kaWNhdGVzIGFuIGF1dGhlbnRpY2F0aW9uIGhhcyBiZWVuIGF0dGVtcHRlZCwgYnV0IGl0IHdhcyBpbnZhbGlkLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoZW50aWNhdGVkIEluZGljYXRlcyB0aGF0IGEgdXNlciBpcyBhdXRoZW50aWNhdGVkLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoZW50aWNhdGluZyBJbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0aW5nLiBTb21lIHJlcXVlc3RzIG1pZ2h0IGJlIHBlbmRpbmcgYW5kIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZXhwaXJlZEF1dGhlbnRpY2F0aW9uIEluZGljYXRlcyB0aGF0IGEgdXNlcidzIGF1dGhlbnRpY2F0aW9uIGhhcyBleHBpcmVkIGFuZCB0aGF0IHRoZSB1c2VyIG11c3QgbG9nIGJhY2sgaW4uXG4gICAgICogQHR5cGVkZWYge3N0cmluZ30gRXZlcmxpdmUuQXV0aFN0YXR1c1xuICAgICAqL1xuICAgIEF1dGhTdGF0dXM6IHtcbiAgICAgICAgdW5hdXRoZW50aWNhdGVkOiAndW5hdXRoZW50aWNhdGVkJyxcbiAgICAgICAgbWFzdGVyS2V5OiAnbWFzdGVyS2V5JyxcbiAgICAgICAgaW52YWxpZEF1dGhlbnRpY2F0aW9uOiAnaW52YWxpZEF1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgYXV0aGVudGljYXRlZDogJ2F1dGhlbnRpY2F0ZWQnLFxuICAgICAgICBleHBpcmVkQXV0aGVudGljYXRpb246ICdleHBpcmVkQXV0aGVudGljYXRpb24nLFxuICAgICAgICBhdXRoZW50aWNhdGluZzogJ2F1dGhlbnRpY2F0aW5nJ1xuICAgIH0sXG4gICAgb2ZmbGluZUl0ZW1TdGF0ZXM6IHtcbiAgICAgICAgY3JlYXRlZDogJ2NyZWF0ZScsXG4gICAgICAgIG1vZGlmaWVkOiAndXBkYXRlJyxcbiAgICAgICAgZGVsZXRlZDogJ2RlbGV0ZSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSFRUUCBNZXRob2RzXG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKi9cbiAgICBIdHRwTWV0aG9kOiB7XG4gICAgICAgIEdFVDogJ0dFVCcsXG4gICAgICAgIFBPU1Q6ICdQT1NUJyxcbiAgICAgICAgUFVUOiAnUFVUJyxcbiAgICAgICAgREVMRVRFOiAnREVMRVRFJ1xuICAgIH0sXG4gICAgbWF4RGlzdGFuY2VDb25zdHM6IHtcbiAgICAgICAgcmFkaWFuczogJyRtYXhEaXN0YW5jZScsXG4gICAgICAgIGttOiAnJG1heERpc3RhbmNlSW5LaWxvbWV0ZXJzJyxcbiAgICAgICAgbWlsZXM6ICckbWF4RGlzdGFuY2VJbk1pbGVzJ1xuICAgIH0sXG4gICAgcmFkaXVzQ29uc3RzOiB7XG4gICAgICAgIHJhZGlhbnM6ICdyYWRpdXMnLFxuICAgICAgICBrbTogJ3JhZGl1c0luS2lsb21ldGVycycsXG4gICAgICAgIG1pbGVzOiAncmFkaXVzSW5NaWxlcydcbiAgICB9XG59O1xuXG4vLyB1c2luZyBhbiBpbnZhbGlkIGZpZWxkIG5hbWUgaW4gdGhlIGNvbnRleHQgb2YgRXZlcmxpdmVcbi8vIHRvIGVuc3VyZSBubyBuYW1pbmcgY29sbGlzaW9ucyBjYW4gb2NjdXJcbmNvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlciA9ICdfX2V2ZXJsaXZlX29mZmxpbmVfc3RhdGUnO1xuXG5jb25zdGFudHMuU3luY0Vycm9ycyA9IHtcbiAgICBnZW5lcmFsRXJyb3I6ICdnZW5lcmFsRXJyb3InLFxuICAgIGl0ZW1TeW5jRXJyb3I6ICdpdGVtU3luY0Vycm9yJ1xufTtcblxuY29uc3RhbnRzLnN5bmNCYXRjaFNpemUgPSAxMDtcblxuY29uc3RhbnRzLkF1dGhTdG9yZUtleSA9ICdfX2V2ZXJsaXZlX2F1dGhfa2V5JztcblxuLy8gdGhlIG1pbmltdW0gaW50ZXJ2YWwgYmV0d2VlbiBzeW5jIHJlcXVlc3RzXG5jb25zdGFudHMuZGVmYXVsdFN5bmNJbnRlcnZhbCA9IDEwMDAgKiA2MCAqIDEwOyAvLyAxMCBtaW51dGVzXG5jb25zdGFudHMuZmlsZVVwbG9hZEtleSA9ICdmaWxlVXBsb2FkJztcbmNvbnN0YW50cy5maWxlVXBsb2FkRGVsaW1pdGVyID0gJ18nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50cztcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJ25vZGUtY3J5cHRvanMtYWVzJykuQ3J5cHRvSlM7XG52YXIgQUVTID0gQ3J5cHRvSlMuQUVTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBDcnlwdG9ncmFwaGljUHJvdmlkZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIENyeXB0b2dyYXBoaWNQcm92aWRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9nZXRLZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZW5jcnlwdGlvbi5rZXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NhbkVuY3J5cHREZWNyeXB0OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEtleSgpICYmIGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhbkVuY3J5cHREZWNyeXB0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBBRVMuZW5jcnlwdChjb250ZW50LCB0aGlzLl9nZXRLZXkoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5FbmNyeXB0RGVjcnlwdChjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gQUVTLmRlY3J5cHQoY29udGVudCwgdGhpcy5fZ2V0S2V5KCkpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyO1xufSgpKTsiLCJ2YXIgaXNOYXRpdmVTY3JpcHQgPSBCb29sZWFuKCgodHlwZW9mIGFuZHJvaWQgIT09ICd1bmRlZmluZWQnICYmIGFuZHJvaWQgJiYgYW5kcm9pZC53aWRnZXQgJiYgYW5kcm9pZC53aWRnZXQuQnV0dG9uKVxuICAgIHx8ICh0eXBlb2YgVUlCdXR0b24gIT09ICd1bmRlZmluZWQnICYmIFVJQnV0dG9uKSkpO1xuXG5pZiAoaXNOYXRpdmVTY3JpcHQpIHtcbiAgICBnbG9iYWwud2luZG93ID0ge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlOiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKCkgeyB9IC8vc2hpbSBmb3IgbW9uZ28tcXVlcnkgdW5kZXIgbmF0aXZlc2NyaXB0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGlzQ29yZG92YSA9IC9eZmlsZTpcXC97M31bXlxcL118eC13bWFwcC9pLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpICYmIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGllbW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgaXNXaW5kb3dzUGhvbmUgPSBpc0NvcmRvdmEgJiYgL2llbW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgaXNBbmRyb2lkID0gaXNDb3Jkb3ZhICYmIGNvcmRvdmEucGxhdGZvcm1JZCA9PT0gJ2FuZHJvaWQnO1xufVxuXG52YXIgaXNOb2RlanMgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG52YXIgaXNSZXF1aXJlanMgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XG52YXIgaXNEZXNrdG9wID0gIWlzTmF0aXZlU2NyaXB0ICYmICFpc0NvcmRvdmEgJiYgIWlzTm9kZWpzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc0NvcmRvdmE6IGlzQ29yZG92YSxcbiAgICBpc05hdGl2ZVNjcmlwdDogaXNOYXRpdmVTY3JpcHQsXG4gICAgaXNEZXNrdG9wOiBpc0Rlc2t0b3AsXG4gICAgaXNXaW5kb3dzUGhvbmU6IGlzV2luZG93c1Bob25lLFxuICAgIGlzQW5kcm9pZDogaXNBbmRyb2lkLFxuICAgIGlzTm9kZWpzOiBpc05vZGVqcyxcbiAgICBpc1JlcXVpcmVqczogaXNSZXF1aXJlanNcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBIZWxwZXJzXG4gKiBAY2xhc3NkZXNjIEV2ZXJsaXZlIGhlbHBlciBjbGFzc2VzXG4gKi9cblxudmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKTtcblxudmFyIGhlbHBlcnMgPSBbXTtcblxudmFyIGh0bWxIZWxwZXIgPSByZXF1aXJlKCcuL2h0bWwvaHRtbEhlbHBlcicpO1xuXG5pZiAocGxhdGZvcm0uaXNDb3Jkb3ZhIHx8IHBsYXRmb3JtLmlzRGVza3RvcCkge1xuICAgIGhlbHBlcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdodG1sJyxcbiAgICAgICAgY3RvcjogaHRtbEhlbHBlclxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhlbHBlcnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLi8uLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xudmFyIF8gPSBjb21tb24uXztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xudmFyIEh0bWxIZWxwZXJSZXNwb25zaXZlTW9kdWxlID0gcmVxdWlyZSgnLi9odG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZScpO1xudmFyIEh0bWxIZWxwZXJPZmZsaW5lTW9kdWxlID0gcmVxdWlyZSgnLi9odG1sSGVscGVyT2ZmbGluZU1vZHVsZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cycpO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBFdmVudEVtaXR0ZXJQcm94eSA9IHJlcXVpcmUoJy4uLy4uL0V2ZW50RW1pdHRlclByb3h5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIHByb2Nlc3NPbkxvYWQ6IGZhbHNlLFxuICAgICAgICBwcm9jZXNzT25SZXNpemU6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nSW1hZ2VVcmw6ICcnLFxuICAgICAgICBlcnJvckltYWdlVXJsOiAnJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgbG9hZGluZ0ltYWdlOiAnZGF0YS1sb2FkaW5nLWltYWdlJyxcbiAgICAgICAgICAgIGVycm9ySW1hZ2U6ICdkYXRhLWVycm9yLWltYWdlJyxcbiAgICAgICAgICAgIGRwaTogJ2RhdGEtZHBpJyxcbiAgICAgICAgICAgIGltYWdlU291cmNlOiAnZGF0YS1zcmMnLFxuICAgICAgICAgICAgZmlsZVNvdXJjZTogJ2RhdGEtaHJlZicsXG4gICAgICAgICAgICBlbmFibGVPZmZsaW5lOiAnZGF0YS1vZmZsaW5lJyxcbiAgICAgICAgICAgIGVuYWJsZVJlc3BvbnNpdmU6ICdkYXRhLXJlc3BvbnNpdmUnXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgSGVscGVycy5odG1sXG4gICAgICogQGRlc2NyaXB0aW9uIEV2ZXJsaXZlIGhlbHBlciBmb3IgaHRtbCByZWxhdGVkIG9wZXJhdGlvbnMsIHN1Y2ggYXMgcHJvY2Vzc2luZyBodG1sIGVsZW1lbnRzIHdpdGggc3BlY2lmaWMgdGFncy5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEh0bWxIZWxwZXIoZXZlcmxpdmUsIGNvbmZpZykge1xuICAgICAgICBFdmVudEVtaXR0ZXJQcm94eS5hcHBseSh0aGlzKTtcblxuICAgICAgICB0aGlzLl9ldmVybGl2ZSA9IGV2ZXJsaXZlO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIHVybFRlbXBsYXRlOiAnW3Byb3RvY29sXVtob3N0bmFtZV1bYXBpa2V5XS9bb3BlcmF0aW9uc11bdXJsXScsXG4gICAgICAgICAgICBzZXJ2ZXI6ICdiczEuY2RuLnRlbGVyaWsuY29tL2ltYWdlL3YxLydcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIGRlZmF1bHRzLCBjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXR0cmlidXRlcyA9IF8uZXh0ZW5kKHt9LCBkZWZhdWx0cy5hdHRyaWJ1dGVzLCBjb25maWcuYXR0cmlidXRlcyk7XG5cbiAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZSA9IG5ldyBIdG1sSGVscGVyUmVzcG9uc2l2ZU1vZHVsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fb2ZmbGluZSA9IG5ldyBIdG1sSGVscGVyT2ZmbGluZU1vZHVsZSh0aGlzKTtcblxuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuXG4gICAgSHRtbEhlbHBlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucHJvY2Vzc09uTG9hZCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5wcm9jZXNzQWxsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9jZXNzT25SZXNpemUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgXy5kZWJvdW5jZSh0aGlzLnByb2Nlc3NBbGwuYmluZCh0aGlzKSwgMzAwKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF90cmlnZ2VyT25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIF90cmlnZ2VyT25Qcm9jZXNzZWQoYXJncykge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5lbWl0KCdwcm9jZXNzZWQnLCBhcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGVmYXVsdFByb2Nlc3NTZXR0aW5nczogZnVuY3Rpb24gX2RlZmF1bHRQcm9jZXNzU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgb2ZmbGluZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldExvYWRpbmdVcmw6IGZ1bmN0aW9uIF9zZXRMb2FkaW5nVXJsKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nSW1hZ2VVcmkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMuYXR0cmlidXRlcy5sb2FkaW5nSW1hZ2UpIHx8IHRoaXMub3B0aW9ucy5sb2FkaW5nSW1hZ2VVcmw7XG4gICAgICAgICAgICBpZiAoIWxvYWRpbmdJbWFnZVVyaSB8fCB1dGlscy5pc0VsZW1lbnQuYW5jaG9yKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRVcmwoZWxlbWVudCwgbG9hZGluZ0ltYWdlVXJpLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0QmFja2dyb3VuZFNyYzogZnVuY3Rpb24gX2dldEJhY2tncm91bmRTcmMoZWwpIHtcbiAgICAgICAgICAgIHZhciBlbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xuICAgICAgICAgICAgdmFyIGJhY2tnckltYWdlID0gZWxTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG5cbiAgICAgICAgICAgIHZhciBpbWcgPSBiYWNrZ3JJbWFnZSAhPT0gJ25vbmUnID8gYmFja2dySW1hZ2UgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgICAgICBpbWcgPSBpbWcucmVwbGFjZSgvdXJsXFwoKCc/XCI/KSguKj8pXFwxXFwpL2dpLCAnJDInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltZztcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0RXJyb3JVcmw6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JJbWFnZVVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmVycm9ySW1hZ2UpIHx8IHRoaXMub3B0aW9ucy5lcnJvckltYWdlVXJsO1xuICAgICAgICAgICAgaWYgKCFlcnJvckltYWdlVXJsIHx8IHV0aWxzLmlzRWxlbWVudC5hbmNob3IoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFVybChlbGVtZW50LCBlcnJvckltYWdlVXJsLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0VXJsOiBmdW5jdGlvbiBfc2V0VXJsKGVsZW1lbnQsIHVybCwgYXBwbHkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxBdHRyID0gc2VsZi5fZ2V0QXR0cihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNFbGVtZW50LmltYWdlKGVsZW1lbnQpICYmIGVsQXR0ciA9PT0gc2VsZi5vcHRpb25zLmF0dHJpYnV0ZXMuaW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoJ0NhblxcJ3QgYmUgbG9hZGVkOiAnICsgdXJsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2V0VXJsKGVsZW1lbnQsIHVybCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbEF0dHIgPT09IHNlbGYub3B0aW9ucy5hdHRyaWJ1dGVzLmltYWdlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9ICdzcmMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbEF0dHIgPT09IHNlbGYub3B0aW9ucy5hdHRyaWJ1dGVzLmZpbGVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gJ2hyZWYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gXy5sYXN0KGVsQXR0ci5zcGxpdCgnLScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgdXJsICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0QXR0cjogZnVuY3Rpb24gX2dldEF0dHIoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmltYWdlU291cmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRlcy5pbWFnZVNvdXJjZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmZpbGVTb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmZpbGVTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFVybDogZnVuY3Rpb24gX2dldFVybChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMuaW1hZ2VTb3VyY2UpXG4gICAgICAgICAgICAgICAgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMuZmlsZVNvdXJjZSlcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9nZXRCYWNrZ3JvdW5kU3JjKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93cmFwRWxlbWVudHM6IGZ1bmN0aW9uIF93cmFwRWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfLm1hcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXZhbHVhdGVEYXRhQXR0ciA9IGZ1bmN0aW9uIGV2YWx1YXRlRGF0YUF0dHIoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhLWEgLSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEtYT1cIlwiIC0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhLWE9XCJ0cnVlXCIgLSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEtYT1cImFueXRoaW5nXCIgLSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEtYT1cImZhbHNlXCIgLSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAvLyBtaXNzaW5nIC0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFWYWwgPSAoZWxlbWVudC5hdHRyaWJ1dGVzW2F0dHJdIHx8IHt2YWx1ZTogbnVsbH0pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRhdGFWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBKU09OLnBhcnNlKGRhdGFWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FuUmVzcG9uc2l2ZSA9IGV2YWx1YXRlRGF0YUF0dHIoc2VsZi5vcHRpb25zLmF0dHJpYnV0ZXMuZW5hYmxlUmVzcG9uc2l2ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbk9mZmxpbmUgPSBldmFsdWF0ZURhdGFBdHRyKHNlbGYub3B0aW9ucy5hdHRyaWJ1dGVzLmVuYWJsZU9mZmxpbmUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IGNhblJlc3BvbnNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lOiBjYW5PZmZsaW5lXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2Nlc3NcbiAgICAgICAgICogQG1lbWJlck9mIEhlbHBlcnMuaHRtbFxuICAgICAgICAgKiBAcGFyYW0ge0h0bWxFbGVtZW50fEh0bWxFbGVtZW50W119IGVsZW1lbnRzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBBIHNldHRpbmdzIHNwZWNpZnlpbmcgY3VzdG9tIGJlaGF2aW9yLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5yZXNwb25zaXZlXSBXaGV0aGVyIHRvIHByb2Nlc3MgdGhlIGRhdGEtcmVzcG9uc2l2ZSBhdHRyaWJ1dGVzIHRoYXQgaGVscCBpbXBsZW1lbnQgUmVzcG9uc2l2ZSBJbWFnZXMuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldHRpbmdzLm9mZmxpbmVdIFdoZXRoZXIgdG8gcHJvY2VzcyB0aGUgZGF0YS1vZmZsaW5lIGF0dHJpYnV0ZXMgdGhhdCBoZWxwIGltcGxlbWVudCBvZmZsaW5lIGZpbGVzLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBwcm9jZXNzXG4gICAgICAgICAqIEBtZW1iZXJPZiBIZWxwZXJzLmh0bWxcbiAgICAgICAgICogQHBhcmFtIHtIdG1sRWxlbWVudHxIdG1sRWxlbWVudFtdfSBlbGVtZW50c1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgQSBzZXR0aW5ncyBzcGVjaWZ5aW5nIGN1c3RvbSBiZWhhdmlvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3MucmVzcG9uc2l2ZV0gV2hldGhlciB0byBwcm9jZXNzIHRoZSBkYXRhLXJlc3BvbnNpdmUgYXR0cmlidXRlcyB0aGF0IGhlbHAgaW1wbGVtZW50IFJlc3BvbnNpdmUgSW1hZ2VzLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5vZmZsaW5lXSBXaGV0aGVyIHRvIHByb2Nlc3MgdGhlIGRhdGEtb2ZmbGluZSBhdHRyaWJ1dGVzIHRoYXQgaGVscCBpbXBsZW1lbnQgb2ZmbGluZSBmaWxlcy5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0byB0aGUgcHJvY2VzcyBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoZWxlbWVudHMsIHNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSBzZWxmLl9kZWZhdWx0UHJvY2Vzc1NldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KGVsZW1lbnRzKSB8fCBlbGVtZW50cyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IF8uZmxhdHRlbihlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkRWxlbWVudHMgPSBzZWxmLl93cmFwRWxlbWVudHMoZWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIF8uZWFjaCh3cmFwcGVkRWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50Lml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmxpbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFVcmwgPSBzZWxmLl9nZXRVcmwocmVzdWx0LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLnB1c2godXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuUmVzcG9uc2l2ZSA9IHNldHRpbmdzLnJlc3BvbnNpdmUgPyBlbGVtZW50Lm9wZXJhdGlvbnMucmVzcG9uc2l2ZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuT2ZmbGluZSA9IHNldHRpbmdzLm9mZmxpbmUgPyBlbGVtZW50Lm9wZXJhdGlvbnMub2ZmbGluZSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuUmVzcG9uc2l2ZSAmJiAhY2FuT2ZmbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLnB1c2goc2VsZi5fc2V0VXJsKHJlc3VsdC5lbGVtZW50LCBkYXRhVXJsLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuX3NldExvYWRpbmdVcmwocmVzdWx0LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlT3BlcmF0aW9uID0gZnVuY3Rpb24gaGFuZGxlT3BlcmF0aW9uKG9wZXJhdGlvbiwgdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W29wZXJhdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhblJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZXNwb25zaXZlLnJlc3BvbnNpdmVJbWFnZShlbGVtZW50LCBkYXRhVXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihoYW5kbGVPcGVyYXRpb24uYmluZCh0aGlzLCAncmVzcG9uc2l2ZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbk9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNpdmVTcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZS5wcm9jZXNzT2ZmbGluZShyZXNwb25zaXZlU3JjIHx8IGRhdGFVcmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGhhbmRsZU9wZXJhdGlvbi5iaW5kKHRoaXMsICdvZmZsaW5lJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChmaW5hbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NldFVybChyZXN1bHQuZWxlbWVudCwgZmluYWxVcmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fc2V0RXJyb3JVcmwocmVzdWx0LmVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiByZXN1bHQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcnN2cC5hbGxTZXR0bGVkKHByb21pc2VzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWxlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gocmVzdWx0cywgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdGUgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkLnB1c2gocmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkOiBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyaWdnZXJPblByb2Nlc3NlZChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBwcm9jZXNzQWxsXG4gICAgICAgICAqIEBtZW1iZXJPZiBIZWxwZXJzLmh0bWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIEEgc2V0dGluZ3Mgc3BlY2lmeWluZyBjdXN0b20gYmVoYXZpb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldHRpbmdzLnJlc3BvbnNpdmVdIFdoZXRoZXIgdG8gcHJvY2VzcyB0aGUgZGF0YS1yZXNwb25zaXZlIGF0dHJpYnV0ZXMgdGhhdCBoZWxwIGltcGxlbWVudCBSZXNwb25zaXZlIEltYWdlcy5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3Mub2ZmbGluZV0gV2hldGhlciB0byBwcm9jZXNzIHRoZSBkYXRhLW9mZmxpbmUgYXR0cmlidXRlcyB0aGF0IGhlbHAgaW1wbGVtZW50IG9mZmxpbmUgZmlsZXMuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2Nlc3NBbGxcbiAgICAgICAgICogQG1lbWJlck9mIEhlbHBlcnMuaHRtbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgQSBzZXR0aW5ncyBzcGVjaWZ5aW5nIGN1c3RvbSBiZWhhdmlvci5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0dGluZ3MucmVzcG9uc2l2ZV0gV2hldGhlciB0byBwcm9jZXNzIHRoZSBkYXRhLXJlc3BvbnNpdmUgYXR0cmlidXRlcyB0aGF0IGhlbHAgaW1wbGVtZW50IFJlc3BvbnNpdmUgSW1hZ2VzLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXR0aW5ncy5vZmZsaW5lXSBXaGV0aGVyIHRvIHByb2Nlc3MgdGhlIGRhdGEtb2ZmbGluZSBhdHRyaWJ1dGVzIHRoYXQgaGVscCBpbXBsZW1lbnQgb2ZmbGluZSBmaWxlcy5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSB0byB0aGUgcHJvY2VzcyBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NBbGw6IGZ1bmN0aW9uIHByb2Nlc3NBbGwoc2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHRoaXMuX2RlZmF1bHRQcm9jZXNzU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNpdmVTZWxlY3RvciA9ICdbJyArIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVzLmVuYWJsZVJlc3BvbnNpdmUgKyAnXSc7XG4gICAgICAgICAgICB2YXIgb2ZmbGluZVNlbGVjdG9yID0gJ1snICsgdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMuZW5hYmxlT2ZmbGluZSArICddJztcblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNpdmVFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHJlc3BvbnNpdmVTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmZsaW5lRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgb2ZmbGluZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChvZmZsaW5lU2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IF8udW5pcXVlKHNsaWNlLmNhbGwocmVzcG9uc2l2ZUVsZW1lbnRzKS5jb25jYXQoc2xpY2UuY2FsbChvZmZsaW5lRWxlbWVudHMpKSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2VzcyhlbGVtZW50cywgc2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gSHRtbEhlbHBlcjtcbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG52YXIgRXZlcmxpdmVFcnJvck1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL0V2ZXJsaXZlRXJyb3InKTtcbnZhciBFdmVybGl2ZUVycm9ycyA9IEV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcnM7XG52YXIgRXZlcmxpdmVFcnJvciA9IEV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xudmFyIF8gPSBjb21tb24uXztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxIZWxwZXJPZmZsaW5lTW9kdWxlKGh0bWxIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5odG1sSGVscGVyID0gaHRtbEhlbHBlcjtcbiAgICB9XG5cbiAgICBIdG1sSGVscGVyT2ZmbGluZU1vZHVsZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHByb2Nlc3NPZmZsaW5lOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5odG1sSGVscGVyLl9ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5yZWplY3RlZFByb21pc2UobmV3IEV2ZXJsaXZlRXJyb3IoJ09mZmxpbmUgc3RvcmFnZSBtdXN0IGJlIGVuYWJsZWQgaW4gb3JkZXIgdG8gdXNlIHRoZSBvZmZsaW5lIGZlYXR1cmVzIG9mIHRoZSBpbWFnZXMgY29tcG9uZW50LicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaHRtbEhlbHBlci5fZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuZmlsZXMuZG93bmxvYWRPZmZsaW5lKHVybClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYWxVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsVXJsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gRXZlcmxpdmVFcnJvcnMuY2Fubm90RG93bmxvYWRPZmZsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5odG1sSGVscGVyLl9ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0T2ZmbGluZUZpbGVzRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkRmlsZSA9IF8uZmluZChvZmZsaW5lRmlsZXNEYXRhLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Lm9ubGluZUxvY2F0aW9uICYmIGVudHJ5Lm9mZmxpbmVMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ubGluZUxvY2F0aW9uID0gZW50cnkub25saW5lTG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZW5hbWVJbmRleCA9IG9ubGluZUxvY2F0aW9uLmxhc3RJbmRleE9mKGJhc2VuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlbmFtZUluZGV4ICE9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZEZpbGUub2ZmbGluZUxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDYW5ub3QgZmluZCBvZmZsaW5lIGltYWdlICcgKyB1cmwsIEV2ZXJsaXZlRXJyb3JzLm1pc3NpbmdPckludmFsaWRGaWxlQ29udGVudC5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBIdG1sSGVscGVyT2ZmbGluZU1vZHVsZTtcbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uJyk7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbEhlbHBlclJlc3BvbnNpdmVNb2R1bGUoaHRtbEhlbHBlcikge1xuICAgICAgICB0aGlzLmh0bWxIZWxwZXIgPSBodG1sSGVscGVyO1xuICAgIH1cblxuICAgIEh0bWxIZWxwZXJSZXNwb25zaXZlTW9kdWxlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0QmFja2dyb3VuZFdpZHRoOiBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kV2lkdGgoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoZWwub2Zmc2V0V2lkdGgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlUGFyYW1zU3RyaW5nOiBmdW5jdGlvbiBwYXJzZVBhcmFtc1N0cmluZyhzdHIpIHtcbiAgICAgICAgICAgIGlmICghc3RyIHx8IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnIHx8IHN0ci5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzVXNlclJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRtcCA9IHN0ci5zcGxpdCgnLycpO1xuICAgICAgICAgICAgdmFyIGlpID0gdG1wLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0bXBbaV0uc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICAgICAgdG1wT2JqID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzFdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzFdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsxXSA9IHVuZXNjYXBlKGl0ZW1bMV0ucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRtcE9ialtpdGVtWzBdXSA9IGl0ZW1bMV07XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2godG1wT2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVswXSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNVc2VyUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGlzVXNlclJlc2l6ZTogaXNVc2VyUmVzaXplXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEltZ1BhcmFtczogZnVuY3Rpb24gZ2V0SW1nUGFyYW1zKHNyYykge1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnM7XG4gICAgICAgICAgICB2YXIgaW1nVXJsID0gc3JjLnJlcGxhY2UoLy4qP3Jlc2l6ZT1bXi8vXSpcXC8vZ2ksICcnKTtcbiAgICAgICAgICAgIHZhciBwcm90b2NvbFJlID0gbmV3IFJlZ0V4cCgnaHR0cHM/Oi8vJywgJ2dpJyk7XG4gICAgICAgICAgICB2YXIgc2VydmVyUmUgPSBuZXcgUmVnRXhwKHRoaXMuaHRtbEhlbHBlci5fc2V0dGluZ3Muc2VydmVyLCAnZ2knKTtcbiAgICAgICAgICAgIHZhciBhcGlLZXlSZSA9IG5ldyBSZWdFeHAodGhpcy5odG1sSGVscGVyLl9ldmVybGl2ZS5hcGlLZXkgKyAnLycsICdnaScpO1xuXG4gICAgICAgICAgICBvcGVyYXRpb25zID0gc3JjLnJlcGxhY2UoaW1nVXJsLCAnJykucmVwbGFjZShwcm90b2NvbFJlLCAnJykucmVwbGFjZShzZXJ2ZXJSZSwgJycpLnJlcGxhY2UoYXBpS2V5UmUsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbnMgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucyA9IG9wZXJhdGlvbnMuaW5kZXhPZignLycpID8gb3BlcmF0aW9ucy5zdWJzdHJpbmcoMCwgb3BlcmF0aW9ucy5sZW5ndGggLSAxKSA6IG9wZXJhdGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3BlcmF0aW9ucyA9IHRoaXMucGFyc2VQYXJhbXNTdHJpbmcob3BlcmF0aW9ucyk7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIGEgdXNlciByZXNpemUgb3BlcmF0aW9uLCB1c2UgdGhlIHBhc3NlZCB1cmwgaW4gdGhlIGRhdGEtc3JjIHByb3BlcnR5XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9ucy5pc1VzZXJSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBpbWdVcmwgPSBzcmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW1nVXJsOiBpbWdVcmwsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uczogb3BlcmF0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICAgICAgaXNVc2VyUmVzaXplOiBvcGVyYXRpb25zLmlzVXNlclJlc2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcoPzpcXFxcc3xeKScgKyBjbCArICcoPzpcXFxcc3wkKScpO1xuICAgICAgICAgICAgcmV0dXJuICEhZWwuY2xhc3NOYW1lLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJbWFnZVdpZHRoOiBmdW5jdGlvbiBnZXRJbWFnZVdpZHRoKGVsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFdpZHRoID0gcGFyZW50RWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgaXRlbVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50RWwsIG51bGwpO1xuICAgICAgICAgICAgdmFyIHBsID0gcGFyc2VGbG9hdChpdGVtU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1sZWZ0JykpO1xuICAgICAgICAgICAgdmFyIHByID0gcGFyc2VGbG9hdChpdGVtU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcbiAgICAgICAgICAgIHZhciBibCA9IHBhcnNlRmxvYXQoaXRlbVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJykpO1xuICAgICAgICAgICAgdmFyIGJyID0gcGFyc2VGbG9hdChpdGVtU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXJpZ2h0LXdpZHRoJykpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMocGFyZW50V2lkdGggLSBNYXRoLmNlaWwocGwgKyBwciArIGJsICsgYnIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXREZXZpY2VQaXhlbFJhdGlvOiBmdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBpeGVsUmF0aW86ZnVuY3Rpb24gZ2V0UGl4ZWxSYXRpbyhlbCkge1xuICAgICAgICAgICAgdmFyIHBpeGVsRGVuc2l0eSA9IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmh0bWxIZWxwZXIub3B0aW9ucy5hdHRyaWJ1dGVzLmRwaSkgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxEZW5zaXR5ICE9PSAnJyA/IF8uaXNOdW1iZXIocGl4ZWxEZW5zaXR5KSA/IHBhcnNlRmxvYXQocGl4ZWxEZW5zaXR5KSA6IGZhbHNlIDogdGhpcy5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW1nUGFyYW1zU3RyaW5nOiBmdW5jdGlvbiBnZXRJbWdQYXJhbXNTdHJpbmcoaW1hZ2UsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHBhcmFtc1N0ciA9ICcnO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgdmFyIGlpID0gcGFyYW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfLmtleXMoaXRlbSlbMF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc0VsZW1lbnQuaW1hZ2UoaW1hZ2UpICYmIGtleSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxSYXRpbyhpbWFnZS5pdGVtKTtcbiAgICAgICAgICAgICAgICBwaXhlbERlbnNpdHkgPSAocGl4ZWxEZW5zaXR5KSA/ICcscGQ6JyArIHBpeGVsRGVuc2l0eSA6ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IChrZXkgPT09ICdyZXNpemUnKSA/IGl0ZW1ba10gKyBwaXhlbERlbnNpdHkgOiBpdGVtW2tdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmFtc1N0ciArPSBrZXkgKyAnPScgKyB2YWx1ZSArICcvJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtc1N0cjtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNwb25zaXZlSW1hZ2U6IGZ1bmN0aW9uIHJlc3BvbnNpdmVJbWFnZShpdGVtLCBkYXRhU3JjKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBfLmV4dGVuZCh7fSwgaXRlbSk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGltYWdlLml0ZW07XG4gICAgICAgICAgICB2YXIgdGFnID0gaW1hZ2UudGFnO1xuXG4gICAgICAgICAgICB2YXIgaXNJbWFnZSA9IHV0aWxzLmlzRWxlbWVudC5pbWFnZSh0YWcpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoO1xuXG4gICAgICAgICAgICBpbWFnZSA9IF8uZXh0ZW5kKHt9LCBpbWFnZSwgc2VsZi5nZXRJbWdQYXJhbXMoZGF0YVNyYykpO1xuXG4gICAgICAgICAgICBpZiAoIWltYWdlLmlzVXNlclJlc2l6ZSkge1xuICAgICAgICAgICAgICAgIGltZ1dpZHRoID0gKCFpc0ltYWdlKSA/IHNlbGYuZ2V0QmFja2dyb3VuZFdpZHRoKGVsZW1lbnQpIDogc2VsZi5nZXRJbWFnZVdpZHRoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbWdXaWR0aCA9IGltZ1dpZHRoID8gaW1nV2lkdGggOiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBpbWFnZS5pc1VzZXJSZXNpemUgPyBpbWFnZS5pbWdVcmwgOiBzZWxmLmdldEltZ1NyYyhpbWFnZSwgaW1nV2lkdGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghaW1nV2lkdGggJiYgIWltYWdlLmlzVXNlclJlc2l6ZSkgeyAvLyB3ZSBkb24ndCBoYXZlIHRoZSB3aWR0aCBvZiB0aGUgdXNlciBpbWFnZSBlaXRoZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZWxlbWVudCBpcyBub3QgdmlzaWJsZSwgd2UgZG9uJ3QgaGF2ZSB0byBwcm9jZXNzIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc3JjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEltZ1NyYzogZnVuY3Rpb24gZ2V0SW1nU3JjKGltYWdlLCBpbWdXaWR0aCkge1xuICAgICAgICAgICAgdmFyIHByb3RvY29sID0gdGhpcy5odG1sSGVscGVyLl9ldmVybGl2ZS5zZXR1cC5zY2hlbWUgKyAnOi8vJztcbiAgICAgICAgICAgIHZhciBhcGlLZXkgPSB0aGlzLmh0bWxIZWxwZXIuX2V2ZXJsaXZlLnNldHVwLmFwaUtleTtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSB0aGlzLmh0bWxIZWxwZXIuX3NldHRpbmdzLnNlcnZlcjtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLmh0bWxIZWxwZXIuX3NldHRpbmdzLnVybFRlbXBsYXRlO1xuICAgICAgICAgICAgdmFyIHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxSYXRpbyhpbWFnZS5pdGVtKTtcblxuICAgICAgICAgICAgcGl4ZWxEZW5zaXR5ID0gcGl4ZWxEZW5zaXR5ID8gJyxwZDonICsgcGl4ZWxEZW5zaXR5IDogJyc7XG5cbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCdbcHJvdG9jb2xdJywgcHJvdG9jb2wpO1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1thcGlrZXldJywgYXBpS2V5ID8gYXBpS2V5IDogJycpO1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1tob3N0bmFtZV0nLCBzZXJ2ZXIpO1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gaW1hZ2Uub3BlcmF0aW9ucyB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9ICcnO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMuZ2V0SW1nUGFyYW1zU3RyaW5nKGltYWdlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0VsZW1lbnQuaW1hZ2UoaW1hZ2UudGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zID0gaW1nV2lkdGggPyAncmVzaXplPXc6JyArIGltZ1dpZHRoICsgcGl4ZWxEZW5zaXR5ICsgJy8nICsgcGFyYW1zIDogcGFyYW1zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMgPSAncmVzaXplPXc6JyArIGltZ1dpZHRoICsgcGl4ZWxEZW5zaXR5ICsgJy8nICsgcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgnW29wZXJhdGlvbnNdJywgb3BlcmF0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCdbb3BlcmF0aW9uc10nLCAncmVzaXplPXc6JyArIGltZ1dpZHRoICsgcGl4ZWxEZW5zaXR5ICsgJy8nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJ1t1cmxdJywgaW1hZ2UuaW1nVXJsKTtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEh0bWxIZWxwZXJSZXNwb25zaXZlTW9kdWxlO1xufSgpKTsiLCIvKiFcbiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiBDb3B5cmlnaHQgKGMpIDIwMTMgVGVsZXJpayBBRFxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUueSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbi8qIVxuIEV2ZXJsaXZlIFNES1xuIFZlcnNpb24gMS40LjFcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuL0V2ZXJsaXZlJyk7XG4gICAgdmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4gICAgaWYgKCFwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdCAmJiAhcGxhdGZvcm0uaXNOb2RlanMpIHtcbiAgICAgICAgdmFyIGtlbmRvID0gcmVxdWlyZSgnLi9rZW5kby9rZW5kby5ldmVybGl2ZScpO1xuICAgICAgICBFdmVybGl2ZS5jcmVhdGVEYXRhU291cmNlID0ga2VuZG8uY3JlYXRlRGF0YVNvdXJjZTtcbiAgICAgICAgRXZlcmxpdmUuY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZSA9IGtlbmRvLmNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2U7XG4gICAgfVxuXG4gICAgLy9HbG9iYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHB1c2ggbm90aWZpY2F0aW9uIGV2ZW50cy4gUmVxdWlyZWQgYnkgdGhlIGNvcmRvdmEgUHVzaE5vdGlmaWNhdGlvbnMgcGx1Z2luIHRoYXQgd2UgdXNlLlxuICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3MgPSB7fTtcbiAgICBFdmVybGl2ZS5PZmZsaW5lID0ge307XG5cbiAgICBFdmVybGl2ZS5RdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkvUXVlcnknKTtcbiAgICBFdmVybGl2ZS5RdWVyeUJ1aWxkZXIgPSByZXF1aXJlKCcuL3F1ZXJ5L1F1ZXJ5QnVpbGRlcicpO1xuICAgIEV2ZXJsaXZlLkdlb1BvaW50ID0gcmVxdWlyZSgnLi9HZW9Qb2ludCcpO1xuICAgIEV2ZXJsaXZlLkNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG4gICAgRXZlcmxpdmUuUmVxdWVzdCA9IHJlcXVpcmUoJy4vUmVxdWVzdCcpO1xuICAgIEV2ZXJsaXZlLkRhdGEgPSByZXF1aXJlKCcuL3R5cGVzL0RhdGEnKTtcbiAgICBFdmVybGl2ZS5fdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgRXZlcmxpdmUuX3RyYXZlcnNlQW5kUmV2aXZlID0gRXZlcmxpdmUuX3V0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlQW5kUmV2aXZlO1xuICAgIEV2ZXJsaXZlLl9jb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG4gICAgdmFyIHBlcnNpc3RlcnNNb2R1bGUgPSByZXF1aXJlKCcuL29mZmxpbmUvb2ZmbGluZVBlcnNpc3RlcnMnKTtcbiAgICBFdmVybGl2ZS5wZXJzaXN0ZXIgPSB7XG4gICAgICAgIExvY2FsU3RvcmFnZTogcGVyc2lzdGVyc01vZHVsZS5Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXIsXG4gICAgICAgIEZpbGVTeXN0ZW06IHBlcnNpc3RlcnNNb2R1bGUuRmlsZVN5c3RlbVBlcnNpc3RlclxuICAgIH07XG5cbiAgICAvL2V2ZXJsaXZlTW9kdWxlIGlzIHByb3ZpZGVkIGJ5IGEgY2xvc3VyZSBnZW5lcmF0ZWQgZHVyaW5nIGJ1aWxkXG4gICAgaWYgKHBsYXRmb3JtLmlzTm9kZWpzIHx8IHBsYXRmb3JtLmlzTmF0aXZlU2NyaXB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlcmxpdmVNb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBldmVybGl2ZU1vZHVsZS5leHBvcnRzID0gRXZlcmxpdmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZlcmxpdmU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvL2luIHJlcXVpcmVqcyBFdmVybGl2ZSBpcyBkZWZpbmVkIGluIHRoZSBzYW1lIGNsb3N1cmVcbiAgICAgICAgLy9icm93c2VyXG4gICAgICAgIGNvbW1vbi5yb290LkV2ZXJsaXZlID0gRXZlcmxpdmU7XG4gICAgfVxufSgpKTsiLCJ2YXIgUXVlcnlCdWlsZGVyID0gcmVxdWlyZSgnLi4vcXVlcnkvUXVlcnlCdWlsZGVyJyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9RdWVyeScpO1xudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XG52YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuLi9FdmVybGl2ZScpO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5qUXVlcnkgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cua2VuZG8gPT09ICd1bmRlZmluZWQnIHx8IF8uaXNFbXB0eSh3aW5kb3cua2VuZG8uZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciAkID0gd2luZG93LmpRdWVyeTtcbiAgICB2YXIga2VuZG8gPSB3aW5kb3cua2VuZG87XG5cbiAgICB2YXIgZXh0ZW5kID0gJC5leHRlbmQ7XG5cbiAgICB2YXIgZXZlcmxpdmVUcmFuc3BvcnQgPSBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5leHRlbmQoe1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5ldmVybGl2ZSQgPSBvcHRpb25zLmRhdGFQcm92aWRlciB8fCBFdmVybGl2ZS4kO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZXJsaXZlJCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5zdGFuY2Ugb2YgdGhlIEJhY2tlbmQgc2VydmljZXMgc2RrIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSB0eXBlIG5hbWUgbXVzdCBiZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFDb2xsZWN0aW9uID0gdGhpcy5ldmVybGl2ZSQuZGF0YShvcHRpb25zLnR5cGVOYW1lKTtcbiAgICAgICAgICAgIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLmluaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1sncmVhZCddO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24udXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHRyYW5zbGF0ZUtlbmRvUXVlcnkob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgIHZhciBldmVybGl2ZVF1ZXJ5ID0gbmV3IFF1ZXJ5KHF1ZXJ5LiR3aGVyZSwgbnVsbCwgcXVlcnkuJHNvcnQsIHF1ZXJ5LiRza2lwLCBxdWVyeS4kdGFrZSk7XG4gICAgICAgICAgICB2YXIgaWQgPSBvcHRpb25zLmRhdGEuSWQ7XG5cbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5nZXRCeUlkKGlkKS50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcikuY2F0Y2gob3B0aW9ucy5lcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5nZXQoZXZlcmxpdmVRdWVyeSkudGhlbihvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpLmNhdGNoKG9wdGlvbnMuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RPcHRpb24gPSB0aGlzLm9wdGlvbnNbJ3VwZGF0ZSddO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24udXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xuICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoIHVwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUZvclVwZGF0ZSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sbGVjdGlvbi53aXRoSGVhZGVycyh0aGlzLmhlYWRlcnMpLndpdGhIZWFkZXJzKG1ldGhvZEhlYWRlcnMpLnVwZGF0ZVNpbmdsZShpdGVtRm9yVXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihvcHRpb25zLnN1Y2Nlc3MuYmluZCh0aGlzLCBpdGVtRm9yVXBkYXRlKSwgb3B0aW9ucy5lcnJvcikuY2F0Y2gob3B0aW9ucy5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1snY3JlYXRlJ107XG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi51cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4ucmVhZC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1ldGhvZEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kSGVhZGVycyA9IG1ldGhvZE9wdGlvbi5oZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzTXVsdGlwbGUgPSBfLmlzQXJyYXkob3B0aW9ucy5kYXRhLm1vZGVscyk7XG4gICAgICAgICAgICB2YXIgY3JlYXRlRGF0YSA9IGlzTXVsdGlwbGUgPyBvcHRpb25zLmRhdGEubW9kZWxzIDogb3B0aW9ucy5kYXRhO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sbGVjdGlvbi53aXRoSGVhZGVycyh0aGlzLmhlYWRlcnMpLndpdGhIZWFkZXJzKG1ldGhvZEhlYWRlcnMpLmNyZWF0ZShjcmVhdGVEYXRhKVxuICAgICAgICAgICAgICAgIC50aGVuKG9wdGlvbnMuc3VjY2Vzcy5iaW5kKHRoaXMsIGNyZWF0ZURhdGEpLCBvcHRpb25zLmVycm9yKS5jYXRjaChvcHRpb25zLmVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1snZGVzdHJveSddO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24udXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzO1xuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xuICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoIGRlc3Ryb3kgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFDb2xsZWN0aW9uLndpdGhIZWFkZXJzKHRoaXMuaGVhZGVycykud2l0aEhlYWRlcnMobWV0aG9kSGVhZGVycykuZGVzdHJveShvcHRpb25zLmRhdGEpXG4gICAgICAgICAgICAgICAgLnRoZW4ob3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKS5jYXRjaChvcHRpb25zLmVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5leHRlbmQodHJ1ZSwga2VuZG8uZGF0YSwge1xuICAgICAgICB0cmFuc3BvcnRzOiB7XG4gICAgICAgICAgICBldmVybGl2ZTogZXZlcmxpdmVUcmFuc3BvcnRcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZW1hczoge1xuICAgICAgICAgICAgZXZlcmxpdmU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgdG90YWw6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmhhc093blByb3BlcnR5KCdjb3VudCcpID8gZGF0YS5jb3VudCA6IGRhdGEuQ291bnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHQgfHwgRXZlcmxpdmUuX3RyYXZlcnNlQW5kUmV2aXZlKGRhdGEuUmVzdWx0KSB8fCBkYXRhO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNvbnN0YW50cy5pZEZpZWxkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVLZW5kb1F1ZXJ5KGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuc2tpcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC4kc2tpcCA9IGRhdGEuc2tpcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5za2lwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGFrZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC4kdGFrZSA9IGRhdGEudGFrZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS50YWtlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc29ydCkge1xuICAgICAgICAgICAgICAgIHZhciBzb3J0RXhwcmVzc2lvbnMgPSBkYXRhLnNvcnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnQgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShzb3J0RXhwcmVzc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRFeHByZXNzaW9ucyA9IFtzb3J0RXhwcmVzc2lvbnNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkLmVhY2goc29ydEV4cHJlc3Npb25zLCBmdW5jdGlvbiAoaWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0W3ZhbHVlLmZpZWxkXSA9IHZhbHVlLmRpciA9PT0gJ2FzYycgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LiRzb3J0ID0gc29ydDtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5zb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGZpbHRlckJ1aWxkZXIuYnVpbGQoZGF0YS5maWx0ZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC4kd2hlcmUgPSBmaWx0ZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuZmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4T3BlcmF0aW9ucyA9IFsnc3RhcnRzd2l0aCcsICdzdGFydHNXaXRoJywgJ2VuZHN3aXRoJywgJ2VuZHNXaXRoJywgJ2NvbnRhaW5zJ107XG5cbiAgICB2YXIgZmlsdGVyQnVpbGRlciA9IHtcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9idWlsZChmaWx0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJCdWlsZGVyLl9pc1JhdyhmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ1aWxkZXIuX3JhdyhmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNTaW1wbGUoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9zaW1wbGUoZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckJ1aWxkZXIuX2lzUmVnZXgoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9yZWdleChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyQnVpbGRlci5faXNBbmQoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9hbmQoZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckJ1aWxkZXIuX2lzT3IoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9vcihmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfaXNSYXc6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIub3BlcmF0b3IgPT09ICdfcmF3JztcbiAgICAgICAgfSxcbiAgICAgICAgX3JhdzogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xuICAgICAgICAgICAgZmllbGRUZXJtW2ZpbHRlci5maWVsZF0gPSBmaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xuICAgICAgICB9LFxuICAgICAgICBfaXNTaW1wbGU6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZmlsdGVyLmxvZ2ljID09PSAndW5kZWZpbmVkJyAmJiAhZmlsdGVyQnVpbGRlci5faXNSZWdleChmaWx0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgdGVybSA9IHt9LCBmaWVsZFRlcm0gPSB7fTtcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IGZpbHRlckJ1aWxkZXIuX3RyYW5zbGF0ZW9wZXJhdG9yKGZpbHRlci5vcGVyYXRvcik7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB0ZXJtW29wZXJhdG9yXSA9IGZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlcm0gPSBmaWx0ZXIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZFRlcm1bZmlsdGVyLmZpZWxkXSA9IHRlcm07XG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xuICAgICAgICB9LFxuICAgICAgICBfaXNSZWdleDogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheShmaWx0ZXIub3BlcmF0b3IsIHJlZ2V4T3BlcmF0aW9ucykgIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICBfcmVnZXg6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZFRlcm0gPSB7fTtcbiAgICAgICAgICAgIHZhciByZWdleCA9IGZpbHRlckJ1aWxkZXIuX2dldFJlZ2V4KGZpbHRlcik7XG4gICAgICAgICAgICBmaWVsZFRlcm1bZmlsdGVyLmZpZWxkXSA9IGZpbHRlckJ1aWxkZXIuX2dldFJlZ2V4VmFsdWUocmVnZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFJlZ2V4OiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IGZpbHRlci52YWx1ZTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJPcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsdGVyT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjb250YWlucyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiLipcIiArIHBhdHRlcm4gKyBcIi4qXCIsIFwiaVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydHNXaXRoJzogLy8gcmVtb3ZpbmcgdGhlIGNhbWVsIGNhc2Ugb3BlcmF0b3JzIHdpbGwgYmUgYSBicmVha2luZyBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydHN3aXRoJzogLy8gdGhlIEtlbmRvIFVJIG9wZXJhdG9ycyBhcmUgaW4gbG93ZXIgY2FzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm4sIFwiaVwiKTtcbiAgICAgICAgICAgICAgICBjYXNlICdlbmRzV2l0aCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kc3dpdGgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuICsgXCIkXCIsIFwiaVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgdHlwZS5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRSZWdleFZhbHVlOiBmdW5jdGlvbiAocmVnZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBRdWVyeUJ1aWxkZXIucHJvdG90eXBlLl9nZXRSZWdleFZhbHVlLmNhbGwodGhpcywgcmVnZXgpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNBbmQ6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubG9naWMgPT09ICdhbmQnO1xuICAgICAgICB9LFxuICAgICAgICBfYW5kOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcGVyYW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyQnVpbGRlci5fYnVpbGQob3BlcmFuZHNbaV0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlckJ1aWxkZXIuX2FuZEFwcGVuZChyZXN1bHQsIHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgX2FuZEFwcGVuZDogZnVuY3Rpb24gKGFuZE9iaiwgbmV3T2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gUXVlcnlCdWlsZGVyLnByb3RvdHlwZS5fYW5kQXBwZW5kLmNhbGwodGhpcywgYW5kT2JqLCBuZXdPYmopO1xuICAgICAgICB9LFxuICAgICAgICBfaXNPcjogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5sb2dpYyA9PT0gJ29yJztcbiAgICAgICAgfSxcbiAgICAgICAgX29yOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIuZmlsdGVycztcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcGVyYW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyQnVpbGRlci5fYnVpbGQob3BlcmFuZHNbaV0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHskb3I6IHJlc3VsdH07XG4gICAgICAgIH0sXG4gICAgICAgIF90cmFuc2xhdGVvcGVyYXRvcjogZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBjYXNlICduZXEnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkbmVcIjtcbiAgICAgICAgICAgICAgICBjYXNlICdndCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRndFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2x0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJGx0XCI7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ3RlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJGd0ZVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2x0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRsdGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgdHlwZS5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLZW5kbyBVSSBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlLlxuICAgICAqIEtlbmRvIFVJIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBLZW5kbyBVSSB3aWRnZXRzIChzdWNoIGFzIFtMaXN0Vmlld10oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvd2ViL2xpc3R2aWV3L292ZXJ2aWV3KSBhbmQgW0dyaWRdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL3dlYi9ncmlkL292ZXJ2aWV3KSkgdG8gcHJvdmlkZSBhbiBlYXN5IHdheSB0byByZW5kZXIgZGF0YSBmcm9tIEJhY2tlbmQgU2VydmljZXMuXG4gICAgICogKmluY2x1ZGluZyBLZW5kbyBVSSBzY3JpcHRzIGlzIHJlcXVpcmVkKi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBkYXRhIHNvdXJjZSBvcHRpb25zLiBTZWUgdGhlIEtlbmRvIFVJIGRvY3VtZW50YXRpb24gZm9yIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydC50eXBlTmFtZSBUaGUgY29udGVudCB0eXBlIG5hbWUgaW4gQmFja2VuZCBTZXJ2aWNlcyB0aGF0IHdpbGwgYmUgbWFuYWdlZC5cbiAgICAgKiBAcmV0dXJucyB7RGF0YVNvdXJjZX0gQSBuZXcgaW5zdGFuY2Ugb2YgS2VuZG8gVUkgRGF0YVNvdXJjZS4gU2VlIHRoZSBLZW5kbyBVSSBkb2N1bWVudGF0aW9uIGZvciBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAZXhhbXBsZSBgYGBqc1xuICAgICAqIHZhciBib29rc0RhdGFTb3VyY2UgPSBFdmVybGl2ZS5jcmVhdGVEYXRhU291cmNlKHtcbiAgICAgKiAgIHRyYW5zcG9ydDoge1xuICAgICAqICAgICB0eXBlTmFtZTogJ0Jvb2tzJ1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBjcmVhdGVEYXRhU291cmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB0eXBlTmFtZSA9IG9wdGlvbnMudHlwZU5hbWU7XG4gICAgICAgIHZhciBldmVybGl2ZSQgPSBvcHRpb25zLmRhdGFQcm92aWRlciB8fCBFdmVybGl2ZS4kO1xuICAgICAgICBpZiAoIWV2ZXJsaXZlJCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gaW5zdGFudGlhdGUgYW4gRXZlcmxpdmUgaW5zdGFuY2UgaW4gb3JkZXIgdG8gY3JlYXRlIGEgS2VuZG8gVUkgRGF0YVNvdXJjZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR5cGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzcGVjaWZ5IGEgJ3R5cGVOYW1lJyBpbiBvcmRlciB0byBjcmVhdGUgYSBLZW5kbyBVSSBEYXRhU291cmNlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVybGl2ZSQuZ2V0S2VuZG9EYXRhU291cmNlKHR5cGVOYW1lLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBLZW5kbyBVSSBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKSB0aGF0IG1hbmFnZXMgYSBjZXJ0YWluIEJhY2tlbmQgU2VydmljZXMgY29udGVudCB0eXBlIGFuZCBjYW4gZXhwYW5kIGEgY2hhaW4gb2YgcmVsYXRpb25zLlxuICAgICAqIEtlbmRvIFVJIFtIaWVyYXJjaGljYWxEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2hpZXJhcmNoaWNhbGRhdGFzb3VyY2UpIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBLZW5kbyBVSSB3aWRnZXRzIChzdWNoIGFzIFtUcmVlVmlld10oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvd2ViL3RyZWV2aWV3L292ZXJ2aWV3KSkgdG8gcmVuZGVyIGRhdGEgZnJvbSBCYWNrZW5kIFNlcnZpY2VzIGluIGEgc3RydWN0dXJlZCB3YXkuXG4gICAgICogVGhlIGNoYWluIG9mIHJlbGF0aW9ucyBpcyBkZWZpbmVkIGJ5IHNwZWNpZnlpbmcgdGhlIGZpZWxkIG5hbWVzIHRoYXQgY29udGFpbiB0aGUgcmVsYXRpb24gb24gZWFjaCBsZXZlbC4gRm9yIGV4YW1wbGUgYSBnZW5lcmljIGhpZXJhcmNoeSBjaGFpbiBpcyBhIGNvbnRlbnQgdHlwZSAnQ29udGluZW50cycgd2l0aCByZWxhdGlvbiB0byAnQ291bnRyaWVzJywgd2hpY2ggaW4gdHVybiBjb250YWlucyBhIHJlbGF0aW9uIHRvICdUb3ducycuXG4gICAgICogKmluY2x1ZGluZyBLZW5kbyBVSSBzY3JpcHRzIGlzIHJlcXVpcmVkKi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBkYXRhIHNvdXJjZSBPcHRpb25zIGZvciBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlTmFtZSBOYW1lIG9mIHRoZSBtYWluIGNvbnRlbnQgdHlwZSBmb3IgdGhlIGRhdGEgc291cmNlLlxuICAgICAqIEBwYXJhbSB7RXhwYW5kRGVmaW5pdGlvbltdfSBvcHRpb25zLmV4cGFuZCBBbiBhcnJheSBvZiBleHBhbmQgZGVmaW5pdGlvbnMuIEl0IGRlZmluZXMgdGhlIGxldmVscyBvZiBoaWVyYXJjaHkgYnkgc3BlY2lmeWluZyB0aGUgcmVsYXRpb24gZmllbGRzLiBBbiBleHBhbmQgZGVmaW5pdGlvbiBjYW4gZWl0aGVyIGJlIHRoZSBmaWVsZCBuYW1lIGFzIGEgKipzdHJpbmcqKiwgb3IgYW4gKipvYmplY3QqKiB0aGF0IGFsbG93cyBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV4cGFuZERlZmluaXRpb24gLSBUaGUgZmllbGQgbmFtZSBvZiB0aGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGV4cGFuZGVkLiBPbmx5IHN1cHBvcnRlZCBpbiBvbmxpbmUgbW9kZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gRXhwYW5kRGVmaW5pdGlvbi5yZWxhdGlvbiAtICpSZXF1aXJlZCouIFRoZSBmaWVsZCBuYW1lIG9mIHRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgZXhwYW5kZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV4cGFuZERlZmluaXRpb24udHlwZU5hbWUgLSAqUmVxdWlyZWQgaW4gb2ZmbGluZSBtb2RlKi4gVGhlIHR5cGUgbmFtZSBvZiB0aGUgcmVsYXRpb24gdGhhdCB3aWxsIGJlIGV4cGFuZGVkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLmZpbHRlciAtIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5zb3J0IC0gQW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIHNvcnQgZXhwcmVzc2lvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5za2lwIC0gQSBudW1iZXIgc3BlY2lmeWluZyB0aGUgc2tpcCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi50YWtlIC0gQSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGFrZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5maWVsZHMgLSBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZmllbGRzIGV4cHJlc3Npb24uXG4gICAgICogQHJldHVybnMge0hpZXJhcmNoaWNhbERhdGFTb3VyY2V9IEEgbmV3IGluc3RhbmNlIG9mIEtlbmRvIFVJIEhpZXJhcmNoaWNhbERhdGFTb3VyY2UuIFNlZSB0aGUgS2VuZG8gVUkgZG9jdW1lbnRhdGlvbiBmb3IgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSkuXG4gICAgICogQGV4YW1wbGUgYGBganNcbiAgICAgKiB2YXIgZWwgPSBuZXcgRXZlcmxpdmUoJ3lvdXItYXBpLWtleS1oZXJlJyk7XG4gICAgICogdmFyIGNvbnRpbmVudHMgPSBFdmVybGl2ZS5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlKHtcbiAgICAgKiAgIFwidHlwZU5hbWVcIjogXCJDb250aW5lbnRzXCIsXG4gICAgICogICBcImV4cGFuZFwiOiBbXCJDb3VudHJpZXNcIiwgXCJUb3duc1wiXVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLi4uXG4gICAgICogKFwiI3RyZWV2aWV3XCIpLmtlbmRvVHJlZVZpZXcoe1xuICAgICAqICAgZGF0YVNvdXJjZTogY29udGluZW50cyxcbiAgICAgKiAgIGRhdGFUZXh0RmllbGQ6IFtcIkNvbnRpbmVudE5hbWVcIiwgXCJDb3VudHJ5TmFtZVwiLCBcIlRvd25OYW1lXCJdXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSBvcHRpb25zLnR5cGVOYW1lO1xuICAgICAgICB2YXIgZXZlcmxpdmUkID0gb3B0aW9ucy5kYXRhUHJvdmlkZXIgfHwgRXZlcmxpdmUuJDtcbiAgICAgICAgaWYgKCFldmVybGl2ZSQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIGluc3RhbnRpYXRlIGFuIEV2ZXJsaXZlIGluc3RhbmNlIGluIG9yZGVyIHRvIGNyZWF0ZSBhIEtlbmRvIFVJIERhdGFTb3VyY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHNwZWNpZnkgYSAndHlwZU5hbWUnIGluIG9yZGVyIHRvIGNyZWF0ZSBhIEtlbmRvIFVJIERhdGFTb3VyY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVybGl2ZSQuZ2V0SGllcmFyY2hpY2FsRGF0YVNvdXJjZSh0eXBlTmFtZSwgb3B0aW9ucyk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgS2VuZG8gVUkgRGF0YVNvdXJjZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBTREsgd2l0aCBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQG1ldGhvZCBnZXRLZW5kb0RhdGFTb3VyY2VcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVOYW1lIFRoZSBjb3JyZXNwb25kaW5nIHR5cGUgbmFtZSBmb3IgdGhlIERhdGFTb3VyY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhc291cmNlT3B0aW9uc10gQWRkaXRpb25hbCBEYXRhU291cmNlIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge0RhdGFTb3VyY2V9XG4gICAgICovXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmdldEtlbmRvRGF0YVNvdXJjZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSwgZGF0YXNvdXJjZU9wdGlvbnMpIHtcbiAgICAgICAgZGF0YXNvdXJjZU9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgZGF0YXNvdXJjZU9wdGlvbnMpO1xuICAgICAgICBpZiAoZGF0YXNvdXJjZU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NlcnZlckdyb3VwaW5nJykgJiYgZGF0YXNvdXJjZU9wdGlvbnMuc2VydmVyR3JvdXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZXJ2ZXIgR3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZhdWx0RXZlcmxpdmVPcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZTogJ2V2ZXJsaXZlJyxcbiAgICAgICAgICAgIHRyYW5zcG9ydDoge1xuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IF8uZGVmYXVsdHMoZGVmYXVsdEV2ZXJsaXZlT3B0aW9ucywgZGF0YXNvdXJjZU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuRGF0YVNvdXJjZShvcHRpb25zKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZ2V0VXJsR2VuZXJhdG9yRm9yTm9kZSA9IGZ1bmN0aW9uIChiYXNlVXJsLCBleHBhbmRBcnJheSkge1xuICAgICAgICB2YXIgZXhwYW5kRmllbGQgPSBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZShleHBhbmRBcnJheVtleHBhbmRBcnJheS5sZW5ndGggLSAxXSk7XG4gICAgICAgIHZhciBwYXRoQXJyYXkgPSBleHBhbmRBcnJheS5zbGljZSgwLCBleHBhbmRBcnJheS5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHBhdGhVcmwgPSAnL19leHBhbmQnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0aFVybCArPSAnLycgKyBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZShwYXRoQXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHBhdGhVcmwsIGV4cGFuZEZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gYmFzZVVybCArICcnO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLklkICYmIGV4cGFuZEZpZWxkKSB7Ly9pZiB3ZSBhcmUgZXhwYW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBwYXRoVXJsICsgJy8nICsgb3B0aW9ucy5JZCArICcvJyArIGV4cGFuZEZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KHBhdGhVcmwsIGV4cGFuZEZpZWxkKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRIZWFkZXJzRm9yRXhwYW5kTm9kZSA9IGZ1bmN0aW9uIChleHBhbmROb2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwYW5kTm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1GaWx0ZXInOiBKU09OLnN0cmluZ2lmeShleHBhbmROb2RlLmZpbHRlciksXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU29ydCc6IEpTT04uc3RyaW5naWZ5KGV4cGFuZE5vZGUuc29ydCksXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU2luZ2xlLUZpZWxkJzogZXhwYW5kTm9kZS5zaW5nbGVGaWVsZCxcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1Ta2lwJzogZXhwYW5kTm9kZS5za2lwLFxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVRha2UnOiBleHBhbmROb2RlLnRha2UsXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRmllbGRzJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kTm9kZS5maWVsZHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlID0gZnVuY3Rpb24gKGV4cGFuZE5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHBhbmROb2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHBhbmROb2RlLnJlbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZE5vZGUucmVsYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHNwZWNpZnkgYSAncmVsYXRpb24nIGZvciBhbiBleHBhbmQgbm9kZSB3aGVuIHVzaW5nIHRoZSBvYmplY3Qgbm90YXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgS2VuZG8gVUkgSGllcmFyY2hpY2FsRGF0YVNvdXJjZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBTREsgd2l0aCBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQG1ldGhvZCBnZXRIaWVyYXJjaGljYWxEYXRhU291cmNlXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlTmFtZSBUaGUgY29ycmVzcG9uZGluZyB0eXBlIG5hbWUgZm9yIHRoZSBEYXRhU291cmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhU291cmNlT3B0aW9ucyBBZGRpdGlvbmFsIERhdGFTb3VyY2Ugb3B0aW9ucyB0aGF0IGRlc2NyaWJlIHRoZSBoaWVyYXJjaGljYWwgc3RydWN0dXJlLlxuICAgICAqIEByZXR1cm5zIHtIaWVyYXJjaGljYWxEYXRhU291cmNlfVxuICAgICAqL1xuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5nZXRIaWVyYXJjaGljYWxEYXRhU291cmNlID0gZnVuY3Rpb24gKHR5cGVOYW1lLCBkYXRhU291cmNlT3B0aW9ucykge1xuICAgICAgICBkYXRhU291cmNlT3B0aW9ucyA9IGRhdGFTb3VyY2VPcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoZGF0YVNvdXJjZU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NlcnZlckdyb3VwaW5nJykgJiYgZGF0YVNvdXJjZU9wdGlvbnMuc2VydmVyR3JvdXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdTZXJ2ZXIgR3JvdXBpbmcgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwYW5kID0gZGF0YVNvdXJjZU9wdGlvbnMuZXhwYW5kIHx8IGRhdGFTb3VyY2VPcHRpb25zO1xuICAgICAgICBkZWxldGUgZGF0YVNvdXJjZU9wdGlvbnMuZXhwYW5kO1xuICAgICAgICBpZiAoIXR5cGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzcGVjaWZ5IGEgJ3R5cGVOYW1lJyBpbiBvcmRlciB0byBjcmVhdGUgYSBLZW5kbyBVSSBIaWVyYXJjaGljYWxEYXRhU291cmNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISQuaXNBcnJheShleHBhbmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzZXQgJ2V4cGFuZCcgYXJyYXkgb3B0aW9uIGluIG9yZGVyIHRvIGNyZWF0ZSBhIEtlbmRvIFVJIEhpZXJhcmNoaWNhbERhdGFTb3VyY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VVcmwgPSB0aGlzLmJ1aWxkVXJsKCkgKyB0eXBlTmFtZTtcblxuICAgICAgICB2YXIgZXhwYW5kU2NoZW1hO1xuICAgICAgICB2YXIgaXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQgPSB0aGlzLl9pc09mZmxpbmVTdG9yYWdlRW5hYmxlZCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gZXhwYW5kLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IC8vcmVjdXJzaXZlbHkgYnVpbGQgdGhlIGhpZXJhcmNoaWNhbCBkYXRhIHNvdXJjZVxuICAgICAgICAgICAgdmFyIGV4cGFuZE5vZGUgPSBleHBhbmRbaV07XG4gICAgICAgICAgICBpZiAoaXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNQbGFpbk9iamVjdChleHBhbmROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIG9mZmxpbmUgaXMgZW5hYmxlZCwgZWFjaCBtZW1iZXIgb2YgdGhlIGV4cGFuZCBhcnJheSBvcHRpb24gbXVzdCBiZSBhbiBvYmplY3QuIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4cGFuZE5vZGUucmVsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBvZmZsaW5lIGlzIGVuYWJsZWQsIGVhY2ggbWVtYmVyIG9mIHRoZSBleHBhbmQgYXJyYXkgb3B0aW9uIG11c3QgaGF2ZSBhIGByZWxhdGlvbmAgb3B0aW9uIHNldC4gIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4cGFuZE5vZGUudHlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBvZmZsaW5lIGlzIGVuYWJsZWQsIGVhY2ggbWVtYmVyIG9mIHRoZSBleHBhbmQgYXJyYXkgb3B0aW9uIG11c3QgaGF2ZSBhIGB0eXBlTmFtZWAgb3B0aW9uIHNldC4gIChFeHBhbmQgbm9kZSBpbmRleDogXCIgKyBpICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzO1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRFeHByZXNzaW9uID0ge307XG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltleHBhbmROb2RlLnJlbGF0aW9uXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgVGFyZ2V0VHlwZU5hbWU6IGV4cGFuZE5vZGUudHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIEZpbHRlcjogZXhwYW5kTm9kZS5maWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIFNvcnQ6IGV4cGFuZE5vZGUuc29ydCxcbiAgICAgICAgICAgICAgICAgICAgVGFrZTogZXhwYW5kTm9kZS50YWtlLFxuICAgICAgICAgICAgICAgICAgICBTa2lwOiBleHBhbmROb2RlLnNraXAsXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkczogZXhwYW5kTm9kZS5maWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIFNpbmdsZUZpZWxkOiBleHBhbmROb2RlLnNpbmdsZUZpZWxkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1FeHBhbmQnOiBKU09OLnN0cmluZ2lmeShleHBhbmRFeHByZXNzaW9uKSxcbiAgICAgICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU2luZ2xlLUZpZWxkJzogZXhwYW5kTm9kZS5yZWxhdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHlwZSA9IHR5cGVOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFR5cGUgPSBleHBhbmRbaSAtIDFdLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBhbmRTY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbjogZXhwYW5kTm9kZS5yZWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJldmVybGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZTogcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGV4cGFuZFNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kU2NoZW1hID0ge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlKGV4cGFuZE5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZXJsaXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZ2V0VXJsR2VuZXJhdG9yRm9yTm9kZShiYXNlVXJsLCBleHBhbmQuc2xpY2UoMCwgaSArIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnNGb3JFeHBhbmROb2RlKGV4cGFuZE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZXhwYW5kU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgb3B0aW9ucy50eXBlID0gJ2V2ZXJsaXZlJztcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB7XG4gICAgICAgICAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgICAgICAgICBkYXRhUHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy5zY2hlbWEgPSBleHBhbmRTY2hlbWE7XG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoZGF0YVNvdXJjZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICBleHRlbmQodHJ1ZSwgb3B0aW9ucywgZGF0YVNvdXJjZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcga2VuZG8uZGF0YS5IaWVyYXJjaGljYWxEYXRhU291cmNlKG9wdGlvbnMpO1xuICAgIH07XG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjcmVhdGVEYXRhU291cmNlOiBjcmVhdGVEYXRhU291cmNlLFxuICAgICAgICBjcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlOiBjcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlXG4gICAgfTtcbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciBfID0gY29tbW9uLl87XG52YXIgcmVxd2VzdCA9IGNvbW1vbi5yZXF3ZXN0O1xudmFyIHV1aWQgPSBjb21tb24udXVpZDtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIENyeXB0b0pTID0gcmVxdWlyZSgnbm9kZS1jcnlwdG9qcy1hZXMnKS5DcnlwdG9KUztcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJyk7XG52YXIgRXZlcmxpdmVFcnJvcnMgPSBlcnJvcnMuRXZlcmxpdmVFcnJvcnM7XG52YXIgRXZlcmxpdmVFcnJvciA9IGVycm9ycy5FdmVybGl2ZUVycm9yO1xuXG52YXIgT2ZmbGluZUZpbGVzTW9kdWxlID0gZnVuY3Rpb24gKG9mZmxpbmVGaWxlc1Byb2Nlc3NvciwgZXZlcmxpdmUpIHtcbiAgICB0aGlzLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IgPSBvZmZsaW5lRmlsZXNQcm9jZXNzb3I7XG4gICAgdGhpcy5fZXZlcmxpdmUgPSBldmVybGl2ZTtcbn07XG5cbi8qKlxuICogQGNsYXNzIE9mZmxpbmVGaWxlc01vZHVsZVxuICogQGNsYXNzZGVzYyBBIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIG1lYW5zIHRvIG9wZXJhdGUgd2l0aCBmaWxlcyBpbiBvZmZsaW5lIG1vZGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbk9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGUgPSB7XG4gICAgX2dldEZpbGVuYW1lTWV0YWRhdGE6IGZ1bmN0aW9uIChsb2NhdGlvbiwgb2ZmbGluZUZpbGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXF3ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluOiB0cnVlXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh4bWxSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50RGlzcG9zaXRpb25IZWFkZXIgPSB4bWxSZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1EaXNwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSAvZmlsZW5hbWU9XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiL2kuZXhlYyhjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0FycmF5KG1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lRmlsZUluZm8uZmlsZW5hbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUZpbGVJbmZvLmZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh4bWxSZXNwb25zZS5yZXNwb25zZVVSTCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgZmlsZSdzIGNvbnRlbnQuXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGRvd25sb2FkT2ZmbGluZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBBIGZpbGUgbG9jYXRpb24gb3IgdGhlIGlkIG9mIGEgZmlsZSBzdG9yZWQgaW4gQmFja2VuZCBTZXJ2aWNlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZSBCb29sZWFuIG9wdGlvbiB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmaWxlIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvZmZsaW5lLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgZmlsZSdzIGNvbnRlbnQuXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGRvd25sb2FkT2ZmbGluZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBBIGZpbGUgbG9jYXRpb24gb3IgdGhlIGlkIG9mIGEgZmlsZSBzdG9yZWQgaW4gQmFja2VuZCBTZXJ2aWNlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZSBCb29sZWFuIG9wdGlvbiB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmaWxlIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvZmZsaW5lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBkb3dubG9hZE9mZmxpbmU6IGZ1bmN0aW9uIChsb2NhdGlvbiwgb3ZlcndyaXRlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBvZmZsaW5lRmlsZUluZm87XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0T2ZmbGluZUZpbGVJbmZvKGxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfb2ZmbGluZUZpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlSW5mbyA9IF9vZmZsaW5lRmlsZUluZm87XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmV4aXN0c09mZmxpbmUobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2V2ZXJsaXZlLmlzT25saW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9mZmxpbmVGaWxlSW5mby5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRGaWxlbmFtZU1ldGFkYXRhKGxvY2F0aW9uLCBvZmZsaW5lRmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fc2F2ZUZpbGUob2ZmbGluZUZpbGVJbmZvLmxvY2F0aW9uLCBvZmZsaW5lRmlsZUluZm8uZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoRXZlcmxpdmVFcnJvcnMuY2Fubm90RG93bmxvYWRPZmZsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRPZmZsaW5lRmlsZUluZm8obG9jYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRPZmZsaW5lTG9jYXRpb24oZmlsZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9LFxuXG4gICAgX3NhdmVGaWxlOiBmdW5jdGlvbiAobG9jYXRpb24sIGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFjdHVhbExvY2F0aW9uO1xuXG4gICAgICAgIHJldHVybiBzZWxmLl9kb3dubG9hZEZpbGUobG9jYXRpb24gLCBmaWxlbmFtZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYWN0dWFsTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhY3R1YWxMb2NhdGlvbiA9IF9hY3R1YWxMb2NhdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLmdldE9mZmxpbmVGaWxlc0RhdGEoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xuICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlc0RhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVMb2NhdGlvbjogYWN0dWFsTG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG9ubGluZUxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5zYXZlT2ZmbGluZUZpbGVzRGF0YSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsTG9jYXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGh5c2ljYWxseSBkZWxldGVzIHRoZSBvZmZsaW5lIGNvcGllcyBvZiBhbGwgZmlsZXMuXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHB1cmdlQWxsXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQaHlzaWNhbGx5IGRlbGV0ZXMgdGhlIG9mZmxpbmUgY29waWVzIG9mIGFsbCBmaWxlcy5cbiAgICAgKiBAbWVtYmVyb2YgT2ZmbGluZUZpbGVzTW9kdWxlLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgcHVyZ2VBbGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgcHVyZ2VBbGw6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUucmVtb3ZlRmlsZXNEaXJlY3RvcnkoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlc01ldGFTdG9yZS5yZW1vdmVGaWxlc0RpcmVjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuX29mZmxpbmVGaWxlc0RhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfSxcblxuICAgIF9nZXRPZmZsaW5lTG9jYXRpb246IGZ1bmN0aW9uIChmaWxlSW5mbykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB1cmwgPSBmaWxlSW5mby5sb2NhdGlvbjtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZUluZm8uZmlsZW5hbWU7XG4gICAgICAgIHZhciBpZCA9IGZpbGVJbmZvLklkO1xuXG4gICAgICAgIHJldHVybiBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZ2V0T2ZmbGluZUxvY2F0aW9uKHVybCwgZmlsZW5hbWUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZVVybCkge1xuICAgICAgICAgICAgICAgIGlmIChvZmZsaW5lVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lVXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHVybCBpcyBwcm92aWRlZCB0aGlzIG1lYW5zIHRoYXQgdGhlIGZpbGUgZXhpc3RzIG9ubHkgb2ZmbGluZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBVcmkgZmllbGQgaGFzIG5vdCBiZWVuIHBvcHVsYXRlZCBieSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgaWYgKGlkICYmICF1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldEZpbGVVcmxGb3JJZChpZCwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9kb3dubG9hZEZpbGU6IGZ1bmN0aW9uICh1cmwsIG5hbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRPRE86IFtvZmZsaW5lXSB0aGlzIHdpbGwgbm90IHdvcmsgaW4gTmF0aXZlU2NyaXB0IGF0IHRoZSBtb21lbnRcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGZpbGVUcmFuc2ZlciA9IG5ldyBGaWxlVHJhbnNmZXIoKTtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRVcmwgPSBzZWxmLl9zYW5pdGl6ZVVybCh1cmwpO1xuICAgICAgICAgICAgdmFyIGZpbGVJZCA9IHBhdGguYmFzZW5hbWUoc2FuaXRpemVkVXJsKTtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSBwYXRoLmV4dG5hbWUobmFtZSk7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlSWQ7XG4gICAgICAgICAgICBpZiAocGF0aC5leHRuYW1lKHNhbml0aXplZFVybCkgIT09IGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICBmaWxlbmFtZSArPSBleHRlbnNpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWxlUGFyZW50RGlyZWN0b3J5ID0gJyc7XG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzR3VpZCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVJZEluZGV4ID0gdXJsLmxhc3RJbmRleE9mKGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSB1cmwuc3Vic3RyKDAsIGZpbGVJZEluZGV4KTtcbiAgICAgICAgICAgICAgICBmaWxlUGFyZW50RGlyZWN0b3J5ID0gQ3J5cHRvSlMuTUQ1KGJhc2VVcmwpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZVN0b3JlLmdldERhdGFEaXJlY3RvcnkoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5qb2luUGF0aChkYXRhRGlyLm5hdGl2ZVVSTCwgc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLmZpbGVTdG9yZS5maWxlc0RpcmVjdG9yeVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGFyZW50RGlyZWN0b3J5LCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVRyYW5zZmVyLmRvd25sb2FkKHVybCwgbG9jYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QsIHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuX2V2ZXJsaXZlLmJ1aWxkQXV0aEhlYWRlcigpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2FuaXRpemVVcmw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkVXJsID0gZW5jb2RlVVJJKHVybCk7XG4gICAgICAgIHZhciBxdWVzdGlvbk1hcmtJbmRleCA9IHNhbml0aXplZFVybC5sYXN0SW5kZXhPZignPycpO1xuICAgICAgICBpZiAocXVlc3Rpb25NYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzYW5pdGl6ZWRVcmwgPSBzYW5pdGl6ZWRVcmwuc3Vic3RyKDAsIHF1ZXN0aW9uTWFya0luZGV4KTsgLy9saW51eCBkb2VzIG5vdCBhbGxvdyBxdWVzdGlvbiBtYXJrcyBpbiBpdHMgZmlsZW5hbWVzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2FuaXRpemVkVXJsO1xuICAgIH0sXG5cbiAgICBfZ2V0RmlsZVVybEZvcklkOiBmdW5jdGlvbiAoZmlsZUlkLCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUuZ2V0RGF0YURpcmVjdG9yeSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YURpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlRXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuam9pblBhdGgoZGF0YURpcmVjdG9yeS5uYXRpdmVVUkwsIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUuZmlsZXNEaXJlY3RvcnlQYXRoLCBmaWxlSWQgKyBmaWxlRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBmaWxlIGV4aXN0cyBvZmZsaW5lLlxuICAgICAqIEBtZW1iZXJvZiBPZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBleGlzdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9yIGZpbGUgaWQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGZpbGUgZXhpc3RzIG9mZmxpbmUuXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGV4aXN0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb3IgZmlsZSBpZCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgZXhpc3RzT2ZmbGluZTogZnVuY3Rpb24gKGxvY2F0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuX2dldE9mZmxpbmVGaWxlSW5mbyhsb2NhdGlvbilcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9mZmxpbmVMb2NhdGlvbihmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZVVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUuZ2V0RmlsZUJ5QWJzb2x1dGVQYXRoKG9mZmxpbmVVcmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhb2ZmbGluZUZpbGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaXRlbU5vdEZvdW5kLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUGh5c2ljYWxseSBkZWxldGVzIHRoZSBvZmZsaW5lIGNvcHkgb2YgYSBmaWxlLlxuICAgICAqIEBtZW1iZXJvZiBPZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBwdXJnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb3IgZmlsZSBpZCB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQaHlzaWNhbGx5IGRlbGV0ZXMgdGhlIG9mZmxpbmUgY29weSBvZiBhIGZpbGUuXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHB1cmdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvciBmaWxlIGlkIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBwdXJnZTogZnVuY3Rpb24gKGxvY2F0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuX2dldE9mZmxpbmVGaWxlSW5mbyhsb2NhdGlvbilcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9mZmxpbmVMb2NhdGlvbihmaWxlSW5mbyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yLnB1cmdlKGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBVUkwgZm9yIGEgZmlsZSB0aGF0IGlzIHN0b3JlZCBvZmZsaW5lLlxuICAgICAqIEBtZW1iZXJvZiBPZmZsaW5lRmlsZXNNb2R1bGUucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBnZXRPZmZsaW5lTG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbG9jYXRpb24gVGhlIGxvY2F0aW9uIG9yIGZpbGUgaWQgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XG4gICAgICovXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIFVSTCBmb3IgYSBmaWxlIHRoYXQgaXMgc3RvcmVkIG9mZmxpbmUuXG4gICAgICogQG1lbWJlcm9mIE9mZmxpbmVGaWxlc01vZHVsZS5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGdldE9mZmxpbmVMb2NhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gb3IgZmlsZSBpZCB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBnZXRPZmZsaW5lTG9jYXRpb246IGZ1bmN0aW9uIChsb2NhdGlvbiwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLl9nZXRPZmZsaW5lRmlsZUluZm8obG9jYXRpb24pXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fZ2V0T2ZmbGluZUxvY2F0aW9uLmJpbmQoc2VsZikpXG4gICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfSxcblxuICAgIF9nZXRPZmZsaW5lRmlsZUluZm86IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzYW5pdGl6ZWRVcmwgPSB0aGlzLl9zYW5pdGl6ZVVybChsb2NhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2VsZi5fZXZlcmxpdmUuRmlsZXNcbiAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXG4gICAgICAgICAgICAgICAgLnVzZU9mZmxpbmUodHJ1ZSlcbiAgICAgICAgICAgICAgICAuZ2V0QnlJZChzYW5pdGl6ZWRVcmwpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBmaWxlLlVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLkZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgSWQ6IHNhbml0aXplZFVybFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLml0ZW1Ob3RGb3VuZC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNoYW5nZUZpbGVFeHRlbnNpb25CeUlkOiBmdW5jdGlvbiAoaWQsIGV4dGVuc2lvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoYW5nZUV4dGVuc2lvbihpZCwgZXh0ZW5zaW9uKTtcbiAgICB9LFxuXG4gICAgX2NoYW5nZUV4dGVuc2lvbjogZnVuY3Rpb24gKGlkLCBuZXdFeHRlbnNpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkYXRhRGlyO1xuXG4gICAgICAgIHZhciBmaWxlU3RvcmUgPSBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3IuZmlsZVN0b3JlO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBpZCArIG5ld0V4dGVuc2lvbjtcbiAgICAgICAgcmV0dXJuIGZpbGVTdG9yZS5nZXRGaWxlc0RpcmVjdG9yeSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGlyZWN0b3J5RW50cnkpIHtcbiAgICAgICAgICAgICAgICBkYXRhRGlyID0gZGlyZWN0b3J5RW50cnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0T2ZmbGluZUxvY2F0aW9uKGlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobG9jYWxQYXRoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdGaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUobG9jYWxQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdGaWxlTmFtZSAhPT0gZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTdG9yZS5nZXRGaWxlQnlBYnNvbHV0ZVBhdGgobG9jYWxQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlU3RvcmUucmVuYW1lRmlsZShkYXRhRGlyLCBmaWxlRW50cnksIGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5nZXRPZmZsaW5lRmlsZXNEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG9mZmxpbmVGaWxlc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGVkRW50cnkgPSBfLmZpbmRXaGVyZShvZmZsaW5lRmlsZXNEYXRhLCB7b2ZmbGluZUxvY2F0aW9uOiBsb2NhbFBhdGh9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcHBlZEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDb3VsZCBub3QgZmluZCBhIGNhY2hlZCBsb2NhdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBmaWxlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0xvY2F0aW9uID0gbWFwcGVkRW50cnkub2ZmbGluZUxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0V4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShwcmV2aW91c0xvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0dWFsTG9jYXRpb24gPSBwcmV2aW91c0xvY2F0aW9uLnNsaWNlKDAsIHByZXZpb3VzTG9jYXRpb24ubGVuZ3RoIC0gcHJldmlvdXNFeHRlbnNpb24ubGVuZ3RoKSArIG5ld0V4dGVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRFbnRyeS5vZmZsaW5lTG9jYXRpb24gPSBhY3R1YWxMb2NhdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vZmZsaW5lRmlsZXNQcm9jZXNzb3Iuc2F2ZU9mZmxpbmVGaWxlc0RhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2ZmbGluZUZpbGVzTW9kdWxlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZXJsaXZlRXJyb3JNb2R1bGUgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJyk7XG52YXIgRXZlcmxpdmVFcnJvciA9IEV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcbnZhciBFdmVybGl2ZUVycm9ycyA9IEV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcnM7XG52YXIgRmlsZVN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmFnZXMvRmlsZVN0b3JlJyk7XG52YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBGSUxFU19NRVRBREFUQV9GSUxFX05BTUUgPSAnZmlsZXNNZXRhZGF0YU1hcCc7XG5cbnZhciBPZmZsaW5lRmlsZXNQcm9jZXNzb3IgPSBmdW5jdGlvbiAoc2V0dXAsIGV2ZXJsaXZlKSB7XG4gICAgdGhpcy5maWxlU3RvcmUgPSBuZXcgRmlsZVN0b3JlKHNldHVwLmZpbGVzLnN0b3JhZ2VQYXRoLCBzZXR1cCk7XG4gICAgdGhpcy5maWxlc01ldGFTdG9yZSA9IG5ldyBGaWxlU3RvcmUoc2V0dXAuZmlsZXMubWV0YVBhdGgsIHNldHVwKTtcbiAgICB0aGlzLl9ldmVybGl2ZSA9IGV2ZXJsaXZlO1xufTtcblxuT2ZmbGluZUZpbGVzUHJvY2Vzc29yLnByb3RvdHlwZSA9IHtcbiAgICB2YWxpZGF0ZUZpbGVDcmVhdGVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIGlzU3luYykge1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIW9iai5iYXNlNjQgJiYgIWlzU3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoRXZlcmxpdmVFcnJvcnMubWlzc2luZ09ySW52YWxpZEZpbGVDb250ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9iai5Db250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoRXZlcmxpdmVFcnJvcnMubWlzc2luZ0NvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9iai5GaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vVE9ETzogW29mZmxpbmVdIGFkZCBhbiBhcHByb3ByaWF0ZSBlcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoRXZlcmxpdmVFcnJvcnMuaW52YWxpZFJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRPZmZsaW5lRmlsZXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX29mZmxpbmVGaWxlc0RhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5maWxlc01ldGFTdG9yZS5nZXRGaWxlKEZJTEVTX01FVEFEQVRBX0ZJTEVfTkFNRSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhRmlsZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZXNNZXRhU3RvcmUucmVhZEZpbGVBc1RleHQobWV0YWRhdGFGaWxlSGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVRleHQgPSAnW10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vZmZsaW5lRmlsZXNEYXRhID0gSlNPTi5wYXJzZShtZXRhZGF0YVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLl9vZmZsaW5lRmlsZXNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLl9vZmZsaW5lRmlsZXNEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNhdmVPZmZsaW5lRmlsZXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gc2VsZi5nZXRPZmZsaW5lRmlsZXNEYXRhKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZsaW5lRmlsZXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZXNNZXRhU3RvcmUud3JpdGVUZXh0KEZJTEVTX01FVEFEQVRBX0ZJTEVfTkFNRSwgSlNPTi5zdHJpbmdpZnkob2ZmbGluZUZpbGVzRGF0YSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVwc2VydEZpbGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBpc0NyZWF0ZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmouYmFzZTY0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5yZWplY3RlZFByb21pc2UoRXZlcmxpdmVFcnJvcnMubWlzc2luZ09ySW52YWxpZEZpbGVDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9iai5Db250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMucmVqZWN0ZWRQcm9taXNlKEV2ZXJsaXZlRXJyb3JzLm1pc3NpbmdDb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5iYXNlNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmouYmFzZTY0KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB1dGlscy5nZXRJZChvYmopO1xuICAgICAgICAgICAgdmFyIHVyaTtcbiAgICAgICAgICAgIHZhciBkb3dubG9hZEZpbGVQcm9taXNlID0gb2JqLlVyaSA/IHV0aWxzLnN1Y2Nlc3NmdWxQcm9taXNlKG9iai5VcmkpIDpcbiAgICAgICAgICAgICAgICBzZWxmLl9ldmVybGl2ZS5maWxlc1xuICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKGlzU3luYylcbiAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmdldERvd25sb2FkVXJsQnlJZChpZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkb3dubG9hZEZpbGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKF91cmkpIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBfdXJpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcy5leGlzdHNPZmZsaW5lKGlkKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGV4aXN0cykge1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcy5fc2F2ZUZpbGUodXJpLCBvYmouRmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLlN0b3JhZ2UgPSAnaW50ZXJuYWwnO1xuICAgICAgICByZXR1cm4gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudmFsaWRhdGVGaWxlQ3JlYXRlT2JqZWN0KG9iaiwgaXNTeW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb25saW5lTG9jYXRpb24gPSBvYmouVXJpO1xuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gc2VsZi5nZXRGaWxlbmFtZUZvck9iamVjdChvYmopO1xuXG4gICAgICAgICAgICB2YXIgb2ZmbGluZUZpbGVJbmZvO1xuICAgICAgICAgICAgdmFyIGJhc2U2NENvbnRlbnRzID0gb2JqLmJhc2U2NDtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouYmFzZTY0O1xuXG4gICAgICAgICAgICB2YXIgY29udGVudHMgPSB1dGlscy5iNjR0b0Jsb2IoYmFzZTY0Q29udGVudHMsIG9iai5Db250ZW50VHlwZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLndyaXRlRmlsZShmaWxlbmFtZSwgY29udGVudHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlSW5mbyA9IGZpbGVJbmZvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRPZmZsaW5lRmlsZXNEYXRhKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZsaW5lRmlsZXNEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUxvY2F0aW9uOiBvZmZsaW5lRmlsZUluZm8ub2ZmbGluZUxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25saW5lTG9jYXRpb246IG9ubGluZUxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogbWF5YmUgc2F2ZSB0aGUgZmlsZXNkYXRhP1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai5MZW5ndGggPSBvZmZsaW5lRmlsZUluZm8uc2l6ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHB1cmdlOiBmdW5jdGlvbiAobG9jYWxMb2NhdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmbGluZUZpbGVzRGF0YSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2ZmbGluZUZpbGVzRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZsaW5lRmlsZSA9IF8ud2hlcmUob2ZmbGluZUZpbGVzRGF0YSwge29mZmxpbmVMb2NhdGlvbjogbG9jYWxMb2NhdGlvbn0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIGNoZWNrIGlmIHRoZSBsZW5ndGggb2Ygb2ZmbGluZUZpbGUgPT09IDBcbiAgICAgICAgICAgICAgICB2YXIgb2ZmbGluZUluZm9JbmRleCA9IG9mZmxpbmVGaWxlc0RhdGEuaW5kZXhPZihvZmZsaW5lRmlsZVswXSk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVJbmZvSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVGaWxlc0RhdGEuc3BsaWNlKG9mZmxpbmVJbmZvSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNhdmVPZmZsaW5lRmlsZXNEYXRhKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZpbGVTdG9yZS5nZXRGaWxlQnlBYnNvbHV0ZVBhdGgobG9jYWxMb2NhdGlvbik7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZVN0b3JlLnJlbW92ZUZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHdyaXRlRmlsZTogZnVuY3Rpb24gKGZpbGVuYW1lLCBjb250ZW50cywgZm9sZGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9mZmxpbmVMb2NhdGlvbjtcblxuICAgICAgICByZXR1cm4gc2VsZi5maWxlU3RvcmUud3JpdGVUZXh0KGZpbGVuYW1lLCBjb250ZW50cywgZm9sZGVyKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxvY2F0aW9uT25EaXNrKSB7XG4gICAgICAgICAgICAgICAgb2ZmbGluZUxvY2F0aW9uID0gbG9jYXRpb25PbkRpc2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2F2ZU9mZmxpbmVGaWxlc0RhdGEoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmlsZVN0b3JlLmdldEZpbGVTaXplKGZpbGVuYW1lLCBmb2xkZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUxvY2F0aW9uOiBvZmZsaW5lTG9jYXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldEZpbGVuYW1lRm9yT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBleHRlbnNpb24gPSBwYXRoLmV4dG5hbWUob2JqLkZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIG9iai5faWQgKyBleHRlbnNpb247XG4gICAgfSxcblxuICAgIGdldE9mZmxpbmVMb2NhdGlvbjogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPZmZsaW5lRmlsZXNEYXRhKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZsaW5lRmlsZXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpc09mZmxpbmVVcmwgPSAhIV8uZmluZFdoZXJlKG9mZmxpbmVGaWxlc0RhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZUxvY2F0aW9uOiB1cmxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09mZmxpbmVVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2ZmbGluZUZpbGVEYXRhID0gXy5maW5kV2hlcmUob2ZmbGluZUZpbGVzRGF0YSwge1xuICAgICAgICAgICAgICAgICAgICBvbmxpbmVMb2NhdGlvbjogdXJsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob2ZmbGluZUZpbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lRmlsZURhdGEub2ZmbGluZUxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2ZmbGluZUZpbGVzUHJvY2Vzc29yOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBvZmZsaW5lVHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi9vZmZsaW5lVHJhbnNmb3JtYXRpb25zJyk7XG52YXIgZXhwYW5kUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vRXhwYW5kUHJvY2Vzc29yJyk7XG5cbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3I7XG52YXIgRXZlcmxpdmVFcnJvcnMgPSBldmVybGl2ZUVycm9yTW9kdWxlLkV2ZXJsaXZlRXJyb3JzO1xuXG52YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciBtaW5nbyA9IGNvbW1vbi5NaW5nbztcbnZhciBtb25nb1F1ZXJ5ID0gY29tbW9uLm1vbmdvUXVlcnk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9RdWVyeScpO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xudmFyIEhlYWRlcnMgPSBjb25zdGFudHMuSGVhZGVycztcbnZhciBvZmZsaW5lSXRlbVN0YXRlcyA9IGNvbnN0YW50cy5vZmZsaW5lSXRlbVN0YXRlcztcblxudmFyIHVuc3VwcG9ydGVkT2ZmbGluZUhlYWRlcnMgPSBbSGVhZGVycy5wb3dlckZpZWxkc107XG5cbnZhciB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9ucyA9IHt9O1xudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlXSA9IHRydWU7XG51bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGVdID0gdHJ1ZTtcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZV0gPSB0cnVlO1xudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlXSA9IHRydWU7XG51bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGVdID0gdHJ1ZTtcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldEFjbF0gPSB0cnVlO1xudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXJdID0gdHJ1ZTtcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcl0gPSB0cnVlO1xudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXJdID0gdHJ1ZTtcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXJdID0gdHJ1ZTtcbnVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbl0gPSB0cnVlO1xudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ291dF0gPSB0cnVlO1xudW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckNoYW5nZVBhc3N3b3JkXSA9IHRydWU7XG51bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyUmVzZXRQYXNzd29yZF0gPSB0cnVlO1xuXG5mdW5jdGlvbiBidWlsZFVzZXJzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSkge1xuICAgIHZhciB1bnN1cHBvcnRlZFVzZXJTb2NpYWxQcm92aWRlck9wZXJhdGlvbnMgPSBbXG4gICAgICAgIERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcixcbiAgICAgICAgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXIsXG4gICAgICAgIERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXJcbiAgICBdO1xuXG4gICAgdmFyIG9wZXJhdGlvbiA9IGRhdGFRdWVyeS5vcGVyYXRpb247XG4gICAgaWYgKHVuc3VwcG9ydGVkVXNlclNvY2lhbFByb3ZpZGVyT3BlcmF0aW9ucy5pbmRleE9mKG9wZXJhdGlvbikgIT09IC0xKSB7XG4gICAgICAgIG9wZXJhdGlvbiArPSBkYXRhUXVlcnkuZGF0YS5Qcm92aWRlciB8fCBkYXRhUXVlcnkuZGF0YS5JZGVudGl0eS5Qcm92aWRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1RoZSBVc2VycyBvcGVyYXRpb24gJyArIG9wZXJhdGlvbiArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xufVxuXG5mdW5jdGlvbiBidWlsZEZpbGVzRXJyb3JNZXNzYWdlKGRhdGFRdWVyeSkge1xuICAgIHJldHVybiAnVGhlIEZpbGVzIG9wZXJhdGlvbiAnICsgZGF0YVF1ZXJ5Lm9wZXJhdGlvbiArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xufVxuXG5mdW5jdGlvbiBPZmZsaW5lUXVlcnlQcm9jZXNzb3IocGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIsIG9mZmxpbmVGaWxlc1Byb2Nlc3NvciwgZXZlcmxpdmUsIHNldHVwKSB7XG4gICAgdGhpcy5fY29sbGVjdGlvbkNhY2hlID0ge307XG4gICAgdGhpcy5vZmZsaW5lRmlsZXNQcm9jZXNzb3IgPSBvZmZsaW5lRmlsZXNQcm9jZXNzb3I7XG4gICAgdGhpcy5fcGVyc2lzdGVyID0gcGVyc2lzdGVyO1xuICAgIHRoaXMuX2VuY3J5cHRpb25Qcm92aWRlciA9IGVuY3J5cHRpb25Qcm92aWRlcjtcbiAgICB0aGlzLmV2ZXJsaXZlID0gZXZlcmxpdmU7XG4gICAgdGhpcy5zZXR1cCA9IHNldHVwO1xufVxuXG5PZmZsaW5lUXVlcnlQcm9jZXNzb3IucHJvdG90eXBlID0ge1xuICAgIHByb2Nlc3NRdWVyeTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICB2YXIgdW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2UgPSB0aGlzLmdldFVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlKGRhdGFRdWVyeSk7XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSAmJiAhZGF0YVF1ZXJ5LmlzU3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcih1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc29ydCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5zb3J0KTtcbiAgICAgICAgdmFyIGxpbWl0ID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnRha2UpO1xuICAgICAgICB2YXIgc2tpcCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5za2lwKTtcbiAgICAgICAgdmFyIHNlbGVjdCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5zZWxlY3QpO1xuICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLmZpbHRlcik7XG4gICAgICAgIHZhciBleHBhbmQgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMuZXhwYW5kKTtcblxuICAgICAgICBpZiAoZGF0YVF1ZXJ5LmZpbHRlciBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyT2JqID0gZGF0YVF1ZXJ5LmZpbHRlci5idWlsZCgpO1xuICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyT2JqLiR3aGVyZSB8fCBmaWx0ZXIgfHwge307XG4gICAgICAgICAgICBzb3J0ID0gZmlsdGVyT2JqLiRzb3J0IHx8IHNvcnQ7XG4gICAgICAgICAgICBsaW1pdCA9IGZpbHRlck9iai4kdGFrZSB8fCBsaW1pdDtcbiAgICAgICAgICAgIHNraXAgPSBmaWx0ZXJPYmouJHNraXAgfHwgc2tpcDtcbiAgICAgICAgICAgIHNlbGVjdCA9IGZpbHRlck9iai4kc2VsZWN0IHx8IHNlbGVjdDtcbiAgICAgICAgICAgIGV4cGFuZCA9IGZpbHRlck9iai4kZXhwYW5kIHx8IGV4cGFuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciA9IChkYXRhUXVlcnkuZmlsdGVyIHx8IGZpbHRlcikgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvcnMgPSB1dGlscy5nZXRVbnN1cHBvcnRlZE9wZXJhdG9ycyhmaWx0ZXIpO1xuICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50ID0gdW5zdXBwb3J0ZWRPcGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICBpZiAodW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3IgJyArIHVuc3VwcG9ydGVkT3BlcmF0b3JzWzBdICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZS4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3JzICcgKyB1bnN1cHBvcnRlZE9wZXJhdG9ycy5qb2luKCcsJykgKyAnYXJlIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlLic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQoZmlsdGVyKTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGFRdWVyeS5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKGRhdGFRdWVyeSwgZmlsdGVyLCBzb3J0LCBza2lwLCBsaW1pdCwgc2VsZWN0LCBleHBhbmQpO1xuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnlJZChkYXRhUXVlcnksIGV4cGFuZCk7XG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzR2V0RG93bmxvYWRVcmxCeUlkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvd25sb2FkVXJsQnlJZChkYXRhUXVlcnkpO1xuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb3VudChkYXRhUXVlcnksIGZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoZGF0YVF1ZXJ5KTtcbiAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlOlxuICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRhdGFRdWVyeSwgZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNVcGRhdGVDb250ZW50OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUZpbGVDb250ZW50KGRhdGFRdWVyeSwgZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShkYXRhUXVlcnksIGZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZTpcbiAgICAgICAgICAgICAgICBmaWx0ZXIuX2lkID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShkYXRhUXVlcnksIGZpbHRlcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5pc1N5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcihkYXRhUXVlcnkub3BlcmF0aW9uICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZScpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldERvd25sb2FkVXJsQnlJZDogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZDtcbiAgICAgICAgdmFyIG9mZmxpbmVGaWxlUGF0aDtcblxuICAgICAgICByZXR1cm4gc2VsZi5ldmVybGl2ZVxuICAgICAgICAgICAgLmZpbGVzXG4gICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxuICAgICAgICAgICAgLmlzU3luYyhkYXRhUXVlcnkuaXNTeW5jKVxuICAgICAgICAgICAgLmdldEJ5SWQoaWQpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmV2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLmZpbGVzLl9nZXRGaWxlVXJsRm9ySWQoZmlsZS5JZCwgZmlsZS5GaWxlbmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgb2ZmbGluZUZpbGVQYXRoID0gZmlsZVBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuX29mZmxpbmVGaWxlc1Byb2Nlc3Nvci5maWxlU3RvcmUuZ2V0RmlsZUJ5QWJzb2x1dGVQYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXJpOiBvZmZsaW5lRmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2U6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnN1cHBvcnRlZE9mZmxpbmVIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gdW5zdXBwb3J0ZWRPZmZsaW5lSGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuZ2V0SGVhZGVyKGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RoZSBoZWFkZXIgJyArIGhlYWRlciArICcgaXMgbm90IHN1cHBvcnRlZCBpbiBvZmZsaW5lIG1vZGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzQ29udGVudFR5cGUudXNlcnMoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKSAmJiB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tkYXRhUXVlcnkub3BlcmF0aW9uXSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkVXNlcnNFcnJvck1lc3NhZ2UoZGF0YVF1ZXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc1NpbmdsZSA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucyAmJiBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQ7XG4gICAgICAgIHZhciBpc1VwZGF0ZUJ5RmlsdGVyID0gZGF0YVF1ZXJ5Lm9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlICYmICFpc1NpbmdsZTtcbiAgICAgICAgdmFyIGlzUmF3VXBkYXRlID0gZGF0YVF1ZXJ5Lm9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlO1xuICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyhkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpICYmIChpc1Jhd1VwZGF0ZSB8fCBpc1VwZGF0ZUJ5RmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkRmlsZXNFcnJvck1lc3NhZ2UoZGF0YVF1ZXJ5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Q3JlYXRlUmVzdWx0OiBmdW5jdGlvbiAoY3JlYXRlZEl0ZW1zLCByZXR1cm5GdWxsSXRlbSkge1xuICAgICAgICBpZiAoY3JlYXRlZEl0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChyZXR1cm5GdWxsSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gXy5leHRlbmQoe30sIGNyZWF0ZWRJdGVtc1swXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBDcmVhdGVkQXQ6IHV0aWxzLmNsb25lRGF0ZShjcmVhdGVkSXRlbXNbMF0uQ3JlYXRlZEF0KSxcbiAgICAgICAgICAgICAgICAgICAgSWQ6IGNyZWF0ZWRJdGVtc1swXS5faWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXVsdGlwbGVDcmVhdGVSZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIF8uZWFjaChjcmVhdGVkSXRlbXMsIGZ1bmN0aW9uIChjcmVhdGVkSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5GdWxsSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUNvcHkgPSBfLmV4dGVuZCh7fSwgY3JlYXRlZEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShpdGVtQ29weSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENyZWF0ZWRBdDogdXRpbHMuY2xvbmVEYXRlKGNyZWF0ZWRJdGVtLkNyZWF0ZWRBdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBJZDogY3JlYXRlZEl0ZW0uX2lkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG11bHRpcGxlQ3JlYXRlUmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IG11bHRpcGxlQ3JlYXRlUmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2NyZWF0ZUl0ZW1zKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSwgZGF0YVF1ZXJ5LmRhdGEsIGRhdGFRdWVyeS5pc1N5bmMsIGRhdGFRdWVyeS5wcmVzZXJ2ZVN0YXRlKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNyZWF0ZWRJdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBpc0ZpbGVzUXVlcnkgPSB1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENyZWF0ZVJlc3VsdChjcmVhdGVkSXRlbXMsIGlzRmlsZXNRdWVyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVhZDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyLCBzb3J0LCBza2lwLCBsaW1pdCwgc2VsZWN0LCBleHBhbmQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwYW5kUmVzdWx0O1xuXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTGVuZ3RoO1xuXG4gICAgICAgICAgICBzZWxmLl9wcmVwYXJlRXhwYW5kKGV4cGFuZCwgZGF0YVF1ZXJ5LCB0cnVlKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFJlc3VsdCA9IHByZXBhcmVFeHBhbmRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBwcmVwYXJlRXhwYW5kUmVzdWx0Lm1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwIHx8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbkxlbmd0aCA9IGFsbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5yZW1vdmVJZFRyYW5zZm9ybShyZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2V4cGFuZFJlc3VsdChleHBhbmRSZXN1bHQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQocmVzdWx0LCBjb2xsZWN0aW9uTGVuZ3RoLCBkYXRhUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3JlYWRJbnRlcm5hbDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGZpbHRlciwgc29ydCwgc2tpcCwgbGltaXQsIHNlbGVjdCkge1xuICAgICAgICB2YXIgZmlsdGVyQ29weSA9IF8uZXh0ZW5kKHt9LCBmaWx0ZXIpO1xuICAgICAgICB2YXIgYWN0dWFsRmlsdGVyID0gdGhpcy5fZ2V0V2l0aG91dERlbGV0ZWRGaWx0ZXIoZmlsdGVyQ29weSk7XG4gICAgICAgIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMudHJhdmVyc2VBbmRUcmFuc2Zvcm1GaWx0ZXJJZChhY3R1YWxGaWx0ZXIpO1xuICAgICAgICB2YXIgcXVlcnkgPSBtaW5nby5RdWVyeShhY3R1YWxGaWx0ZXIpO1xuICAgICAgICB2YXIgY3Vyc29yID0gbWluZ28uQ3Vyc29yKGNvbGxlY3Rpb24sIHF1ZXJ5LCBzZWxlY3QpO1xuICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLnNvcnQoc29ydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgY3Vyc29yLnNraXAoc2tpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgIGN1cnNvci5saW1pdChsaW1pdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXy5tYXAoY3Vyc29yLmFsbCgpLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlYWRCeUlkOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBleHBhbmQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwYW5kUmVzdWx0O1xuICAgICAgICByZXR1cm4gc2VsZi5fcHJlcGFyZUV4cGFuZChleHBhbmQsIGRhdGFRdWVyeSwgZmFsc2UpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJlcGFyZUV4cGFuZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZFJlc3VsdCA9IHByZXBhcmVFeHBhbmRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEV2ZXJsaXZlRXJyb3JzLml0ZW1Ob3RGb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2V4cGFuZFJlc3VsdChleHBhbmRSZXN1bHQsIGl0ZW0pLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQocmVzdWx0LCBudWxsLCBkYXRhUXVlcnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRCeUlkOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWQpIHtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0lkIGZpZWxkIGlzIG1hbmRhdG9yeSB3aGVuIHVzaW5nIG9mZmxpbmUgc3RvcmFnZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbGxlY3Rpb25baWRdKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF8uZXh0ZW5kKHt9LCBjb2xsZWN0aW9uW2lkXSk7XG4gICAgICAgICAgICB2YXIgaXNEZWxldGVkID0gaXRlbSAmJiBpdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQ7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0RlbGV0ZWQgPyB1bmRlZmluZWQgOiBpdGVtO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcmVwYXJlRXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kLCBkYXRhUXVlcnksIGlzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZFByb2Nlc3Nvci5wcmVwYXJlKGV4cGFuZCwgZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBpc0FycmF5LCBkYXRhUXVlcnkuZmllbGRzLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBwcmVwYXJlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0V4cGFuZEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZEV4cGFuZEV4cHJlc3Npb24uY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHByZXBhcmVSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZXhwYW5kUmVzdWx0OiBmdW5jdGlvbiAocHJlcGFyZUV4cGFuZFJlc3VsdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVFeHBhbmRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRQcm9jZXNzb3IuZXhwYW5kKHByZXBhcmVFeHBhbmRSZXN1bHQucmVsYXRpb25zVHJlZSwgcmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVNb2R1bGU6IHNlbGZcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnRXhwYW5kRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkRXhwYW5kRXhwcmVzc2lvbi5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldFdpdGhvdXREZWxldGVkRmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHZhciB3aXRob3V0RGVsZXRlZEZpbHRlciA9IHtcbiAgICAgICAgICAgICRhbmQ6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHdpdGhvdXREZWxldGVkRmlsdGVyLiRhbmQucHVzaChmaWx0ZXIpO1xuICAgICAgICB2YXIgZGVsZXRlT2ZmbGluZUZpbHRlciA9IHt9O1xuICAgICAgICBkZWxldGVPZmZsaW5lRmlsdGVyW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPSB7JG5lOiBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkfTtcbiAgICAgICAgd2l0aG91dERlbGV0ZWRGaWx0ZXIuJGFuZC5wdXNoKGRlbGV0ZU9mZmxpbmVGaWx0ZXIpO1xuICAgICAgICByZXR1cm4gd2l0aG91dERlbGV0ZWRGaWx0ZXI7XG4gICAgfSxcblxuICAgIF9nZXRVcGRhdGVJdGVtc1Jlc3VsdDogZnVuY3Rpb24gKHVwZGF0ZUl0ZW1zKSB7XG4gICAgICAgIHZhciB1cGRhdGVkSXRlbUNvdW50ID0gdXBkYXRlSXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgbW9kaWZpZWRBdFJlc3VsdCA9IHVwZGF0ZWRJdGVtQ291bnQgPyB1cGRhdGVJdGVtc1swXS5Nb2RpZmllZEF0IDogbmV3IERhdGUoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgTW9kaWZpZWRBdDogbW9kaWZpZWRBdFJlc3VsdCxcbiAgICAgICAgICAgIHJlc3VsdDogdXBkYXRlZEl0ZW1Db3VudFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUl0ZW1zKGRhdGFRdWVyeSwgZGF0YVF1ZXJ5LmRhdGEsIGZpbHRlciwgZGF0YVF1ZXJ5LmlzU3luYykudGhlbihmdW5jdGlvbiAodXBkYXRlSXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRVcGRhdGVJdGVtc1Jlc3VsdCh1cGRhdGVJdGVtcyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlSXRlbXMoZGF0YVF1ZXJ5LCBmaWx0ZXIsIGRhdGFRdWVyeS5pc1N5bmMpO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLl9nZXRDb2xsZWN0aW9uKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyUmVzdWx0ID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24sIGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe3Jlc3VsdDogZmlsdGVyUmVzdWx0Lmxlbmd0aH0pO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2V0SXRlbURhdGVzOiBmdW5jdGlvbiAoY3VycmVudEl0ZW0sIGl0ZW1Ub0NyZWF0ZSwgY29udGVudFR5cGUpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBtYW51YWxseSBjbG9uZSB0aGUgZGF0ZXMgaW4gb3JkZXIgdG8gZGVyZWZlcmVuY2UgdGhlbSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QgYXNcbiAgICAgICAgLy8gXy5leHRlbmRzIHdpbGwgcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZGF0ZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlXG4gICAgICAgIGlmIChjdXJyZW50SXRlbS5DcmVhdGVkQXQgJiYgY3VycmVudEl0ZW0uQ3JlYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShjdXJyZW50SXRlbS5DcmVhdGVkQXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEl0ZW0uTW9kaWZpZWRBdCAmJiBjdXJyZW50SXRlbS5Nb2RpZmllZEF0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQXQgPSB1dGlscy5jbG9uZURhdGUoY3VycmVudEl0ZW0uTW9kaWZpZWRBdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtVG9DcmVhdGUuTW9kaWZpZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShpdGVtVG9DcmVhdGUuQ3JlYXRlZEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQnkgPSBpdGVtVG9DcmVhdGUuQ3JlYXRlZEJ5IHx8IHRoaXMuZXZlcmxpdmUuc2V0dXAucHJpbmNpcGFsSWQgfHwgY29uc3RhbnRzLmd1aWRFbXB0eTtcbiAgICAgICAgaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQnkgPSBpdGVtVG9DcmVhdGUuTW9kaWZpZWRCeSB8fCBpdGVtVG9DcmVhdGUuQ3JlYXRlZEJ5O1xuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdVc2VycycpIHtcbiAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5Pd25lciA9IGl0ZW1Ub0NyZWF0ZS5faWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtVG9DcmVhdGUuT3duZXIgPSBpdGVtVG9DcmVhdGUuQ3JlYXRlZEJ5IHx8IGNvbnN0YW50cy5ndWlkRW1wdHk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX21hcENyZWF0ZUl0ZW06IGZ1bmN0aW9uIChjdXJyZW50SXRlbSwgY29sbGVjdGlvbiwgaXNTeW5jLCBwcmVzZXJ2ZVN0YXRlLCBjb250ZW50VHlwZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGl0ZW1Ub0NyZWF0ZSA9IF8uZXh0ZW5kKHt9LCBjdXJyZW50SXRlbSk7XG4gICAgICAgIGl0ZW1Ub0NyZWF0ZS5faWQgPSBpdGVtVG9DcmVhdGUuSWQgfHwgdXRpbHMudXVpZCgpO1xuICAgICAgICBkZWxldGUgaXRlbVRvQ3JlYXRlLklkO1xuXG4gICAgICAgIHZhciBleGlzdGluZ0l0ZW0gPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub0NyZWF0ZS5faWQpO1xuICAgICAgICB2YXIgaXRlbUV4aXN0cyA9ICEhZXhpc3RpbmdJdGVtO1xuICAgICAgICB2YXIgc3RhdGU7XG4gICAgICAgIGlmIChpdGVtRXhpc3RzICYmICghaXNTeW5jICYmICFwcmVzZXJ2ZVN0YXRlKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIHJldHVybiB0aGUgc2FtZSBlcnJvciBhcyB0aGUgc2VydmVyIGRvZXNcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdBbiBpdGVtIHdpdGggdGhlIHNwZWNpZmllZCBpZCBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzU3luYyAmJiBwcmVzZXJ2ZVN0YXRlICYmIGl0ZW1FeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGV4aXN0aW5nSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGlzU3luYyA/IHVuZGVmaW5lZCA6IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7IC8vIHNldCB0aGUgc3RhdGUgdG8gY3JlYXRlZCBvbmx5IGlmIG5vdCBzeW5jaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzSXRlbVJlc3VsdCgpIHtcbiAgICAgICAgICAgIHNlbGYuX3NldEl0ZW1EYXRlcyhjdXJyZW50SXRlbSwgaXRlbVRvQ3JlYXRlLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICBzZWxmLl9zZXRJdGVtKGNvbGxlY3Rpb24sIF8uZXh0ZW5kKHt9LCBpdGVtVG9DcmVhdGUpLCBzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVRvQ3JlYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzQ29udGVudFR5cGUuZmlsZXMoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vZmZsaW5lRmlsZXNQcm9jZXNzb3IudXBzZXJ0RmlsZUZyb21PYmplY3QoaXRlbVRvQ3JlYXRlLCB0cnVlLCBpc1N5bmMpLnRoZW4ocHJvY2Vzc0l0ZW1SZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NJdGVtUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NyZWF0ZUl0ZW1zOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGl0ZW1zLCBpc1N5bmMsIHByZXNlcnZlU3RhdGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29sbGVjdGlvbihjb250ZW50VHlwZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zRm9yQ3JlYXRlID0gXy5pc0FycmF5KGl0ZW1zKSA/IGl0ZW1zIDogW2l0ZW1zXTtcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZEl0ZW1zID0gXy5tYXAoaXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChjdXJyZW50SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFwQ3JlYXRlSXRlbShjdXJyZW50SXRlbSwgY29sbGVjdGlvbiwgaXNTeW5jLCBwcmVzZXJ2ZVN0YXRlLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcnN2cC5hbGwoY3JlYXRlZEl0ZW1zKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YShjb250ZW50VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElkcyBhcmUgZ2VuZXJhdGVkIHJlZ2FyZGxlc3Mgb2YgdGhlIGF1dG9HZW5lcmF0ZUlkIG9wdGlvbi4gSG93ZXZlciB0aGUgSWQncyBhcmUgb21pdHRlZCB3aGVuIHJldHVybmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaXRlbXMgdG8gdGhlIGNsaWVudCBpZiBhdXRvR2VuZXJhdGVJZCBpcyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoY29udGVudFR5cGUpICYmICFpc1N5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRJdGVtcyA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlSWRUcmFuc2Zvcm0oaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfYXBwbHlVcGRhdGVPcGVyYXRpb246IGZ1bmN0aW9uIChvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb24sIGl0ZW1Ub1VwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jLCBtb2RpZmllZEF0KSB7XG4gICAgICAgIHZhciBkYk9wZXJhdG9ycyA9IHV0aWxzLmdldERiT3BlcmF0b3JzKG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbiwgdHJ1ZSk7XG4gICAgICAgIHZhciBoYXNEYk9wZXJhdG9yID0gZGJPcGVyYXRvcnMubGVuZ3RoICE9PSAwO1xuXG4gICAgICAgIHZhciB1cGRhdGVFeHByZXNzaW9uO1xuICAgICAgICBpZiAoaGFzRGJPcGVyYXRvcikge1xuICAgICAgICAgICAgdXBkYXRlRXhwcmVzc2lvbiA9IG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgJHNldDogb3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGVFeHByZXNzaW9uRm9yVXNlciA9IHtcbiAgICAgICAgICAgIE1vZGlmaWVkQnk6IHRoaXMuZXZlcmxpdmUuc2V0dXAucHJpbmNpcGFsSWQgfHwgY29uc3RhbnRzLmd1aWRFbXB0eVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVFeHByZXNzaW9uLiRzZXQgPSBfLmV4dGVuZCh1cGRhdGVFeHByZXNzaW9uRm9yVXNlciwgdXBkYXRlRXhwcmVzc2lvbi4kc2V0KTtcblxuICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB1cGRhdGVFeHByZXNzaW9uLiRzZXQuTW9kaWZpZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb24uTW9kaWZpZWRBdCB8fCBtb2RpZmllZEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vbmdvUXVlcnkoaXRlbVRvVXBkYXRlLCB7fSwgdXBkYXRlRXhwcmVzc2lvbiwge3N0cmljdDogdHJ1ZX0pOyAvLyBTZXR0aW5nIHN0cmljdCB0byB0cnVlIHNvIG9ubHkgZXhhY3QgbWF0Y2hlcyB3b3VsZCBiZSB1cGRhdGVkXG5cbiAgICAgICAgaXRlbVRvVXBkYXRlLl9pZCA9IGl0ZW1Ub1VwZGF0ZS5faWQgfHwgdXBkYXRlRXhwcmVzc2lvbi5faWQgfHwgdXBkYXRlRXhwcmVzc2lvbi5JZDtcbiAgICAgICAgZGVsZXRlIGl0ZW1Ub1VwZGF0ZS5JZDtcblxuICAgICAgICB2YXIgbmV3U3RhdGU7XG4gICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Ub1VwZGF0ZVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0SXRlbShjb2xsZWN0aW9uLCBpdGVtVG9VcGRhdGUsIG5ld1N0YXRlKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRmlsZUNvbnRlbnQ6IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgdmFyIGlzU3luYyA9IGRhdGFRdWVyeS5pc1N5bmM7XG4gICAgICAgIHZhciB1cGRhdGVFeHByZXNzaW9uID0gZGF0YVF1ZXJ5LmRhdGE7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW1JZCA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZDtcbiAgICAgICAgdmFyIHVwZGF0ZUl0ZW1zO1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb2xsZWN0aW9uKHR5cGVOYW1lKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlSXRlbUZvclVwZGF0ZSA9IHNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbUlkKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtcyA9IFtzaW5nbGVJdGVtRm9yVXBkYXRlXTtcbiAgICAgICAgICAgICAgICBzaW5nbGVJdGVtRm9yVXBkYXRlLmJhc2U2NCA9IHVwZGF0ZUV4cHJlc3Npb24uYmFzZTY0O1xuICAgICAgICAgICAgICAgIHNpbmdsZUl0ZW1Gb3JVcGRhdGUuRmlsZW5hbWUgPSB1cGRhdGVFeHByZXNzaW9uLkZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHNpbmdsZUl0ZW1Gb3JVcGRhdGUuQ29udGVudFR5cGUgPSB1cGRhdGVFeHByZXNzaW9uLkNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaW5nbGVJdGVtRm9yVXBkYXRlLlVyaTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vdmVyd3JpdGVGaWxlKGl0ZW1JZCwgc2luZ2xlSXRlbUZvclVwZGF0ZSwgaXNTeW5jKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hcHBseVVwZGF0ZU9wZXJhdGlvbih1cGRhdGVFeHByZXNzaW9uLCBzaW5nbGVJdGVtRm9yVXBkYXRlLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NldEl0ZW0oY29sbGVjdGlvbiwgc2luZ2xlSXRlbUZvclVwZGF0ZSwgY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YSh0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRVcGRhdGVJdGVtc1Jlc3VsdCh1cGRhdGVJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX292ZXJ3cml0ZUZpbGU6IGZ1bmN0aW9uIChpdGVtSWQsIGl0ZW1Gb3JVcGRhdGUsIGlzU3luYykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuZXZlcmxpdmUub2ZmbGluZVN0b3JhZ2UuZmlsZXMucHVyZ2UoaXRlbUlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLm9mZmxpbmVGaWxlc1Byb2Nlc3Nvci51cHNlcnRGaWxlRnJvbU9iamVjdChpdGVtRm9yVXBkYXRlLCB0cnVlLCBpc1N5bmMpO1xuICAgICAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUl0ZW1zOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCB1cGRhdGVFeHByZXNzaW9uLCBmaWx0ZXIsIGlzU3luYykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcblxuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUl0ZW1zO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucyAmJiBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpbmdsZUl0ZW1Gb3JVcGRhdGUgPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1JZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1zID0gW3NpbmdsZUl0ZW1Gb3JVcGRhdGVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKGNvbGxlY3Rpb25OYW1lKSAmJiB1cGRhdGVFeHByZXNzaW9uLiRzZXQgJiYgdXBkYXRlRXhwcmVzc2lvbi4kc2V0LkZpbGVuYW1lIHx8IHVwZGF0ZUV4cHJlc3Npb24uRmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHVwZGF0ZUV4cHJlc3Npb24uRmlsZW5hbWUgfHwgdXBkYXRlRXhwcmVzc2lvbi4kc2V0LkZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5ldmVybGl2ZS5vZmZsaW5lU3RvcmFnZS5maWxlcy5jaGFuZ2VGaWxlRXh0ZW5zaW9uQnlJZChpdGVtSWQsIGV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FwcGx5VXBkYXRlT3BlcmF0aW9uKHVwZGF0ZUV4cHJlc3Npb24sIHNpbmdsZUl0ZW1Gb3JVcGRhdGUsIGNvbGxlY3Rpb24sIGlzU3luYywgZGF0YVF1ZXJ5Lk1vZGlmaWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEoY29sbGVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlSXRlbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hcHBseVVwZGF0ZU9wZXJhdGlvbih1cGRhdGVFeHByZXNzaW9uLCBzaW5nbGVJdGVtRm9yVXBkYXRlLCBjb2xsZWN0aW9uLCBpc1N5bmMsIGRhdGFRdWVyeS5Nb2RpZmllZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1zID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24sIGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVG9VcGRhdGUgPSB1cGRhdGVJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRXhpc3RzID0gISFzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub1VwZGF0ZS5faWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbUV4aXN0cyAmJiAhaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogW29mZmxpbmVdIHJldHVybiB0aGUgY29ycmVjdCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFdmVybGl2ZUVycm9ycy5pdGVtTm90Rm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hcHBseVVwZGF0ZU9wZXJhdGlvbih1cGRhdGVFeHByZXNzaW9uLCBpdGVtVG9VcGRhdGUsIGNvbGxlY3Rpb24sIGlzU3luYywgZGF0YVF1ZXJ5Lk1vZGlmaWVkQXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3BlcnNpc3REYXRhKGNvbGxlY3Rpb25OYW1lKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlSXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRBbGxDb2xsZWN0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5nZXRBbGxEYXRhKGZ1bmN0aW9uIChhbGxEYXRhKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFsbERhdGEsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gc2VsZi5fZW5jcnlwdGlvblByb3ZpZGVyLmRlY3J5cHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhW2tleV0gPSBKU09OLnBhcnNlKGRlY3J5cHRlZERhdGEgfHwgJ3t9JywgdXRpbHMucGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcigpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoYWxsRGF0YSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldENvbGxlY3Rpb246IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHBlcnNpc3RlciBpZiB0aGVyZSBpcyBubyBkYXRhIGluIHRoZSBjb2xsZWN0aW9uIGNhY2hlIGZvciB0aGlzIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgaWYgKCFzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGVyc2lzdGVyLmdldERhdGEoY29udGVudFR5cGUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0ZWREYXRhUmF3ID0gc2VsZi5fZW5jcnlwdGlvblByb3ZpZGVyLmRlY3J5cHQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gSlNPTi5wYXJzZShkZWNyeXB0ZWREYXRhUmF3IHx8ICd7fScsIHV0aWxzLnBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV0gPSBkZWNyeXB0ZWREYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zZXRJdGVtOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgZGVsZXRlIGl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9IHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29sbGVjdGlvbltpdGVtLl9pZF0gPSBpdGVtO1xuICAgIH0sXG5cblxuICAgIF9nZXREaXJ0eUl0ZW1zOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgZmlsdGVyID0ge307XG4gICAgICAgIGZpbHRlcltjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID0geyRleGlzdHM6IHRydWV9O1xuICAgICAgICB2YXIgcXVlcnkgPSBtaW5nby5RdWVyeShmaWx0ZXIpO1xuICAgICAgICB2YXIgY3Vyc29yID0gbWluZ28uQ3Vyc29yKGNvbGxlY3Rpb24sIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5hbGwoKTtcbiAgICB9LFxuXG4gICAgX3BlcnNpc3REYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZURhdGEgPSBzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdIHx8IHt9O1xuICAgICAgICAgICAgc2VsZi5fdHJhbnNmb3JtUGVyc2lzdGVkRGF0YShjb250ZW50VHlwZSwgY29udGVudFR5cGVEYXRhKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZURhdGFSYXcgPSBKU09OLnN0cmluZ2lmeShjb250ZW50VHlwZURhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlRGF0YVJhd0VuY3J5cHRlZCA9IHNlbGYuX2VuY3J5cHRpb25Qcm92aWRlci5lbmNyeXB0KGNvbnRlbnRUeXBlRGF0YVJhdyk7XG4gICAgICAgICAgICBzZWxmLl9wZXJzaXN0ZXIuc2F2ZURhdGEoY29udGVudFR5cGUsIGNvbnRlbnRUeXBlRGF0YVJhd0VuY3J5cHRlZCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zaG91bGRBdXRvZ2VuZXJhdGVJZEZvckNvbnRlbnRUeXBlOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5zZXR1cCAmJiB0aGlzLnNldHVwLnR5cGVTZXR0aW5ncyAmJiB0aGlzLnNldHVwLnR5cGVTZXR0aW5nc1tjb250ZW50VHlwZV0gJiYgdGhpcy5zZXR1cC50eXBlU2V0dGluZ3NbY29udGVudFR5cGVdLmF1dG9HZW5lcmF0ZUlkID09PSBmYWxzZSk7XG4gICAgfSxcblxuICAgIF9jbGVhckl0ZW06IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBpdGVtKSB7XG4gICAgICAgIGRlbGV0ZSBjb2xsZWN0aW9uW2l0ZW0uX2lkXTtcbiAgICB9LFxuXG4gICAgX21hcFJlbW92ZUl0ZW06IGZ1bmN0aW9uIChpdGVtVG9SZW1vdmUsIGNvbGxlY3Rpb24sIGlzU3luYywgY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKGNvbGxlY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmV2ZXJsaXZlLm9mZmxpbmVTdG9yYWdlLmZpbGVzLnB1cmdlKGl0ZW1Ub1JlbW92ZS5faWQpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRvUmVtb3ZlLl9pZCA9IGl0ZW1Ub1JlbW92ZS5faWQgfHwgaXRlbVRvUmVtb3ZlLklkO1xuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1FeGlzdHMgPSAhIXNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbVRvUmVtb3ZlLl9pZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1FeGlzdHMgJiYgIWlzU3luYykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignQ2Fubm90IGRlbGV0ZSBpdGVtIC0gaXRlbSB3aXRoIGlkICcgKyBpdGVtVG9SZW1vdmUuX2lkICsgJyBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBoYXMgZXhpc3RlZCBvbmx5IG9mZmxpbmUgb3IgdGhlIGRhdGEgaXMgc3luY2luZ1xuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgaXRlbSB3YXMgZGVsZXRlZCBieSB0aGUgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVneVxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVGcm9tTWVtb3J5ID0gaXRlbVRvUmVtb3ZlW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQgfHwgaXNTeW5jO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVGcm9tTWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NsZWFySXRlbShjb2xsZWN0aW9uLCBpdGVtVG9SZW1vdmUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3NldEl0ZW0oY29sbGVjdGlvbiwgaXRlbVRvUmVtb3ZlLCBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUl0ZW1zOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIsIGlzU3luYykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcblxuICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zVG9SZW1vdmUgPSBzZWxmLl9yZWFkSW50ZXJuYWwoY29sbGVjdGlvbiwgZmlsdGVyKTtcblxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkSXRlbXNQcm9taXNlcyA9IF8ubWFwKGl0ZW1zVG9SZW1vdmUsIGZ1bmN0aW9uIChpdGVtVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX21hcFJlbW92ZUl0ZW0oaXRlbVRvUmVtb3ZlLCBjb2xsZWN0aW9uLCBpc1N5bmMsIGNvbGxlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByc3ZwLmFsbChyZW1vdmVkSXRlbXNQcm9taXNlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGl0ZW1zVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEoY29sbGVjdGlvbk5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtc1RvUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaXRlbXNUb1JlbW92ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl90cmFuc2Zvcm1PZmZsaW5lUmVzdWx0KGl0ZW1zVG9SZW1vdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfYXBwbHlUcmFuc2Zvcm1hdGlvbnM6IGZ1bmN0aW9uICh0cmFuc2Zvcm1lZFJlc3VsdCwgdHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCkpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0cmFuc2Zvcm1hdGlvbnMsIGZ1bmN0aW9uICh0cmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdC5tYXAoZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRSZXN1bHQucmVzdWx0W2tleV0gPSB0cmFuc2Zvcm1hdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uZWFjaCh0cmFuc2Zvcm1hdGlvbnMsIGZ1bmN0aW9uICh0cmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCA9IHRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtT2ZmbGluZVJlc3VsdDogZnVuY3Rpb24gKHJlc3VsdFNldCwgY291bnQsIGRhdGFRdWVyeSwgYWRkaXRpb25hbFRyYW5zZm9ybWF0aW9ucykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRSZXN1bHQgPSB7XG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFNldCxcbiAgICAgICAgICAgIGNvdW50OiBjb3VudCB8fCAocmVzdWx0U2V0IHx8IFtdKS5sZW5ndGhcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKGNvdW50ICE9PSB1bmRlZmluZWQgJiYgY291bnQgIT09IG51bGwpIHx8IEFycmF5LmlzQXJyYXkocmVzdWx0U2V0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRSZXN1bHQuY291bnQgPSBjb3VudCB8fCByZXN1bHRTZXQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuXG4gICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0pO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZU1hcmtlcnNUcmFuc2Zvcm0pO1xuXG4gICAgICAgIGlmIChkYXRhUXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBpbmNsdWRlQ291bnQgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyKEhlYWRlcnMuaW5jbHVkZUNvdW50KTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQ291bnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRyYW5zZm9ybWVkUmVzdWx0LmNvdW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2luZ2xlRmllbGRFeHByZXNzaW9uID0gZGF0YVF1ZXJ5LmdldEhlYWRlcihIZWFkZXJzLnNpbmdsZUZpZWxkKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlRmllbGRFeHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuc2luZ2xlRmllbGRUcmFuc2Zvcm0uYmluZCh0aGlzLCBzaW5nbGVGaWVsZEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRpdGlvbmFsVHJhbnNmb3JtYXRpb25zKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMgPSB0cmFuc2Zvcm1hdGlvbnMuY29uY2F0KGFkZGl0aW9uYWxUcmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm1hdGlvbnModHJhbnNmb3JtZWRSZXN1bHQsIHRyYW5zZm9ybWF0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkUmVzdWx0LmNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFJlc3VsdDtcbiAgICB9LFxuXG4gICAgX3RyYW5zZm9ybVBlcnNpc3RlZERhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgY29udGVudFR5cGVEYXRhKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1GaWVsZHMgPSBbXTtcblxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdVc2VycycpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpZWxkcyA9IHRyYW5zZm9ybUZpZWxkcy5jb25jYXQoWydQYXNzd29yZCcsICdTZWNyZXRRdWVzdGlvbklkJywgJ1NlY3JldEFuc3dlciddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1GaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVEYXRhLCBmdW5jdGlvbiAoY29udGVudFR5cGVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZUZpZWxkc1RyYW5zZm9ybShjb250ZW50VHlwZU9iamVjdCwgdHJhbnNmb3JtRmllbGRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHB1cmdlQWxsOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uQ2FjaGUgPSB7fTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5wdXJnZUFsbChzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9LFxuXG4gICAgcHVyZ2U6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5fcGVyc2lzdGVyLnB1cmdlKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9mZmxpbmVRdWVyeVByb2Nlc3NvcjsiLCJ2YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XG52YXIgZXZlcmxpdmVFcnJvck1vZHVsZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKTtcbnZhciBFdmVybGl2ZUVycm9yID0gZXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9yO1xudmFyIEV2ZXJsaXZlRXJyb3JzID0gZXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9ycztcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbnZhciBvZmZsaW5lSXRlbVN0YXRlcyA9IGNvbnN0YW50cy5vZmZsaW5lSXRlbVN0YXRlcztcbnZhciBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXInKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBfID0gY29tbW9uLl87XG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xudmFyIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMgPSByZXF1aXJlKCcuL29mZmxpbmVUcmFuc2Zvcm1hdGlvbnMnKTtcbnZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcbnZhciBPZmZsaW5lUXVlcnlQcm9jZXNzb3IgPSByZXF1aXJlKCcuL09mZmxpbmVRdWVyeVByb2Nlc3NvcicpO1xudmFyIE9mZmxpbmVGaWxlc1Byb2Nlc3NvciA9IHJlcXVpcmUoJy4vT2ZmbGluZUZpbGVzUHJvY2Vzc29yJyk7XG52YXIgT2ZmbGluZUZpbGVzTW9kdWxlID0gcmVxdWlyZSgnLi9PZmZsaW5lRmlsZXNNb2R1bGUnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgc3luY0xvY2F0aW9uID0ge1xuICAgIHNlcnZlcjogJ3NlcnZlcicsXG4gICAgY2xpZW50OiAnY2xpZW50J1xufTtcblxudmFyIHN5bmNTdGFydEV2ZW50RGF0YSA9IHtcbiAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoRXZlcmxpdmVFcnJvcnMuc3luY0NhbmNlbGxlZEJ5VXNlci5tZXNzYWdlLCBFdmVybGl2ZUVycm9ycy5zeW5jQ2FuY2VsbGVkQnlVc2VyLmNvZGUpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgT2ZmbGluZU1vZHVsZVxuICogQGNsYXNzRGVzYyBBIGNsYXNzIHByb3ZpZGluZyBhY2Nlc3MgdG8gdGhlIHZhcmlvdXMgb2ZmbGluZSBzdG9yYWdlIGZlYXR1cmVzLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUge0BsaW5rIE9mZmxpbmVNb2R1bGV9IGNsYXNzLlxuICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICogQG1lbWJlciB7T2ZmbGluZU1vZHVsZX0gb2ZmbGluZVN0b3JhZ2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2ZmbGluZU1vZHVsZShldmVybGl2ZSwgb3B0aW9ucywgcGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlcmxpdmUgPSBldmVybGl2ZTtcbiAgICAgICAgdGhpcy5zZXR1cCA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2lzU3luY2hyb25pemluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbmNyeXB0aW9uUHJvdmlkZXIgPSBlbmNyeXB0aW9uUHJvdmlkZXI7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dXAuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUZpbGVzUHJvY2Vzc29yID0gbmV3IE9mZmxpbmVGaWxlc1Byb2Nlc3Nvcih0aGlzLnNldHVwLCB0aGlzLl9ldmVybGl2ZSk7XG4gICAgICAgICAgICB0aGlzLl9xdWVyeVByb2Nlc3NvciA9IG5ldyBPZmZsaW5lUXVlcnlQcm9jZXNzb3IocGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIsIHRoaXMuX29mZmxpbmVGaWxlc1Byb2Nlc3NvciwgdGhpcy5fZXZlcmxpdmUsIHRoaXMuc2V0dXApO1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtPZmZsaW5lRmlsZXNNb2R1bGVde0BsaW5rIE9mZmxpbmVGaWxlc01vZHVsZX0gY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCBmaWxlcyBpbiBvZmZsaW5lIG1vZGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtPZmZsaW5lRmlsZXNNb2R1bGV9IGZpbGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgT2ZmbGluZUZpbGVzTW9kdWxlKHRoaXMuX29mZmxpbmVGaWxlc1Byb2Nlc3NvciwgdGhpcy5fZXZlcmxpdmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldFN5bmNGaWx0ZXJGb3JJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQoaXRlbSk7XG4gICAgICAgIGZpbHRlci5Nb2RpZmllZEF0ID0gaXRlbS5Nb2RpZmllZEF0O1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBJZDogaXRlbS5JZFxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZS5cbiAgICAgICAgICogQG1ldGhvZCBwdXJnZUFsbFxuICAgICAgICAgKiBAbmFtZSBwdXJnZUFsbFxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZS5cbiAgICAgICAgICogQG1ldGhvZCBwdXJnZUFsbFxuICAgICAgICAgKiBAbmFtZSBwdXJnZUFsbFxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgcHVyZ2VBbGw6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yLnB1cmdlQWxsKHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZGF0YSBmb3IgYSBzcGVjaWZpYyBjb250ZW50IHR5cGUgZnJvbSB0aGUgb2ZmbGluZSBzdG9yYWdlLlxuICAgICAgICAgKiBAbWV0aG9kIHB1cmdlXG4gICAgICAgICAqIEBuYW1lIHB1cmdlXG4gICAgICAgICAqIEBtZW1iZXJPZiBPZmZsaW5lTW9kdWxlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSB0byBwdXJnZS5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBvZmZsaW5lIHN0b3JhZ2UuXG4gICAgICAgICAqIEBtZXRob2QgcHVyZ2VcbiAgICAgICAgICogQG5hbWUgcHVyZ2VcbiAgICAgICAgICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50VHlwZSBUaGUgY29udGVudCB0eXBlIHRvIHB1cmdlLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAgICAgICAqL1xuICAgICAgICBwdXJnZTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yLnB1cmdlKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvY2Vzc1F1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVByb2Nlc3Nvci5wcm9jZXNzUXVlcnkocXVlcnkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRPZmZsaW5lOiBmdW5jdGlvbiAob2ZmbGluZSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cC5vZmZsaW5lID0gb2ZmbGluZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc09ubGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnNldHVwLm9mZmxpbmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3ByZXBhcmVTeW5jRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlc0ZvclN5bmMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlc1N5bmNEYXRhID0ge307XG4gICAgICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XG4gICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVzRm9yU3luYywgZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCB0eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBzeW5jSXRlbXMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGNvbnRlbnRUeXBlLm9mZmxpbmVJdGVtc1RvU3luYyk7XG4gICAgICAgICAgICAgICAgdmFyIHN5bmNEYXRhID0gc2VsZi5fZ2V0U3luY0l0ZW1TdGF0ZXModHlwZU5hbWUsIHN5bmNJdGVtcywgY29udGVudFR5cGUuc2VydmVySXRlbXMpO1xuICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHN5bmNEYXRhLmNvbmZsaWN0cyk7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzU3luY0RhdGFbdHlwZU5hbWVdID0gc3luY0RhdGEuaXRlbXNGb3JTeW5jO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiBjb25mbGljdHMsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzU3luY0RhdGE6IGNvbnRlbnRUeXBlc1N5bmNEYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXNvbHZlQ29uZmxpY3RzOiBmdW5jdGlvbiAoc3luY0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseVJlc29sdXRpb25TdHJhdGVneShzeW5jRGF0YS5jb25mbGljdHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWVyZ2VSZXNvbHZlZENvbmZsaWN0cyhzeW5jRGF0YS5jb25mbGljdHMsIHN5bmNEYXRhLmNvbnRlbnRUeXBlc1N5bmNEYXRhKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNEYXRhLmNvbnRlbnRUeXBlc1N5bmNEYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzU3luY2hyb25pemluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzU3luY2hyb25pemluZztcbiAgICAgICAgfSxcblxuICAgICAgICBfZmlyZVN5bmNTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5faXNTeW5jaHJvbml6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2lzU3luY2hyb25pemluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2ZXJsaXZlLl9lbWl0dGVyLmVtaXQoJ3N5bmNTdGFydCcsIHN5bmNTdGFydEV2ZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2ZpcmVTeW5jRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX2lzU3luY2hyb25pemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zLCBmdW5jdGlvbiAoc3luY2VkSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRUb1NlcnZlciArPSBfLndoZXJlKHN5bmNlZEl0ZW1zLCB7c3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlcn0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRUb0NsaWVudCArPSBfLndoZXJlKHN5bmNlZEl0ZW1zLCB7c3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudH0pLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9ldmVybGl2ZS5fZW1pdHRlci5lbWl0KCdzeW5jRW5kJywgdGhpcy5fc3luY1Jlc3VsdEluZm8pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNSZXN1bHRJbmZvO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9lYWNoU3luY0l0ZW06IGZ1bmN0aW9uIChpdGVtcywgZ2V0RmlsdGVyRnVuY3Rpb24sIGNvbnRlbnRUeXBlTmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIF8uZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUZpbHRlciA9IGdldEZpbHRlckZ1bmN0aW9uKGl0ZW0ucmVtb3RlSXRlbSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGZvciB0aGlzIGl0ZW0gd2UgZG8gbm90IHdhbnQgdG8gdHJ5IGFuZCBzeW5jIGl0IGFnYWluXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdEl0ZW0gPSBpdGVtLnJlc3VsdGluZ0l0ZW07XG4gICAgICAgICAgICAgICAgdmFyIGlzQ3VzdG9tID0gaXRlbS5pc0N1c3RvbTtcbiAgICAgICAgICAgICAgICBpZiAoXy5zb21lKHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW2NvbnRlbnRUeXBlTmFtZV0sIHtpdGVtSWQ6IHJlc3VsdEl0ZW0uSWR9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uKHJlc3VsdEl0ZW0sIGl0ZW1GaWx0ZXIsIGlzQ3VzdG9tKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG91bGRBdXRvZ2VuZXJhdGVJZEZvckNvbnRlbnRUeXBlOiBmdW5jdGlvbiAoY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVByb2Nlc3Nvci5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShjb2xsZWN0aW9uTmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZENyZWF0ZWRGaWxlVG9TeW5jUHJvbWlzZXM6IGZ1bmN0aW9uIChyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSwgc3luY1Byb21pc2VzLCBjb2xsZWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBfLmVhY2gocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVzQ29sbGVjdGlvbiA9IHNlbGYuX2V2ZXJsaXZlLmZpbGVzO1xuICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtLklkXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbGVzLmdldE9mZmxpbmVMb2NhdGlvbihpdGVtLklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl90cmFuc2ZlckZpbGUoZmFsc2UsIGl0ZW0sIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkV2l0aFNlcnZlclJlc3BvbnNlSXRlbSA9IF8uZXh0ZW5kKHt9LCBpdGVtLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRTeW5jZWRJdGVtVG9SZXN1bHQobWVyZ2VkV2l0aFNlcnZlclJlc3BvbnNlSXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlc0NvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlU2luZ2xlKG1lcmdlZFdpdGhTZXJ2ZXJSZXNwb25zZUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5jbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3RyYW5zZmVyRmlsZTogZnVuY3Rpb24gKGlzVXBkYXRlLCBpdGVtLCBsb2NhdGlvbikge1xuICAgICAgICAgICAgdmFyIHNkayA9IHRoaXMuX2V2ZXJsaXZlO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWRVcmwgPSBzZGsuZmlsZXMuZ2V0VXBsb2FkVXJsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVFeGlzdHNQcm9taXNlID0gdXRpbHMuc3VjY2Vzc2Z1bFByb21pc2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlRXhpc3RzUHJvbWlzZSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNkay5maWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRCeUlkKGl0ZW0uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpbGVFeGlzdHNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGZpbGVFeGlzdHNPblNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuVXBkYXRlID0gaXNVcGRhdGUgJiYgZmlsZUV4aXN0c09uU2VydmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRVcmwgKz0gJy8nICsgaXRlbS5JZCArICcvQ29udGVudCc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVRyYW5zZmVyID0gbmV3IEZpbGVUcmFuc2ZlcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUtleSA9IGNvbnN0YW50cy5maWxlVXBsb2FkS2V5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVLZXk6IGZpbGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiBjYW5VcGRhdGUgPyAnUFVUJyA6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBpdGVtLkNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGl0ZW0uRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZGsuYnVpbGRBdXRoSGVhZGVyKClcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChpdGVtLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeGVkS2V5ID0gY29uc3RhbnRzLmZpbGVVcGxvYWRLZXkgKyBjb25zdGFudHMuZmlsZVVwbG9hZERlbGltaXRlciArIGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zW3ByZWZpeGVkS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBmaWxlVHJhbnNmZXIudXBsb2FkKGxvY2F0aW9uLCB1cGxvYWRVcmwsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRSZXN1bHQgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5wYXJzZUpTT04ocmVzdWx0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXN1bHQuUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkocGFyc2VkUmVzdWx0LlJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBwYXJzZWRSZXN1bHQuUmVzdWx0WzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXJzZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZENyZWF0ZWRPYmplY3RUb1N5bmNQcm9taXNlczogZnVuY3Rpb24gKHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCBjb250ZW50VHlwZURhdGEsIGNvbGxlY3Rpb25OYW1lLCBpZHMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc3luY1Byb21pc2VzW29mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWRdID1cbiAgICAgICAgICAgICAgICBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlID0gXy5tYXAocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLklkID0gcmVzLnJlc3VsdFtpbmRleF0uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uQ3JlYXRlZEF0ID0gaXRlbS5Nb2RpZmllZEF0ID0gcmVzLnJlc3VsdFtpbmRleF0uQ3JlYXRlZEF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmlzQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRTeW5jZWRJdGVtVG9SZXN1bHQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5jbGllbnQsIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChjcmVhdGVkSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFN5bmNlZEl0ZW1Ub1Jlc3VsdChjcmVhdGVkSXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHMgJiYgaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0ge0lkOiB7JGluOiBpZHN9fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRlc3Ryb3koZmlsdGVyKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5jbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkQ3JlYXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWU7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSA9IF8ucGx1Y2soY29udGVudFR5cGVEYXRhLmNyZWF0ZWRJdGVtcywgJ3Jlc3VsdGluZ0l0ZW0nKTtcbiAgICAgICAgICAgIHZhciBpZHM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGUoY29sbGVjdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWRzID0gXy5wbHVjayhyZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSwgJ0lkJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZUlkVHJhbnNmb3JtKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzQ29udGVudFR5cGUuZmlsZXMoY29sbGVjdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENyZWF0ZWRGaWxlVG9TeW5jUHJvbWlzZXMocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIHN5bmNQcm9taXNlcywgY29sbGVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ3JlYXRlZE9iamVjdFRvU3luY1Byb21pc2VzKHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCBjb250ZW50VHlwZURhdGEsIGNvbGxlY3Rpb25OYW1lLCBpZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9hZGRVcGRhdGVkSXRlbXNGb3JTeW5jOiBmdW5jdGlvbiAoY29udGVudFR5cGVEYXRhLCBnZXRGaWx0ZXJPcGVyYXRpb24sIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sIGl0ZW1VcGRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICAgICAgc2VsZi5fZWFjaFN5bmNJdGVtKGNvbnRlbnRUeXBlRGF0YS5tb2RpZmllZEl0ZW1zLCBnZXRGaWx0ZXJPcGVyYXRpb24sIGNvbGxlY3Rpb25OYW1lLCBpdGVtVXBkYXRlT3BlcmF0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkRGVsZXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgZ2V0RmlsdGVyT3BlcmF0aW9uLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBpdGVtRGVsZXRlT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICAgICAgc2VsZi5fZWFjaFN5bmNJdGVtKGNvbnRlbnRUeXBlRGF0YS5kZWxldGVkSXRlbXMsIGdldEZpbHRlck9wZXJhdGlvbiwgY29sbGVjdGlvbk5hbWUsIGl0ZW1EZWxldGVPcGVyYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vblN5bmNSZXNwb25zZTogZnVuY3Rpb24gKHJlcywgaXRlbSwgY29sbGVjdGlvbk5hbWUsIG9wZXJhdGlvbiwgaXNDdXN0b21JdGVtKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmIChyZXMucmVzdWx0ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXy5leHRlbmQoe30sIEV2ZXJsaXZlRXJyb3JzLnN5bmNDb25mbGljdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFN5bmNlZEl0ZW1Ub1Jlc3VsdChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgc3luY0xvY2F0aW9uLnNlcnZlciwgb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEl0ZW0gPSBfLmV4dGVuZCh7fSwgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgTW9kaWZpZWRBdDogcmVzLk1vZGlmaWVkQXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWRJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5JZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUXVlcnkodXBkYXRlUXVlcnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRTeW5jZWRJdGVtVG9SZXN1bHQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5jbGllbnQsIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFN5bmNlZEl0ZW1Ub1Jlc3VsdChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgc3luY0xvY2F0aW9uLnNlcnZlciwgb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXJnZUJ5SWQoY29sbGVjdGlvbk5hbWUsIGl0ZW0uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRTeW5jZWRJdGVtVG9SZXN1bHQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5jbGllbnQsIG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfcHVyZ2VCeUlkOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGl0ZW1JZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlQcm9jZXNzb3IuX2dldENvbGxlY3Rpb24oY29udGVudFR5cGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbGxlY3Rpb25baXRlbUlkXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3F1ZXJ5UHJvY2Vzc29yLl9wZXJzaXN0RGF0YShjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8gPSBzZWxmLl9zeW5jUmVzdWx0SW5mbyB8fCB7XG4gICAgICAgICAgICAgICAgc3luY2VkSXRlbXM6IHt9LFxuICAgICAgICAgICAgICAgIHN5bmNlZFRvU2VydmVyOiAwLFxuICAgICAgICAgICAgICAgIHN5bmNlZFRvQ2xpZW50OiAwLFxuICAgICAgICAgICAgICAgIGZhaWxlZEl0ZW1zOiB7fSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkIC8vIGFkZGVkIGZvciB2aXNpYmlsaXR5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDYW5ub3Qgc3luY2hyb25pemUgd2hpbGUgb2ZmbGluZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9maXJlU3luY1N0YXJ0KClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseVN5bmMoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzeW5jUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RzV2hpbGVTeW5jID0gW107XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChzeW5jUmVzdWx0cywgZnVuY3Rpb24gKHN5bmNSZXN1bHQsIGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmNSZXN1bHQgJiYgc3luY1Jlc3VsdC5zdGF0ZSA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUeXBlID0gc3luY1Jlc3VsdC5yZWFzb24uY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bmNSZXN1bHQucmVhc29uICYmIHN5bmNSZXN1bHQucmVhc29uLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLnN5bmNDb25mbGljdC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0c1doaWxlU3luYy5wdXNoKHN5bmNSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNhdmUgdGltZSBhbmQgdHJhZmZpYyB3ZSBhcmUgdXNpbmcgYSBzaW5nbGUgY3JlYXRlIHJlcXVlc3QgZm9yIGFsbCBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHdoeSBpZiB0aGVyZSBpcyBhbiBlcnJvciB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBpdGVtcyB3ZSB0cmllZCB0byBjcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNldCB0aGUgc2FtZSBlcnJvciBmb3IgYWxsIGl0ZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHN5bmNSZXN1bHQucmVhc29uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW3RhcmdldFR5cGVdID0gc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbdGFyZ2V0VHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goc3luY1Jlc3VsdC5yZWFzb24uaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZmFpbGVkSXRlbXNbdGFyZ2V0VHlwZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goXy5leHRlbmQoe2l0ZW1JZDogaXRlbS5JZH0sIF8ucGljayhzeW5jUmVzdWx0LnJlYXNvbiwgJ3N0b3JhZ2UnLCAndHlwZScsICdlcnJvcicpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW3RhcmdldFR5cGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goXy5leHRlbmQoe2l0ZW1JZDogaXRlbUlkfSwgXy5waWNrKHN5bmNSZXN1bHQucmVhc29uLCAnc3RvcmFnZScsICd0eXBlJywgJ2Vycm9yJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0c1doaWxlU3luYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9maXJlU3luY0VuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9oYW5kbGVLZWVwU2VydmVyOiBmdW5jdGlvbiAodHlwZU5hbWUsIGNvbmZsaWN0aW5nSXRlbSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW07XG4gICAgICAgICAgICB2YXIgY2xpZW50SXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5jbGllbnRJdGVtO1xuICAgICAgICAgICAgdmFyIHN5bmNRdWVyeTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGl0ZW0gb2ZmbGluZVxuICAgICAgICAgICAgICAgIHN5bmNRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcnZlckl0ZW0uSWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VydmVySXRlbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJJdGVtICYmICFjbGllbnRJdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGl0ZW0gb2ZmbGluZVxuICAgICAgICAgICAgICAgIHN5bmNRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJ2ZXJJdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgaXRlbSBvZmZsaW5lXG4gICAgICAgICAgICAgICAgc3luY1F1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2xpZW50SXRlbS5JZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdCb3RoIHNlcnZlckl0ZW0gYW5kIGNsaWVudEl0ZW0gYXJlIG5vdCBzZXQgd2hlbiBzeW5jaW5nIGRhdGEgd2l0aCBcIktlZXBTZXJ2ZXJcIiByZXNvbHV0aW9uIHN0cmF0ZWd5LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzeW5jUXVlcnkuaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJvY2Vzc1F1ZXJ5KHN5bmNRdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzeW5jUXVlcnkub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFN5bmNlZEl0ZW1Ub1Jlc3VsdChzZXJ2ZXJJdGVtLCB0eXBlTmFtZSwgc3luY0xvY2F0aW9uLmNsaWVudCwgb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkU3luY2VkSXRlbVRvUmVzdWx0KHNlcnZlckl0ZW0sIHR5cGVOYW1lLCBzeW5jTG9jYXRpb24uY2xpZW50LCBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFN5bmNlZEl0ZW1Ub1Jlc3VsdChjbGllbnRJdGVtLCB0eXBlTmFtZSwgc3luY0xvY2F0aW9uLmNsaWVudCwgb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3luY1F1ZXJ5Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQgPSBzZXJ2ZXJJdGVtLklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZCA9IHNlcnZlckl0ZW0uSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQgPSBjbGllbnRJdGVtLklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHN5bmNRdWVyeS5jb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5jbGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hhbmRsZUtlZXBDbGllbnQ6IGZ1bmN0aW9uIChjb25mbGljdGluZ0l0ZW0sIGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW07XG4gICAgICAgICAgICB2YXIgY2xpZW50SXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5jbGllbnRJdGVtO1xuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY2xpZW50SXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZE9iamVjdCA9IF8uZXh0ZW5kKGNsaWVudEl0ZW0sIHtNb2RpZmllZEF0OiBuZXcgRGF0ZShzZXJ2ZXJJdGVtLk1vZGlmaWVkQXQpfSk7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLm1vZGlmaWVkSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBtb2RpZmllZE9iamVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJ2ZXJJdGVtICYmICFjbGllbnRJdGVtKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5kZWxldGVkSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBzZXJ2ZXJJdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmNyZWF0ZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGNsaWVudEl0ZW1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0JvdGggc2VydmVySXRlbSBhbmQgY2xpZW50SXRlbSBhcmUgbm90IHNldCB3aGVuIHN5bmNpbmcgZGF0YSB3aXRoIFwiS2VlcENsaWVudFwiIHJlc29sdXRpb24gc3RyYXRlZ3kuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2hhbmRsZUN1c3RvbTogZnVuY3Rpb24gKGNvbmZsaWN0aW5nSXRlbSwgdHlwZU5hbWUsIG9mZmxpbmVTeW5jT3BlcmF0aW9ucywgY29udGVudFR5cGVTeW5jRGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbTtcbiAgICAgICAgICAgIHZhciBjbGllbnRJdGVtID0gY29uZmxpY3RpbmdJdGVtLmNsaWVudEl0ZW07XG4gICAgICAgICAgICB2YXIgY3VzdG9tSXRlbSA9IF8ub21pdChjb25mbGljdGluZ0l0ZW0ucmVzdWx0Lml0ZW0sICdDcmVhdGVkQXQnLCAnTW9kaWZpZWRBdCcpO1xuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjcmVhdGVJdGVtT2ZmbGluZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcnZlckl0ZW0gLy8gY3JlYXRlIHRoZSBzZXJ2ZXIgaXRlbSBvZmZsaW5lIGFuZCBpdCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiBzeW5jIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtT2ZmbGluZVF1ZXJ5LnByZXNlcnZlU3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkuaXNTeW5jID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKHRoaXMucHJvY2Vzc1F1ZXJ5KGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSAmJiAhY2xpZW50SXRlbSkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUl0ZW0uSWQgPSBzZXJ2ZXJJdGVtLklkO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogY3VzdG9tSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b206IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VydmVySXRlbSAmJiAhY3VzdG9tSXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuZGVsZXRlZEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogc2VydmVySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b206IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSAmJiBjbGllbnRJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUl0ZW1PZmZsaW5lUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHR5cGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3VzdG9tSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjbGllbnRJdGVtLklkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKHRoaXMucHJvY2Vzc1F1ZXJ5KHVwZGF0ZUl0ZW1PZmZsaW5lUXVlcnkpKTtcbiAgICAgICAgICAgICAgICBjdXN0b21JdGVtLklkID0gY2xpZW50SXRlbS5JZDtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuY3JlYXRlZEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBzZXJ2ZXJJdGVtLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBjdXN0b21JdGVtLFxuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXN0b21JdGVtLklkID0gc2VydmVySXRlbS5JZDtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLm1vZGlmaWVkSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGN1c3RvbUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21lcmdlUmVzb2x2ZWRDb25mbGljdHM6IGZ1bmN0aW9uIChjb25mbGljdHMsIHN5bmNEYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBvZmZsaW5lU3luY09wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIF8uZWFjaChjb25mbGljdHMsIGZ1bmN0aW9uIChjb25mbGljdCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IGNvbmZsaWN0LmNvbnRlbnRUeXBlTmFtZTtcbiAgICAgICAgICAgICAgICBfLmVhY2goY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcywgZnVuY3Rpb24gKGNvbmZsaWN0aW5nSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGVTeW5jRGF0YSA9IHN5bmNEYXRhW3R5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25mbGljdGluZ0l0ZW0ucmVzdWx0LnJlc29sdXRpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcFNlcnZlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVLZWVwU2VydmVyKHR5cGVOYW1lLCBjb25mbGljdGluZ0l0ZW0sIG9mZmxpbmVTeW5jT3BlcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcENsaWVudDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVLZWVwQ2xpZW50KGNvbmZsaWN0aW5nSXRlbSwgY29udGVudFR5cGVTeW5jRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uQ3VzdG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKHR5cGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXZlcmxpdmVFcnJvcnMuY3VzdG9tRmlsZVN5bmNOb3RTdXBwb3J0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKGVyci5tZXNzYWdlLCBlcnIuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlQ3VzdG9tKGNvbmZsaWN0aW5nSXRlbSwgdHlwZU5hbWUsIG9mZmxpbmVTeW5jT3BlcmF0aW9ucywgY29udGVudFR5cGVTeW5jRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uU2tpcDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByc3ZwLmFsbChvZmZsaW5lU3luY09wZXJhdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRTeW5jSXRlbVN0YXRlczogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBvZmZsaW5lSXRlbXMsIHNlcnZlckl0ZW1zKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZVN5bmNEYXRhID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zRm9yU3luYzoge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkSXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEl0ZW1zOiBbXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlTmFtZTogY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXM6IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgXy5lYWNoKG9mZmxpbmVJdGVtcywgZnVuY3Rpb24gKG9mZmxpbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBfLmZpbmRXaGVyZShzZXJ2ZXJJdGVtcywge0lkOiBvZmZsaW5lSXRlbS5JZH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtLklkID09PSBvZmZsaW5lSXRlbS5JZCAmJiBvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZV0gPSBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBzZXJ2ZXJJdGVtLklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogRXZlcmxpdmVFcnJvcnMuc3luY0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW1DaGFuZ2VkID0gISFvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVXBkYXRlQ29uZmxpY3QgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50SXRlbUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1VwZGF0ZUNvbmZsaWN0ID0gc2VydmVySXRlbS5Nb2RpZmllZEF0LmdldFRpbWUoKSAhPT0gb2ZmbGluZUl0ZW0uTW9kaWZpZWRBdC5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIG9mZmxpbmUgaXRzIE1vZGlmaWVkQXQgZmllbGQgaXMgbm90IHNldCwgY2hlY2sgaWYgaXQgbmVlZHMgdG8gYmUgc2V0IG9yIHdlIGNhbiB1c2UgdGhpc1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1VwZGF0ZUNvbmZsaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmNvbmZsaWN0cy5jb25mbGljdGluZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpdGVtIHdhcyBtb2RpZmllZCBvbiB0aGUgc2VydmVyIGFuZCBkZWxldGVkIGxvY2FsbHkgd2UgaGF2ZSBhIGNvbmZsaWN0IGFuZCBzZXQgdGhlIGNsaWVudCBpdGVtIHRvIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgYSBzaW1wbGUgbW9kaWZpY2F0aW9uIGNvbmZsaWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SXRlbTogb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCA/IG51bGwgOiBvZmZsaW5lSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJJdGVtOiBzZXJ2ZXJJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLml0ZW1zRm9yU3luYy5kZWxldGVkSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IG9mZmxpbmVJdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuaXRlbXNGb3JTeW5jLm1vZGlmaWVkSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IG9mZmxpbmVJdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBpbiBtZW1vcnkgaGFzIGJlZW4gbW9kaWZpZWQsIGJ1dCB0aGUgaXRlbSBvbiB0aGUgc2VydmVyIGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmNvbmZsaWN0cy5jb25mbGljdGluZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEl0ZW06IG9mZmxpbmVJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckl0ZW06IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLml0ZW1zRm9yU3luYy5jcmVhdGVkSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBvZmZsaW5lSXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY29udGVudFR5cGVTeW5jRGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0UmVzb2x1dGlvblR5cGVGb3JJdGVtOiBmdW5jdGlvbiAocmVzb2x1dGlvblR5cGUsIGNvbmZsaWN0aW5nSXRlbSkge1xuICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtLnJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uVHlwZTogcmVzb2x1dGlvblR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FwcGx5UmVzb2x1dGlvblN0cmF0ZWd5OiBmdW5jdGlvbiAoY29uZmxpY3RzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kgPSBzZWxmLnNldHVwLmNvbmZsaWN0cy5zdHJhdGVneTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RSZXNvbHV0aW9uUHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmxpY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25mbGljdCA9IGNvbmZsaWN0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0LmNvbmZsaWN0aW5nSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuU2VydmVyV2luczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNvbmZsaWN0LmNvbmZsaWN0aW5nSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRSZXNvbHV0aW9uVHlwZUZvckl0ZW0uYmluZChzZWxmLCBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBTZXJ2ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ3VzdG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tU3RyYXRlZ3kgPSBzZWxmLnNldHVwLmNvbmZsaWN0cy5pbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21TdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignSW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbmZsaWN0IHJlc29sdXRpb24gc3RyYXRlZ3kgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbXVzdCBiZSBwcm92aWRlZCB3aGVuIHNldCB0byBDdXN0b20nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdFJlc29sdXRpb25Qcm9taXNlcy5wdXNoKG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVN0cmF0ZWd5KGNvbmZsaWN0cywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKCdJbnZhbGlkIHJlc29sdXRpb24gc3RyYXRlZ3kgcHJvdmlkZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByc3ZwLmFsbChjb25mbGljdFJlc29sdXRpb25Qcm9taXNlcylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRTeW5jUHJvbWlzZUJhdGNoOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGJhdGNoSWRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnSWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRpbic6IGJhdGNoSWRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhcHBseU9mZmxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3RcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeSA9IFJlcXVlc3RPcHRpb25zQnVpbGRlcltkYXRhUXVlcnkub3BlcmF0aW9uXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qoc2VsZi5fZXZlcmxpdmUuc2V0dXAsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXREaXJ0eUl0ZW1zOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UHJvY2Vzc29yLl9nZXREaXJ0eUl0ZW1zKGNvbGxlY3Rpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRTeW5jUHJvbWlzZUZvckNvbGxlY3Rpb246IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgYmF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnN0YW50cy5zeW5jQmF0Y2hTaXplO1xuXG4gICAgICAgICAgICB2YXIgb2ZmbGluZUl0ZW1zVG9TeW5jID0gc2VsZi5fZ2V0RGlydHlJdGVtcyhjb2xsZWN0aW9uKTtcblxuICAgICAgICAgICAgdmFyIGFsbElkc0ZvclN5bmM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBhbGxJZHNGb3JTeW5jID0gXy5wbHVjayhvZmZsaW5lSXRlbXNUb1N5bmMsICdfaWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsSWRzRm9yU3luYyA9IF8ucGx1Y2soXy5yZWplY3Qob2ZmbGluZUl0ZW1zVG9TeW5jLCBmdW5jdGlvbiAob2ZmbGluZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZmxpbmVJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ7XG4gICAgICAgICAgICAgICAgfSksICdfaWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJhdGNoQ291bnQgPSBNYXRoLmNlaWwoYWxsSWRzRm9yU3luYy5sZW5ndGggLyBiYXRjaFNpemUpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiYXRjaFNraXBTaXplID0gaSAqIGJhdGNoU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJZHMgPSBhbGxJZHNGb3JTeW5jLnNsaWNlKGJhdGNoU2tpcFNpemUsIGJhdGNoU2tpcFNpemUgKyBiYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgIHZhciBzeW5jR2V0U2VydmVySXRlbXNQcm9taXNlID0gdGhpcy5fZ2V0U3luY1Byb21pc2VCYXRjaChjb250ZW50VHlwZSwgYmF0Y2hJZHMpO1xuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChzeW5jR2V0U2VydmVySXRlbXNQcm9taXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuYWxsKGJhdGNoZXMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcnZlckl0ZW1zU3luY1Jlc3BvbnNlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVySXRlbXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHNlcnZlckl0ZW1zU3luY1Jlc3BvbnNlcywgZnVuY3Rpb24gKHNlcnZlckl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2VydmVySXRlbXMgPSBfLnVuaW9uKHJlc3VsdC5zZXJ2ZXJJdGVtcywgc2VydmVySXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQub2ZmbGluZUl0ZW1zVG9TeW5jID0gb2ZmbGluZUl0ZW1zVG9TeW5jO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hZGRTeW5jZWRJdGVtVG9SZXN1bHQ6IGZ1bmN0aW9uIChpdGVtLCBjb250ZW50VHlwZSwgc3luY1N0b3JhZ2UsIHN5bmNUeXBlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3luY0luZm8gPSB7XG4gICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHN5bmNUeXBlLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNTdG9yYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXNbY29udGVudFR5cGVdLnB1c2goc3luY0luZm8pO1xuXG4gICAgICAgICAgICB0aGlzLl9ldmVybGl2ZS5fZW1pdHRlci5lbWl0KCdpdGVtU3luY2VkJywgc3luY0luZm8pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRDbGllbnRXaW5zU3luY0RhdGE6IGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN5bmNEYXRhID0ge307XG4gICAgICAgICAgICBfLmVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCB0eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3luY0RhdGFbdHlwZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW3R5cGVOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRJdGVtczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlydHlJdGVtcyA9IHNlbGYuX2dldERpcnR5SXRlbXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zRm9yU3luYyA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0oZGlydHlJdGVtcyk7XG5cbiAgICAgICAgICAgICAgICBfLmVhY2goaXRlbXNGb3JTeW5jLCBmdW5jdGlvbiAoaXRlbUZvclN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpdGVtRm9yU3luY1tjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY0RhdGFbdHlwZU5hbWVdLmNyZWF0ZWRJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogaXRlbUZvclN5bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGl0ZW1Gb3JTeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW3R5cGVOYW1lXS5tb2RpZmllZEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBpdGVtRm9yU3luYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogaXRlbUZvclN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRGF0YVt0eXBlTmFtZV0uZGVsZXRlZEl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBpdGVtRm9yU3luYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogaXRlbUZvclN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtRm9yU3luY1tjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzeW5jRGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0TW9kaWZpZWRGaWxlc0ZvclN5bmNDbGllbnRXaW5zOiBmdW5jdGlvbiAoaXRlbUlkLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNkayA9IHNlbGYuX2V2ZXJsaXZlO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZmxpbmVGaWxlcyA9IHNlbGYuZmlsZXM7XG4gICAgICAgICAgICAgICAgb2ZmbGluZUZpbGVzLmdldE9mZmxpbmVMb2NhdGlvbihpdGVtSWQpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3RyYW5zZmVyRmlsZSh0cnVlLCBpdGVtLCBsb2NhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5SZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2RrLmZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZVNpbmdsZShpdGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLnNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob25saW5lUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbmxpbmVSZXN1bHQgPSBvbmxpbmVSZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLk1vZGlmaWVkQXQgPSBvbmxpbmVSZXN1bHQuTW9kaWZpZWRBdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFN5bmNlZEl0ZW1Ub1Jlc3VsdChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgc3luY0xvY2F0aW9uLnNlcnZlciwgb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNkay5maWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVTaW5nbGUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0TW9kaWZpZWRJdGVtRm9yU3luY0NsaWVudFdpbnM6IGZ1bmN0aW9uIChkYXRhQ29sbGVjdGlvbiwgaXRlbSwgY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVTaW5nbGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkU3luY2VkSXRlbVRvUmVzdWx0KGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBzeW5jTG9jYXRpb24uc2VydmVyLCBvZmZsaW5lSXRlbVN0YXRlcy5tb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEl0ZW0gPSBfLmV4dGVuZCh7fSwgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGlmaWVkQXQ6IHJlcy5Nb2RpZmllZEF0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdXBkYXRlZEl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzUXVlcnkodXBkYXRlUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcmVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZE1vZGlmaWVkSXRlbXNGb3JTeW5jQ2xpZW50V2luczogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRVcGRhdGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdCwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbS5JZDtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignV2hlbiB1cGRhdGluZyBhbiBpdGVtIGl0IG11c3QgaGF2ZSBhbiBJZCBmaWVsZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNDb250ZW50VHlwZS5maWxlcyhjb2xsZWN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW1JZF0gPSBzZWxmLl9nZXRNb2RpZmllZEZpbGVzRm9yU3luY0NsaWVudFdpbnMoaXRlbUlkLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW1JZF0gPSBzZWxmLl9nZXRNb2RpZmllZEl0ZW1Gb3JTeW5jQ2xpZW50V2lucyhkYXRhQ29sbGVjdGlvbiwgaXRlbSwgY29sbGVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hZGREZWxldGVkSXRlbXNGb3JTeW5jQ2xpZW50V2luczogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGREZWxldGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdCwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW0uSWRdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbS5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1doZW4gZGVsZXRpbmcgYW4gaXRlbSBpdCBtdXN0IGhhdmUgYW4gSWQgZmllbGQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZXN0cm95U2luZ2xlKGl0ZW1GaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRTeW5jZWRJdGVtVG9SZXN1bHQoaXRlbSwgY29sbGVjdGlvbk5hbWUsIHN5bmNMb2NhdGlvbi5zZXJ2ZXIsIG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVyZ2VCeUlkKGNvbGxlY3Rpb25OYW1lLCBpdGVtLklkKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF8uZXh0ZW5kKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY0xvY2F0aW9uLmNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF8uZXh0ZW5kKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hcHBseUNsaWVudFdpbnM6IGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN5bmNEYXRhID0gdGhpcy5fZ2V0Q2xpZW50V2luc1N5bmNEYXRhKGNvbGxlY3Rpb25zKTtcbiAgICAgICAgICAgIHZhciBzeW5jUHJvbWlzZXMgPSB7fTtcblxuICAgICAgICAgICAgXy5lYWNoKHN5bmNEYXRhLCBmdW5jdGlvbiAoY29udGVudFR5cGVEYXRhLCB0eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhQ29sbGVjdGlvbiA9IHNlbGYuX2V2ZXJsaXZlLmRhdGEodHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuY3JlYXRlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRDcmVhdGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5tb2RpZmllZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRNb2RpZmllZEl0ZW1zRm9yU3luY0NsaWVudFdpbnMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLmRlbGV0ZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luY0NsaWVudFdpbnMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaFNldHRsZWQoc3luY1Byb21pc2VzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYXBwbHlTdGFuZGFyZFN5bmM6IGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChjb2xsZWN0aW9ucywgZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbY29udGVudFR5cGVdID0gc2VsZi5fZ2V0U3luY1Byb21pc2VGb3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5oYXNoKHByb21pc2VzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50VHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3ByZXBhcmVTeW5jRGF0YShjb250ZW50VHlwZXMpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN5bmNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZXNvbHZlQ29uZmxpY3RzKHN5bmNEYXRhKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50VHlwZVN5bmNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW5jUHJvbWlzZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlU3luY0RhdGEsIGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIGNvbGxlY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUNvbGxlY3Rpb24gPSBzZWxmLl9ldmVybGl2ZS5kYXRhKGNvbGxlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuY3JlYXRlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZENyZWF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5tb2RpZmllZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFVwZGF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBnZXRTeW5jRmlsdGVyRm9ySXRlbSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGl0ZW1GaWx0ZXIsIGlzQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtLklkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc0NvbnRlbnRUeXBlLmZpbGVzKGNvbGxlY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVzQ29sbGVjdGlvbiA9IHNlbGYuX2V2ZXJsaXZlLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW1JZF0gPSBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmbGluZUxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlsZXMuZ2V0T2ZmbGluZUxvY2F0aW9uKGl0ZW1JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGxvY2F0aW9uT25EaXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lTG9jYXRpb24gPSBsb2NhdGlvbk9uRGlzaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVzQ29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRCeUlkKGl0ZW1JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5Nb2RpZmllZEF0LmdldFRpbWUoKSAhPT0gaXRlbS5Nb2RpZmllZEF0LmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChfLmV4dGVuZCh7fSwgRXZlcmxpdmVFcnJvcnMuc3luY0NvbmZsaWN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmxpbmVMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fdHJhbnNmZXJGaWxlKHRydWUsIGl0ZW0sIG9mZmxpbmVMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVzQ29sbGVjdGlvbi5pc1N5bmModHJ1ZSkudXBkYXRlU2luZ2xlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtSWRdID0gZGF0YUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlKGl0ZW0sIGl0ZW1GaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb25TeW5jUmVzcG9uc2UocmVzLCBpdGVtLCBjb2xsZWN0aW9uTmFtZSwgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLCBpc0N1c3RvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiBzeW5jTG9jYXRpb24uc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5kZWxldGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJGb3JJdGVtLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlciwgaXNDdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW0uSWRdID0gZGF0YUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGVzdHJveShpdGVtRmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9vblN5bmNSZXNwb25zZShyZXMsIGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUsIGlzQ3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBpdGVtLklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IHN5bmNMb2NhdGlvbi5zZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaFNldHRsZWQoc3luY1Byb21pc2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYXBwbHlTeW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyeVByb2Nlc3Nvci5fZ2V0QWxsQ29sbGVjdGlvbnMoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZXR1cC5jb25mbGljdHMuc3RyYXRlZ3kgPT09IGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DbGllbnRXaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fYXBwbHlDbGllbnRXaW5zKGNvbGxlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseVN0YW5kYXJkU3luYyhjb2xsZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFsbCB0aGUgb2ZmbGluZSBpdGVtcyB0aGF0IGhhdmUgbm90IGJlZW4gc3luY2VkIG9ubGluZS5cbiAgICAgICAgICogQG1ldGhvZCBnZXRJdGVtc0ZvclN5bmNcbiAgICAgICAgICogQG5hbWUgZ2V0SXRlbXNGb3JTeW5jXG4gICAgICAgICAqIEBtZW1iZXJPZiBPZmZsaW5lTW9kdWxlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgdGhlIG9mZmxpbmUgaXRlbXMgdGhhdCBoYXZlIG5vdCBiZWVuIHN5bmNlZCBvbmxpbmUuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SXRlbXNGb3JTeW5jXG4gICAgICAgICAqIEBuYW1lIGdldEl0ZW1zRm9yU3luY1xuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SXRlbXNGb3JTeW5jOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkaXJ0eUl0ZW1zRm9yU3luYyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcXVlcnlQcm9jZXNzb3IuX2dldEFsbENvbGxlY3Rpb25zKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb2xsZWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJ0eUl0ZW1zID0gc2VsZi5fZ2V0RGlydHlJdGVtcyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJ0eUl0ZW1zRm9yU3luY1tjb2xsZWN0aW9uTmFtZV0gPSBfLm1hcChkaXJ0eUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUZvclN5bmMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBfLmV4dGVuZCh7fSwgaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtRm9yU3luYy5pdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtRm9yU3luYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2IoZGlydHlJdGVtc0ZvclN5bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvckNiKTtcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gT2ZmbGluZU1vZHVsZTtcbn0pKCk7XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG52YXIgcGVyc2lzdGVyc01vZHVsZSA9IHJlcXVpcmUoJy4vb2ZmbGluZVBlcnNpc3RlcnMnKTtcbnZhciBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIgPSBwZXJzaXN0ZXJzTW9kdWxlLkxvY2FsU3RvcmFnZVBlcnNpc3RlcjtcbnZhciBGaWxlU3lzdGVtUGVyc2lzdGVyID0gcGVyc2lzdGVyc01vZHVsZS5GaWxlU3lzdGVtUGVyc2lzdGVyO1xudmFyIE9mZmxpbmVTdG9yYWdlTW9kdWxlID0gcmVxdWlyZSgnLi9PZmZsaW5lU3RvcmFnZU1vZHVsZScpO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBpc05hdGl2ZVNjcmlwdCA9IHJlcXVpcmUoJy4uL2V2ZXJsaXZlLnBsYXRmb3JtJykuaXNOYXRpdmVTY3JpcHQ7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciBDcnlwdG9ncmFwaGljUHJvdmlkZXIgPSByZXF1aXJlKCcuLi9lbmNyeXB0aW9uL0NyeXB0b2dyYXBoaWNQcm92aWRlcicpO1xuXG52YXIgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyA9IHtcbiAgICBhdXRvU3luYzogdHJ1ZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGNvbmZsaWN0czoge1xuICAgICAgICBzdHJhdGVneTogY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnMsXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBudWxsXG4gICAgfSxcbiAgICBvZmZsaW5lOiBmYWxzZSxcbiAgICBzdG9yYWdlOiB7XG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICBwcm92aWRlcjogaXNOYXRpdmVTY3JpcHQgPyBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkZpbGVTeXN0ZW0gOiBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkxvY2FsU3RvcmFnZSxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IG51bGwsXG4gICAgICAgIHN0b3JhZ2VQYXRoOiBjb25zdGFudHMuRGVmYXVsdFN0b3JhZ2VQYXRoXG4gICAgfSxcbiAgICB0eXBlU2V0dGluZ3M6IHt9LFxuICAgIGVuY3J5cHRpb246IHtcbiAgICAgICAgcHJvdmlkZXI6IGNvbnN0YW50cy5FbmNyeXB0aW9uUHJvdmlkZXIuRGVmYXVsdCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IG51bGwsXG4gICAgICAgIGtleTogJydcbiAgICB9LFxuICAgIGZpbGVzOiB7XG4gICAgICAgIHN0b3JhZ2VQYXRoOiBjb25zdGFudHMuRGVmYXVsdEZpbGVzU3RvcmFnZVBhdGgsXG4gICAgICAgIG1ldGFQYXRoOiBjb25zdGFudHMuRGVmYXVsdEZpbGVzTWV0YWRhdGFQYXRoXG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWdpZXMgPSB7fTtcblxuICAgIGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWdpZXNbY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnNdID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGxvY2FsLCBzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUobG9jYWwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ2llc1tjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuU2VydmVyV2luc10gPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgbG9jYWwsIHNlcnZlcikge1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShzZXJ2ZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGluaXRTdG9yYWdlUGVyc2lzdGVyID0gZnVuY3Rpb24gaW5pdFN0b3JhZ2VQZXJzaXN0ZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgcGVyc2lzdGVyO1xuICAgICAgICB2YXIgc3RvcmFnZVByb3ZpZGVyID0gb3B0aW9ucy5zdG9yYWdlLnByb3ZpZGVyO1xuICAgICAgICB2YXIgc3RvcmFnZVByb3ZpZGVySW1wbGVtZW50YXRpb24gPSBvcHRpb25zLnN0b3JhZ2UuaW1wbGVtZW50YXRpb247XG4gICAgICAgIHZhciBzdG9yYWdlS2V5ID0gb3B0aW9ucy5zdG9yYWdlLm5hbWUgfHwgJ2V2ZXJsaXZlT2ZmbGluZVN0b3JhZ2VfJyArIHRoaXMuc2V0dXAuYXBpS2V5O1xuICAgICAgICBpZiAoXy5pc09iamVjdChzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbikgJiYgc3RvcmFnZVByb3ZpZGVyID09PSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkN1c3RvbSkge1xuICAgICAgICAgICAgcGVyc2lzdGVyID0gc3RvcmFnZVByb3ZpZGVySW1wbGVtZW50YXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0b3JhZ2VQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5Mb2NhbFN0b3JhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlciA9IG5ldyBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIoc3RvcmFnZUtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5GaWxlU3lzdGVtOlxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZXIgPSBuZXcgRmlsZVN5c3RlbVBlcnNpc3RlcihzdG9yYWdlS2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkN1c3RvbTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0N1c3RvbSBzdG9yYWdlIHByb3ZpZGVyIHJlcXVpcmVzIGFuIGltcGxlbWVudGF0aW9uIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbnN1cHBvcnRlZCBzdG9yYWdlIHR5cGUgJyArIHN0b3JhZ2VQcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnN0b3JhZ2UuaW1wbGVtZW50YXRpb24gPSBwZXJzaXN0ZXI7XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZXI7XG4gICAgfTtcblxuICAgIHZhciBpbml0RW5jcnlwdGlvblByb3ZpZGVyID0gZnVuY3Rpb24gaW5pdEVuY3J5cHRpb25Qcm92aWRlcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBlbmNyeXB0b3I7XG4gICAgICAgIHZhciBlbmNyeXB0aW9uUHJvdmlkZXIgPSBvcHRpb25zLmVuY3J5cHRpb24ucHJvdmlkZXI7XG4gICAgICAgIHZhciBlbmNyeXB0aW9uSW1wbGVtZW50YXRpb24gPSBvcHRpb25zLmVuY3J5cHRpb24uaW1wbGVtZW50YXRpb247XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KGVuY3J5cHRpb25JbXBsZW1lbnRhdGlvbikgJiYgZW5jcnlwdGlvblByb3ZpZGVyID09PSBjb25zdGFudHMuRW5jcnlwdGlvblByb3ZpZGVyLkN1c3RvbSkge1xuICAgICAgICAgICAgZW5jcnlwdG9yID0gZW5jcnlwdGlvbkltcGxlbWVudGF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChlbmNyeXB0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5FbmNyeXB0aW9uUHJvdmlkZXIuRGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdG9yID0gbmV3IENyeXB0b2dyYXBoaWNQcm92aWRlcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuRW5jcnlwdGlvblByb3ZpZGVyLkN1c3RvbTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0N1c3RvbSBlbmNyeXB0aW9uIHByb3ZpZGVyIHJlcXVpcmVzIGFuIGltcGxlbWVudGF0aW9uIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHByb3ZpZGVyICcgKyBlbmNyeXB0aW9uUHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5lbmNyeXB0aW9uLmltcGxlbWVudGF0aW9uID0gZW5jcnlwdG9yO1xuICAgICAgICByZXR1cm4gZW5jcnlwdG9yO1xuICAgIH07XG5cbiAgICB2YXIgYnVpbGRPZmZsaW5lU3RvcmFnZU1vZHVsZSA9IGZ1bmN0aW9uIGJ1aWxkT2ZmbGluZVN0b3JhZ2VNb2R1bGUoc3RvcmFnZU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmIChzdG9yYWdlT3B0aW9ucyA9PT0gdHJ1ZSkgeyAvLyBleHBsaWNpdCBjaGVjayBmb3Igc2hvcnRoYW5kIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChzdG9yYWdlT3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHN0b3JhZ2VPcHRpb25zLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IF8uZGVmYXVsdHMoc3RvcmFnZU9wdGlvbnMuc3RvcmFnZSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucy5zdG9yYWdlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jcnlwdGlvbiA9IF8uZGVmYXVsdHMoc3RvcmFnZU9wdGlvbnMuZW5jcnlwdGlvbiwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucy5lbmNyeXB0aW9uKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZmxpY3RzID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucy5jb25mbGljdHMsIGRlZmF1bHRPZmZsaW5lU3RvcmFnZU9wdGlvbnMuY29uZmxpY3RzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlciA9IGluaXRTdG9yYWdlUGVyc2lzdGVyLmNhbGwodGhpcywgb3B0aW9ucywgc3RvcmFnZU9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGVuY3J5cHRpb25Qcm92aWRlciA9IGluaXRFbmNyeXB0aW9uUHJvdmlkZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVN0b3JhZ2VNb2R1bGUodGhpcywgb3B0aW9ucywgcGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIpO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdE9mZmxpbmVTdG9yYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vZmZsaW5lU3RvcmFnZSA9IGJ1aWxkT2ZmbGluZVN0b3JhZ2VNb2R1bGUuY2FsbCh0aGlzLCBvcHRpb25zLm9mZmxpbmVTdG9yYWdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdE9mZmxpbmVTdG9yYWdlOiBpbml0T2ZmbGluZVN0b3JhZ2VcbiAgICB9XG59KCkpOyIsInZhciBCYXNlUGVyc2lzdGVyID0gcmVxdWlyZSgnLi9wZXJzaXN0ZXJzL0Jhc2VQZXJzaXN0ZXInKTtcbnZhciBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIgPSByZXF1aXJlKCcuL3BlcnNpc3RlcnMvTG9jYWxTdG9yYWdlUGVyc2lzdGVyJyk7XG52YXIgRmlsZVN5c3RlbVBlcnNpc3RlciA9IHJlcXVpcmUoJy4vcGVyc2lzdGVycy9GaWxlU3lzdGVtUGVyc2lzdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJhc2VQZXJzaXN0ZXI6IEJhc2VQZXJzaXN0ZXIsXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyOiBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIsXG4gICAgRmlsZVN5c3RlbVBlcnNpc3RlcjogRmlsZVN5c3RlbVBlcnNpc3RlclxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcbnZhciBvZmZsaW5lSXRlbVN0YXRlTWFya2VyID0gY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyO1xuXG52YXIgdHJhdmVyc2VBbmRBcHBseSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3BlcmF0aW9uLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBfLm1hcCh2YWx1ZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24oaXRlbSwgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uKHZhbHVlLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgfVxufTtcblxudmFyIGlkVHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5faWQgJiYgIXZhbHVlLklkKSB7XG4gICAgICAgIHZhbHVlLklkID0gdmFsdWUuX2lkO1xuICAgICAgICBkZWxldGUgdmFsdWUuX2lkO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciByZW1vdmVJZFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0cykge1xuICAgIHZhciB2ZXJpZnlTdGF0ZUNyZWF0ZWQgPSBvcHRzLnZlcmlmeVN0YXRlQ3JlYXRlZDtcbiAgICB2YXIgc2hvdWxkTW9kaWZ5T2JqZWN0ID0gdmVyaWZ5U3RhdGVDcmVhdGVkID8gdmFsdWVbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gY29uc3RhbnRzLm9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQgOiB0cnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICh2YWx1ZS5faWQgfHwgdmFsdWUuSWQpICYmIHNob3VsZE1vZGlmeU9iamVjdCkge1xuICAgICAgICBkZWxldGUgdmFsdWUuX2lkO1xuICAgICAgICBkZWxldGUgdmFsdWUuSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIHJlbW92ZU1hcmtlclRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRlbGV0ZSB2YWx1ZVtvZmZsaW5lSXRlbVN0YXRlTWFya2VyXTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucyA9IHtcbiAgICByZW1vdmVJZFRyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlLCB2ZXJpZnlTdGF0ZUNyZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlQW5kQXBwbHkodmFsdWUsIHJlbW92ZUlkVHJhbnNmb3JtLCB7dmVyaWZ5U3RhdGVDcmVhdGVkOiB2ZXJpZnlTdGF0ZUNyZWF0ZWR9KTtcbiAgICB9LFxuICAgIGlkVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlQW5kQXBwbHkodmFsdWUsIGlkVHJhbnNmb3JtYXRpb24pO1xuICAgIH0sXG4gICAgc2luZ2xlRmllbGRUcmFuc2Zvcm06IGZ1bmN0aW9uIChzaW5nbGVGaWVsZEV4cHJlc3Npb24sIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtzaW5nbGVGaWVsZEV4cHJlc3Npb25dO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkOiBmdW5jdGlvbiAoZmlsdGVyT2JqKSB7XG4gICAgICAgIGlmIChmaWx0ZXJPYmogJiYgZmlsdGVyT2JqLklkKSB7XG4gICAgICAgICAgICBmaWx0ZXJPYmouX2lkID0gZmlsdGVyT2JqLklkO1xuICAgICAgICAgICAgZGVsZXRlIGZpbHRlck9iai5JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmlsdGVyT2JqKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdE1lbWJlciA9IGZpbHRlck9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdE1lbWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy50cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkKG9iamVjdE1lbWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVNYXJrZXJzVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlQW5kQXBwbHkodmFsdWUsIHJlbW92ZU1hcmtlclRyYW5zZm9ybSk7XG4gICAgfSxcbiAgICByZW1vdmVGaWVsZHNUcmFuc2Zvcm06IGZ1bmN0aW9uICh2YWx1ZSwgZmllbGRzKSB7XG4gICAgICAgIF8uZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2ZpZWxkXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9uczsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xudmFyIF8gPSBjb21tb24uXztcbnZhciByc3ZwID0gY29tbW9uLnJzdnA7XG5cbnZhciBCYXNlUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBCYXNlUGVyc2lzdGVyXG4gICAgICogQGNsYXNzZGVzYyBBbiBhYnN0cmFjdGlvbiBsYXllciBmb3IgYWxsIHBlcnNpc3RlcnMuIEV2ZXJ5IHBlcnNpc3RlciBjYW4gd3JpdGUvcmVhZFxuICAgICAqIGRhdGEgdG8vZnJvbSBhIHNwZWNpZmljIHBsYWNlLiBUaGUgZGF0YSBpcyBzYXZlZCBhcyBrZXktdmFsdWUgcGFpcnMgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAgICogY29udGVudCB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlUGVyc2lzdGVyKGtleSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZXNTdG9yZUtleSA9IHRoaXMua2V5ICsgJ0BDb250ZW50VHlwZXMnO1xuICAgIH1cblxuICAgIEJhc2VQZXJzaXN0ZXIucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhbGwgdGhlIHNhdmVkIGRhdGEuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QWxsRGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBrZXlzIGFyZSB0aGUgY29udGVudCB0eXBlcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSBpdGVtcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldEFsbERhdGE6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0ge307XG4gICAgICAgICAgICB0aGlzLl9nZXRDb250ZW50VHlwZXMoZnVuY3Rpb24gKGNvbnRlbnRUeXBlcykge1xuICAgICAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZXMsIGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tjb250ZW50VHlwZV0gPSBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0RGF0YShjb250ZW50VHlwZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByc3ZwLmhhc2gocHJvbWlzZXMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICB9LCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNhdmVkIGRhdGEgZm9yIGEgc3BlY2lmaWMgY29udGVudCB0eXBlLlxuICAgICAgICAgKiBAbWV0aG9kIGdldERhdGFcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXRyaWV2ZWQgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgbWV0aG9kIGdldERhdGEgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmVzIGRhdGEgZm9yIGEgc3BlY2lmaWMgY29udGVudCB0eXBlLlxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVEYXRhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50VHlwZSBUaGUgY29udGVudCBmb3Igd2hpY2ggdG8gc2F2ZSB0aGUgZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxuICAgICAgICAgKi9cbiAgICAgICAgc2F2ZURhdGE6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgbWV0aG9kIHNhdmVEYXRhIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZS5cbiAgICAgICAgICogQG1ldGhvZCBwdXJnZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcbiAgICAgICAgICovXG4gICAgICAgIHB1cmdlOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBjbGVhciBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBwZXJzaXN0ZWQgZGF0YSBpbiB0aGUgb2ZmbGluZSBzdG9yZS5cbiAgICAgICAgICogQG1ldGhvZCBwdXJnZUFsbFxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBwdXJnZUFsbDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBjbGVhckFsbCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0S2V5OiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleSArICdfJyArIGNvbnRlbnRUeXBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRDb250ZW50VHlwZXM6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBtZXRob2QgX2dldENvbnRlbnRUeXBlcyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQmFzZVBlcnNpc3Rlcjtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVBlcnNpc3RlcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBGaWxlU3RvcmUgPSByZXF1aXJlKCcuLi8uLi9zdG9yYWdlcy9GaWxlU3RvcmUnKTtcbnZhciBCYXNlUGVyc2lzdGVyID0gcmVxdWlyZSgnLi9CYXNlUGVyc2lzdGVyJyk7XG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xudmFyIF8gPSBjb21tb24uXztcbnZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4uLy4uL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbnZhciBGaWxlU3lzdGVtUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRmlsZVN5c3RlbVBlcnNpc3RlclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZXh0ZW5kcyBCYXNlUGVyc2lzdGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gRmlsZVN5c3RlbVBlcnNpc3RlcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgQmFzZVBlcnNpc3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZpbGVTdG9yZSA9IG5ldyBGaWxlU3RvcmUob3B0aW9ucy5zdG9yYWdlLnN0b3JhZ2VQYXRoLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB1dGlsLmluaGVyaXRzKEZpbGVTeXN0ZW1QZXJzaXN0ZXIsIEJhc2VQZXJzaXN0ZXIpO1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuZ2V0QWxsRGF0YSA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5fZmlsZVN5c3RlbUVycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIuc3VwZXJfLnByb3RvdHlwZS5nZXRBbGxEYXRhLmNhbGwodGhpcywgc3VjY2VzcywgZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5fZmlsZVN5c3RlbUVycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUhhbmRsZShjb250ZW50VHlwZSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgc2VsZi5fcmVhZEZpbGVDb250ZW50KGZpbGVFbnRyeSwgc3VjY2VzcywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSwgZXJyb3IpO1xuICAgIH07XG5cbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5zYXZlRGF0YSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5fZmlsZVN5c3RlbUVycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUhhbmRsZShjb250ZW50VHlwZSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgc2VsZi5fd3JpdGVGaWxlQ29udGVudChmaWxlRW50cnksIGRhdGEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9zYXZlQ29udGVudFR5cGVzKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUucHVyZ2UgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICB0aGlzLmdldEZpbGVIYW5kbGUoY29udGVudFR5cGUsIGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcbiAgICAgICAgICAgIHNlbGYuZmlsZVN0b3JlLnJlbW92ZUZpbGUoZmlsZUVudHJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvcik7XG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XG4gICAgfTtcblxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLnB1cmdlQWxsID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSB0aGlzLl9maWxlU3lzdGVtRXJyb3JIYW5kbGVyKGVycm9yKTtcbiAgICAgICAgdGhpcy5maWxlU3RvcmUucmVtb3ZlRmlsZXNEaXJlY3RvcnkoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlcyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB0aGlzLmdldERhdGEodGhpcy5jb250ZW50VHlwZXNTdG9yZUtleSwgZnVuY3Rpb24gKHNhdmVkQ29udGVudFR5cGVzUmF3KSB7XG4gICAgICAgICAgICB2YXIgc2F2ZWRDb250ZW50VHlwZXMgPSBKU09OLnBhcnNlKHNhdmVkQ29udGVudFR5cGVzUmF3IHx8ICdbXScpO1xuICAgICAgICAgICAgc3VjY2VzcyhzYXZlZENvbnRlbnRUeXBlcyk7XG4gICAgICAgIH0sIGVycm9yKTtcbiAgICB9O1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3NhdmVDb250ZW50VHlwZXMgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fZ2V0Q29udGVudFR5cGVzKGZ1bmN0aW9uIChzYXZlZENvbnRlbnRUeXBlcykge1xuICAgICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNhdmVkQ29udGVudFR5cGVzLCBjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzYXZlZENvbnRlbnRUeXBlcy5wdXNoKGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5nZXRGaWxlSGFuZGxlKHNlbGYuY29udGVudFR5cGVzU3RvcmVLZXksIGZ1bmN0aW9uIChjb250ZW50VHlwZXNGaWxlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fd3JpdGVGaWxlQ29udGVudChjb250ZW50VHlwZXNGaWxlLCBKU09OLnN0cmluZ2lmeShzYXZlZENvbnRlbnRUeXBlcyksIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgICAgIH0sIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLmdldEZpbGVIYW5kbGUgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBhdGggPSBzZWxmLl9nZXRGaWxlUGF0aChjb250ZW50VHlwZSk7XG4gICAgICAgIHRoaXMuZmlsZVN0b3JlLmdldEZpbGVzRGlyZWN0b3J5KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5maWxlU3RvcmUuZ2V0RmlsZShwYXRoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZmlsZUhhbmRsZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICB9O1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3JlYWRGaWxlQ29udGVudCA9IGZ1bmN0aW9uIChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuZmlsZVN0b3JlLnJlYWRGaWxlQXNUZXh0KGZpbGVFbnRyeSkudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgc3VjY2Vzcyhjb250ZW50KTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IpO1xuICAgIH07XG5cbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fd3JpdGVGaWxlQ29udGVudCA9IGZ1bmN0aW9uIChmaWxlRW50cnksIGNvbnRlbnQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuZmlsZVN0b3JlLndyaXRlVGV4dFRvRmlsZShmaWxlRW50cnksIGNvbnRlbnQpXG4gICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICB9O1xuXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEZpbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xuICAgICAgICAvL3JldHVybiB1dGlscy5qb2luUGF0aCh0aGlzLmZpbGVTdG9yZS5maWxlc0RpcmVjdG9yeVBhdGgsIHRoaXMuX2dldEtleShjb250ZW50VHlwZSkpO1xuICAgIH07XG5cbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fZmlsZVN5c3RlbUVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlU3RvcmUuZ2V0RXJyb3JIYW5kbGVyKGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbGVTeXN0ZW1QZXJzaXN0ZXI7XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGVTeXN0ZW1QZXJzaXN0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uJyk7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIExvY2FsU3RvcmUgPSByZXF1aXJlKCcuLi8uLi9zdG9yYWdlcy9Mb2NhbFN0b3JlJyk7XG52YXIgQmFzZVBlcnNpc3RlciA9IHJlcXVpcmUoJy4vQmFzZVBlcnNpc3RlcicpO1xuXG52YXIgTG9jYWxTdG9yYWdlUGVyc2lzdGVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXJcbiAgICAgKiBAZXh0ZW5kcyBCYXNlUGVyc2lzdGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9jYWxTdG9yYWdlUGVyc2lzdGVyKGtleSwgb3B0aW9ucykge1xuICAgICAgICBCYXNlUGVyc2lzdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RvcmUgPSBuZXcgTG9jYWxTdG9yZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICB1dGlsLmluaGVyaXRzKExvY2FsU3RvcmFnZVBlcnNpc3RlciwgQmFzZVBlcnNpc3Rlcik7XG5cbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fZ2V0S2V5KGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIHZhciBzdG9yZWRJdGVtID0gdGhpcy5fZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgc3VjY2VzcyhzdG9yZWRJdGVtKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5zYXZlRGF0YSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUtleSA9IHRoaXMuX2dldEtleShjb250ZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRJdGVtKGNvbnRlbnRUeXBlS2V5LCBkYXRhKTtcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgc3VjY2VzcygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLnB1cmdlQWxsID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX2dldENvbnRlbnRUeXBlcyhmdW5jdGlvbiAoY29udGVudFR5cGVzKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlcywgZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUtleSA9IHNlbGYuX2dldEtleShjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW0oY29udGVudFR5cGVLZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlSXRlbShzZWxmLmNvbnRlbnRUeXBlc1N0b3JlS2V5KTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XG4gICAgICAgICAgICB9LCBlcnJvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JlLmdldEl0ZW0oa2V5KTtcbiAgICB9O1xuXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9O1xuXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fZ2V0S2V5ID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuX2FkZFR5cGVUb0NvbGxlY3Rpb25zQ2FjaGUoY29udGVudFR5cGUpO1xuICAgICAgICByZXR1cm4gTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnN1cGVyXy5wcm90b3R5cGUuX2dldEtleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZXMgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JhZ2VTdHJpbmcgPSB0aGlzLl9nZXRJdGVtKHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXkpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN0cmluZykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX3NldENvbnRlbnRUeXBlc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLl9zZXRJdGVtKHRoaXMuY29udGVudFR5cGVzU3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KGNvbGxlY3Rpb24pKTtcbiAgICB9O1xuXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fYWRkVHlwZVRvQ29sbGVjdGlvbnNDYWNoZSA9IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2dldENvbnRlbnRUeXBlcyhmdW5jdGlvbiAoY29udGVudFR5cGVzKSB7XG4gICAgICAgICAgICBpZiAoIV8uY29udGFpbnMoY29udGVudFR5cGVzLCB0eXBlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZXMucHVzaCh0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2V0Q29udGVudFR5cGVzQ29sbGVjdGlvbihjb250ZW50VHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExvY2FsU3RvcmFnZVBlcnNpc3Rlcjtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxTdG9yYWdlUGVyc2lzdGVyOyIsInZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IFtvZmZsaW5lXSBVcGRhdGUgdGhlIHN0cnVjdHVyZSAtIGZpbHRlciBmaWVsZCBjYW4gYmUgcmVmYWN0b3JlZCBmb3IgZXhhbXBsZSBhbmQgYSBza2lwL2xpbWl0L3NvcnQgcHJvcGVydHkgY2FuIGJlIGFkZGVkXG4gICAgdmFyIERhdGFRdWVyeSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbmZpZy5jb2xsZWN0aW9uTmFtZTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgIHRoaXMuZmlsdGVyID0gY29uZmlnLmZpbHRlcjtcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSBjb25maWcub25TdWNjZXNzO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBjb25maWcub25FcnJvcjtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBjb25maWcub3BlcmF0aW9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gY29uZmlnLnBhcnNlO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxPcHRpb25zID0gY29uZmlnLmFkZGl0aW9uYWxPcHRpb25zO1xuICAgICAgICB0aGlzLmRhdGEgPSBjb25maWcuZGF0YTtcbiAgICAgICAgdGhpcy51c2VPZmZsaW5lID0gY29uZmlnLnVzZU9mZmxpbmU7XG4gICAgICAgIHRoaXMuYXBwbHlPZmZsaW5lID0gY29uZmlnLmFwcGx5T2ZmbGluZTtcbiAgICAgICAgdGhpcy5ub1JldHJ5ID0gY29uZmlnLm5vUmV0cnk7IC8vcmV0cnkgd2lsbCBiZSBkb25lIGJ5IGRlZmF1bHQsIHdoZW4gYSByZXF1ZXN0IGZhaWxzIGJlY2F1c2Ugb2YgZXhwaXJlZCB0b2tlbiwgb25jZSB0aGUgYXV0aGVudGljYXRpb24uY29tcGxldGVBdXRoZW50aWNhdGlvbiBpbiBzZGsgaXMgY2FsbGVkLlxuICAgICAgICB0aGlzLnNraXBBdXRoID0gY29uZmlnLnNraXBBdXRoOyAvL2lmIHNldCB0byB0cnVlLCB0aGUgc2RrIHdpbGwgbm90IHJlcXVpcmUgYXV0aG9yaXphdGlvbiBpZiB0aGUgZGF0YSBxdWVyeSBmYWlscyBiZWNhdXNlIG9mIGV4cGlyZWQgdG9rZW4uIFVzZWQgaW50ZXJuYWxseSBmb3IgdmFyaW91cyBsb2dpbiBtZXRob2RzLlxuICAgICAgICB0aGlzLl9ub3JtYWxpemVkSGVhZGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNTeW5jID0gY29uZmlnLmlzU3luYztcbiAgICB9O1xuXG4gICAgRGF0YVF1ZXJ5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0SGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaGVhZGVyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycyk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fbm9ybWFsaXplZEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIF8uZWFjaChoZWFkZXJLZXlzLCBmdW5jdGlvbiAoaGVhZGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkS2V5ID0gaGVhZGVyS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJWYWx1ZSA9IHNlbGYuaGVhZGVyc1toZWFkZXJLZXldO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3JtYWxpemVkSGVhZGVyc1tub3JtYWxpemVkS2V5XSA9IGhlYWRlclZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZEhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzW25vcm1hbGl6ZWRIZWFkZXJdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEhlYWRlckFzSlNPTjogZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gdGhpcy5fbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoaGVhZGVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoaGVhZGVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIERhdGFRdWVyeS5vcGVyYXRpb25zID0ge1xuICAgICAgICByZWFkOiAncmVhZCcsXG4gICAgICAgIGNyZWF0ZTogJ2NyZWF0ZScsXG4gICAgICAgIHVwZGF0ZTogJ3VwZGF0ZScsXG4gICAgICAgIHJlbW92ZTogJ2Rlc3Ryb3knLFxuICAgICAgICByZW1vdmVTaW5nbGU6ICdkZXN0cm95U2luZ2xlJyxcbiAgICAgICAgcmVhZEJ5SWQ6ICdyZWFkQnlJZCcsXG4gICAgICAgIGNvdW50OiAnY291bnQnLFxuICAgICAgICByYXdVcGRhdGU6ICdyYXdVcGRhdGUnLFxuICAgICAgICBzZXRBY2w6ICdzZXRBY2wnLFxuICAgICAgICBzZXRPd25lcjogJ3NldE93bmVyJyxcbiAgICAgICAgdXNlckxvZ2luOiAnbG9naW4nLFxuICAgICAgICB1c2VyTG9nb3V0OiAnbG9nb3V0JyxcbiAgICAgICAgdXNlckNoYW5nZVBhc3N3b3JkOiAnY2hhbmdlUGFzc3dvcmQnLFxuICAgICAgICB1c2VyTG9naW5XaXRoUHJvdmlkZXI6ICdsb2dpbldpdGgnLFxuICAgICAgICB1c2VyTGlua1dpdGhQcm92aWRlcjogJ2xpbmtXaXRoJyxcbiAgICAgICAgdXNlclVubGlua0Zyb21Qcm92aWRlcjogJ3VubGlua0Zyb20nLFxuICAgICAgICB1c2VyUmVzZXRQYXNzd29yZDogJ3Jlc2V0UGFzc3dvcmQnLFxuICAgICAgICBmaWxlc1VwZGF0ZUNvbnRlbnQ6ICd1cGRhdGVDb250ZW50JyxcbiAgICAgICAgZmlsZXNHZXREb3dubG9hZFVybEJ5SWQ6ICdkb3dubG9hZFVybEJ5SWQnXG4gICAgfTtcblxuICAgIHJldHVybiBEYXRhUXVlcnk7XG59KCkpOyIsInZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xudmFyIE9wZXJhdG9yVHlwZSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLk9wZXJhdG9yVHlwZTtcbnZhciBXaGVyZVF1ZXJ5ID0gcmVxdWlyZSgnLi9XaGVyZVF1ZXJ5Jyk7XG52YXIgUXVlcnlCdWlsZGVyID0gcmVxdWlyZSgnLi9RdWVyeUJ1aWxkZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjbGFzcyBRdWVyeVxuICAgICAqIEBjbGFzc2Rlc2MgQSBxdWVyeSBjbGFzcyB1c2VkIHRvIGRlc2NyaWJlIGEgcmVxdWVzdCB0aGF0IHdpbGwgYmUgbWFkZSB0byB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IEFQSS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2ZpbHRlcl0gQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZmllbGRzXSBBIFtmaWVsZHMgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1TdWJzZXQtb2YtZmllbGRzICV9KSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbc29ydF0gQSBbc29ydCBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLXNvcnRpbmcgJX0pIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgaXRlbXMgdG8gc2tpcC4gVXNlZCBmb3IgcGFnaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFrZV0gTnVtYmVyIG9mIGl0ZW1zIHRvIHRha2UuIFVzZWQgZm9yIHBhZ2luZy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2V4cGFuZF0gQW4gW2V4cGFuZCBleHByZXNzaW9uXSh7JSBzbHVnIGZlYXR1cmVzLWRhdGEtcmVsYXRpb25zLWRlZmluaW5nLWV4cGFuZCAlfSkgZGVmaW5pdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWVyeShmaWx0ZXIsIGZpZWxkcywgc29ydCwgc2tpcCwgdGFrZSwgZXhwYW5kKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5zb3J0ID0gc29ydDtcbiAgICAgICAgdGhpcy50b3NraXAgPSBza2lwO1xuICAgICAgICB0aGlzLnRvdGFrZSA9IHRha2U7XG4gICAgICAgIHRoaXMuZXhwYW5kRXhwcmVzc2lvbiA9IGV4cGFuZDtcbiAgICAgICAgdGhpcy5leHByID0gbmV3IEV4cHJlc3Npb24oT3BlcmF0b3JUeXBlLnF1ZXJ5KTtcbiAgICB9XG5cbiAgICBRdWVyeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKiBBcHBsaWVzIGEgZmlsdGVyIHRvIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgb25seSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCB3aGVyZVxuICAgICAgICAgKiBAbmFtZSB3aGVyZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqIERlZmluZXMgYSBmaWx0ZXIgZGVmaW5pdGlvbiBmb3IgdGhlIGN1cnJlbnQgcXVlcnkuXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCB3aGVyZVxuICAgICAgICAgKiBAbmFtZSB3aGVyZVxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHdoZXJlOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZmlsdGVyLCBbZmlsdGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBBcHBsaWVzIGEgZmllbGRzIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudCBxdWVyeS4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIG9ubHkgYSBzdWJzZXQgb2YgYWxsIGF2YWlsYWJsZSBpdGVtIGZpZWxkcy5cbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmllbGRzRXhwcmVzc2lvbiBBIFtmaWVsZHMgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1TdWJzZXQtb2YtZmllbGRzICV9KSBkZWZpbml0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnNlbGVjdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvL2V4Y2x1ZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZXhjbHVkZSwgYXJndW1lbnRzKTtcbiAgICAgICAgLy99LFxuICAgICAgICAvKiogU29ydHMgdGhlIGl0ZW1zIGluIHRoZSBjdXJyZW50IHF1ZXJ5IGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgc3BlY2lmaWVkIGZpZWxkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2Qgb3JkZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lIHRvIG9yZGVyIGJ5IGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgb3JkZXI6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUub3JkZXIsIFtmaWVsZF0pO1xuICAgICAgICB9LFxuICAgICAgICAvKiogU29ydHMgdGhlIGl0ZW1zIGluIHRoZSBjdXJyZW50IHF1ZXJ5IGluIGRlc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHNwZWNpZmllZCBmaWVsZC5cbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIG9yZGVyRGVzY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUgdG8gb3JkZXIgYnkgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgb3JkZXJEZXNjOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm9yZGVyX2Rlc2MsIFtmaWVsZF0pO1xuICAgICAgICB9LFxuICAgICAgICAvKiogU2tpcHMgYSBjZXJ0YWluIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBiZWdpbm5pbmcgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdCBvZiB0aGUgaXRlbXMuIFVzZWQgZm9yIHBhZ2luZy5cbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNraXBcbiAgICAgICAgICogQHNlZSBbcXVlcnkudGFrZV17QGxpbmsgcXVlcnkudGFrZX1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2tpcC5cbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2tpcDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5za2lwLCBbdmFsdWVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIFRha2VzIGEgc3BlY2lmaWVkIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBxdWVyeSByZXN1bHQuIFVzZWQgZm9yIHBhZ2luZy5cbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHRha2VcbiAgICAgICAgICogQHNlZSBbcXVlcnkuc2tpcF17QGxpbmsgcXVlcnkuc2tpcH1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gdGFrZS5cbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGFrZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS50YWtlLCBbdmFsdWVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIFNldHMgYW4gZXhwYW5kIGV4cHJlc3Npb24gZm9yIHRoZSBjdXJyZW50IHF1ZXJ5LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgY29tcGxleCBkYXRhIHNldHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgYmFzZWQgb24gcmVsYXRpb25zIGJldHdlZW4gZGF0YSB0eXBlcy5cbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIGV4cGFuZFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXhwYW5kRXhwcmVzc2lvbiBBbiBbZXhwYW5kIGV4cHJlc3Npb25dKHslIHNsdWcgZmVhdHVyZXMtZGF0YS1yZWxhdGlvbnMtZGVmaW5pbmctZXhwYW5kICV9KSBkZWZpbml0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5leHBhbmQsIFtleHBhbmRFeHByZXNzaW9uXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBCdWlsZHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRpZmZlcmVudCBleHByZXNzaW9ucyB0aGF0IHdpbGwgYmUgc2VudCB0byB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319LiBJdCBiYXNpY2FsbHkgdHJhbnNsYXRlcyBhbnkgcHJldmlvdXNseSBzcGVjaWZpZWQgZXhwcmVzc2lvbnMgaW50byBzdGFuZGFyZCBxdWVyaWVzIHRoYXQge3tzaXRlLmJzfX0gY2FuIHVuZGVyc3RhbmQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCBidWlsZFxuICAgICAgICAgKiBAcmV0dXJucyB7eyR3aGVyZSwkc2VsZWN0LCRzb3J0LCRza2lwLCR0YWtlLCRleHBhbmR9fVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnlCdWlsZGVyKHRoaXMpLmJ1aWxkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChvcCwgb3Bycykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKG9wcnMpO1xuICAgICAgICAgICAgdGhpcy5leHByLmFkZE9wZXJhbmQobmV3IEV4cHJlc3Npb24ob3AsIGFyZ3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBRdWVyeTtcbn0oKSk7IiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xudmFyIE9wZXJhdG9yVHlwZSA9IGNvbnN0YW50cy5PcGVyYXRvclR5cGU7XG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XG52YXIgR2VvUG9pbnQgPSByZXF1aXJlKCcuLi9HZW9Qb2ludCcpO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xudmFyIG1heERpc3RhbmNlQ29uc3RzID0gY29uc3RhbnRzLm1heERpc3RhbmNlQ29uc3RzO1xudmFyIHJhZGl1c0NvbnN0cyA9IGNvbnN0YW50cy5yYWRpdXNDb25zdHM7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeUJ1aWxkZXIocXVlcnkpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmV4cHIgPSBxdWVyeS5leHByO1xuICAgIH1cblxuICAgIFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIFRPRE8gbWVyZ2UgdGhlIHR3byBvYmplY3RzIGJlZm9yZSByZXR1cm5pbmcgdGhlbVxuICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5maWx0ZXIgfHwgcXVlcnkuZmllbGRzIHx8IHF1ZXJ5LnNvcnQgfHwgcXVlcnkudG9za2lwIHx8IHF1ZXJ5LnRvdGFrZSB8fCBxdWVyeS5leHBhbmRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJHdoZXJlOiBxdWVyeS5maWx0ZXIgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdDogcXVlcnkuZmllbGRzIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRzb3J0OiBxdWVyeS5zb3J0IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICRza2lwOiBxdWVyeS50b3NraXAgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgJHRha2U6IHF1ZXJ5LnRvdGFrZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAkZXhwYW5kOiBxdWVyeS5leHBhbmRFeHByZXNzaW9uIHx8IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAkd2hlcmU6IHRoaXMuX2J1aWxkV2hlcmUoKSxcbiAgICAgICAgICAgICAgICAkc2VsZWN0OiB0aGlzLl9idWlsZFNlbGVjdCgpLFxuICAgICAgICAgICAgICAgICRzb3J0OiB0aGlzLl9idWlsZFNvcnQoKSxcbiAgICAgICAgICAgICAgICAkc2tpcDogdGhpcy5fZ2V0U2tpcCgpLFxuICAgICAgICAgICAgICAgICR0YWtlOiB0aGlzLl9nZXRUYWtlKCksXG4gICAgICAgICAgICAgICAgJGV4cGFuZDogdGhpcy5fZ2V0RXhwYW5kKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRTa2lwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2tpcEV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuc2tpcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNraXBFeHByZXNzaW9uID8gc2tpcEV4cHJlc3Npb24ub3BlcmFuZHNbMF0gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGFrZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRha2VFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLnRha2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YWtlRXhwcmVzc2lvbiA/IHRha2VFeHByZXNzaW9uLm9wZXJhbmRzWzBdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEV4cGFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSBfLmNoYWluKHRoaXMuZXhwci5vcGVyYW5kcylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5leHBhbmQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGV4cHJlc3Npb24pIHsgLy9leHByZXNzaW9uIGNvbnRhaW5zIG9wZXJhbmRzIGFuZCBoYXMgb3BlcmF0b3IgdHlwZSBleHBhbmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKHJlc3VsdCwgZXhwcmVzc2lvbi5vcGVyYW5kc1swXSk7XG4gICAgICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICAgICAgLnZhbHVlKCk7XG4gICAgICAgICAgICByZXR1cm4gXy5pc0VtcHR5KGV4cGFuZEV4cHJlc3Npb24pID8gbnVsbCA6IGV4cGFuZEV4cHJlc3Npb247XG4gICAgICAgIH0sXG4gICAgICAgIF9idWlsZFNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdEV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuc2VsZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAoc2VsZWN0RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIF8ucmVkdWNlKHNlbGVjdEV4cHJlc3Npb24ub3BlcmFuZHMsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW3ZhbHVlXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYnVpbGRTb3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29ydEV4cHJlc3Npb25zID0gXy5maWx0ZXIodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3JkZXIgfHwgdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5vcmRlcl9kZXNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAoc29ydEV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBfLnJlZHVjZShzb3J0RXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChtZW1vLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW3ZhbHVlLm9wZXJhbmRzWzBdXSA9IHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3JkZXIgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYnVpbGRXaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHdoZXJlRXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS53aGVyZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdoZXJlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZChuZXcgRXhwcmVzc2lvbihPcGVyYXRvclR5cGUuYW5kLCB3aGVyZUV4cHJlc3Npb24ub3BlcmFuZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5maWx0ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV4cHJlc3Npb24ub3BlcmFuZHNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW1wbGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZWdleChleHByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdleChleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzR2VvKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbyhleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQW5kKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuZChleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzT3IoZXhwcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3IoZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc05vdChleHByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3QoZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9pc1NpbXBsZTogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5lcXVhbCAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBfc2ltcGxlOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgdmFyIHRlcm0gPSB7fSwgZmllbGRUZXJtID0ge307XG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5fdHJhbnNsYXRlb3BlcmF0b3IoZXhwci5vcGVyYXRvcik7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB0ZXJtW29wZXJhdG9yXSA9IG9wZXJhbmRzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVybSA9IG9wZXJhbmRzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGRUZXJtW29wZXJhbmRzWzBdXSA9IHRlcm07XG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xuICAgICAgICB9LFxuICAgICAgICBfaXNSZWdleDogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5yZWdleCAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS5lbmRzV2l0aDtcbiAgICAgICAgfSxcbiAgICAgICAgX3JlZ2V4OiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gdGhpcy5fZ2V0UmVnZXgoZXhwcik7XG4gICAgICAgICAgICB2YXIgcmVnZXhWYWx1ZSA9IHRoaXMuX2dldFJlZ2V4VmFsdWUocmVnZXgpO1xuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcbiAgICAgICAgICAgIGZpZWxkVGVybVtvcGVyYW5kc1swXV0gPSByZWdleFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFJlZ2V4OiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBleHByLm9wZXJhbmRzWzFdO1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZXhwci5vcGVyYW5kc1syXSA/IGV4cHIub3BlcmFuZHNbMl0gOiAnJztcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwci5vcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLnJlZ2V4OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCA/IHBhdHRlcm4gOiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5lbmRzV2l0aDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiArIFwiJFwiLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldFJlZ2V4VmFsdWU6IGZ1bmN0aW9uIChyZWdleCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAnJztcbiAgICAgICAgICAgIGlmIChyZWdleC5nbG9iYWwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWdleC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWdleC5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyArPSAnaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyRyZWdleDogcmVnZXguc291cmNlLCAkb3B0aW9uczogb3B0aW9uc307XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0dlbzogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5uZWFyU2hwZXJlICYmIGV4cHIub3BlcmF0b3IgPD0gT3BlcmF0b3JUeXBlLndpdGhpblNocGVyZTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dlbzogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZFRlcm0gPSB7fTtcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XG4gICAgICAgICAgICBmaWVsZFRlcm1bb3BlcmFuZHNbMF1dID0gdGhpcy5fZ2V0R2VvVGVybShleHByKTtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRHZW9UZXJtOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgc3dpdGNoIChleHByLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubmVhclNocGVyZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5lYXJTcGhlcmVUZXJtKGV4cHIpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLndpdGhpbkJveDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpbkJveChleHByKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5Qb2x5Z29uOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0V2l0aGluUG9seWdvbihleHByKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRXaXRoaW5DZW50ZXJTcGhlcmUoZXhwcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldE5lYXJTcGhlcmVUZXJtOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSBvcGVyYW5kc1syXTtcbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gb3BlcmFuZHNbM107XG4gICAgICAgICAgICB2YXIgbWF4RGlzdGFuY2VDb25zdDtcbiAgICAgICAgICAgIHZhciB0ZXJtID0ge1xuICAgICAgICAgICAgICAgICckbmVhclNwaGVyZSc6IGNlbnRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2VDb25zdCA9IG1heERpc3RhbmNlQ29uc3RzW21ldHJpY3NdIHx8IG1heERpc3RhbmNlQ29uc3RzLnJhZGlhbnM7XG4gICAgICAgICAgICAgICAgdGVybVttYXhEaXN0YW5jZUNvbnN0XSA9IG1heERpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlcm07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRXaXRoaW5Cb3g6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xuICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB2YXIgdXBwZXJSaWdodCA9IHRoaXMuX2dldEdlb1BvaW50KG9wZXJhbmRzWzJdKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJyR3aXRoaW4nOiB7XG4gICAgICAgICAgICAgICAgICAgICckYm94JzogW2JvdHRvbUxlZnQsIHVwcGVyUmlnaHRdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFdpdGhpblBvbHlnb246IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX2dldEdlb1BvaW50cyhvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICckd2l0aGluJzoge1xuICAgICAgICAgICAgICAgICAgICAnJHBvbHlnb24nOiBwb2ludHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0V2l0aGluQ2VudGVyU3BoZXJlOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gb3BlcmFuZHNbMl07XG4gICAgICAgICAgICB2YXIgbWV0cmljcyA9IG9wZXJhbmRzWzNdO1xuICAgICAgICAgICAgdmFyIHJhZGl1c0NvbnN0ID0gcmFkaXVzQ29uc3RzW21ldHJpY3NdIHx8IHJhZGl1c0NvbnN0cy5yYWRpYW5zO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgJ2NlbnRlcic6IGNlbnRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNwaGVyZUluZm9bcmFkaXVzQ29uc3RdID0gcmFkaXVzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnJHdpdGhpbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJyRjZW50ZXJTcGhlcmUnOiBzcGhlcmVJbmZvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEdlb1BvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW9Qb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0R2VvUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gXy5tYXAocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0R2VvUG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0FuZDogZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuYW5kO1xuICAgICAgICB9LFxuICAgICAgICBfYW5kOiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcGVyYW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZXJtID0gdGhpcy5fYnVpbGQob3BlcmFuZHNbaV0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2FuZEFwcGVuZChyZXN1bHQsIHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgX2FuZEFwcGVuZDogZnVuY3Rpb24gKGFuZE9iaiwgbmV3T2JqKSB7XG4gICAgICAgICAgICB2YXIgaSwgbCwga2V5LCB2YWx1ZSwgbmV3VmFsdWU7XG4gICAgICAgICAgICB2YXIga2V5cyA9IF8ua2V5cyhuZXdPYmopO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFuZE9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZE9ialtrZXldID0gbmV3T2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld09ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF8uZXh0ZW5kKHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFuZE9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZE9iajtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzT3I6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yO1xuICAgICAgICB9LFxuICAgICAgICBfb3I6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IG9wZXJhbmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRlcm0gPSB0aGlzLl9idWlsZChvcGVyYW5kc1tpXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyRvcjogcmVzdWx0fTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzTm90OiBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5ub3Q7XG4gICAgICAgIH0sXG4gICAgICAgIF9ub3Q6IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICByZXR1cm4geyRub3Q6IHRoaXMuX2J1aWxkKGV4cHIub3BlcmFuZHNbMF0pfTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RyYW5zbGF0ZW9wZXJhdG9yOiBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5lcXVhbDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubm90X2VxdWFsOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRuZSc7XG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuZ3Q6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGd0JztcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5sdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckbHQnO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmd0ZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckZ3RlJztcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5sdGU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGx0ZSc7XG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUuaXNpbjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckaW4nO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLm5vdGluOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRuaW4nO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmFsbDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckYWxsJztcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5zaXplOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRzaXplJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdVbmtub3duIG9wZXJhdG9yIHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFF1ZXJ5QnVpbGRlcjtcbn0oKSk7IiwidmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4vRGF0YVF1ZXJ5Jyk7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uJykuXztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIgPSB7fTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybCA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICBpZiAoZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zICYmIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCkge1xuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuZHBvaW50O1xuICAgIH07XG5cbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdCA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRPYmplY3QgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSksXG4gICAgICAgICAgICBmaWx0ZXI6IGRhdGFRdWVyeS5maWx0ZXIsXG4gICAgICAgICAgICBzdWNjZXNzOiBkYXRhUXVlcnkub25TdWNjZXNzLFxuICAgICAgICAgICAgZXJyb3I6IGRhdGFRdWVyeS5vbkVycm9yLFxuICAgICAgICAgICAgZGF0YTogZGF0YVF1ZXJ5LmRhdGEsXG4gICAgICAgICAgICBoZWFkZXJzOiBkYXRhUXVlcnkuaGVhZGVyc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkYXRhUXVlcnkucGFyc2UpIHtcbiAgICAgICAgICAgIGRlZmF1bHRPYmplY3QucGFyc2UgPSBkYXRhUXVlcnkucGFyc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdE9iamVjdDtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZCA9IGZ1bmN0aW9uIChkYXRhUXVlcnksIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdChkYXRhUXVlcnkpLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGVuZHBvaW50OiBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUgKyAnL19jb3VudCdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmZpbHRlcjtcbiAgICAgICAgdmFyIG9maWx0ZXIgPSBudWxsOyAvLyByZXF1ZXN0IG9wdGlvbnMgZmlsdGVyXG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBmaWx0ZXI7IC8vIHNlbmQgdGhlIGZpbHRlciB0aHJvdWdoIHF1ZXJ5IHN0cmluZ1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvZmlsdGVyID0gZmlsdGVyOyAvLyBzZW5kIHRoZSBmaWx0ZXIgYXMgZmlsdGVyIGhlYWRlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcbiAgICAgICAgICAgIGZpbHRlcjogb2ZpbHRlclxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJ1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdChkYXRhUXVlcnkpLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlXSA9IFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVdO1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldEFjbF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XG4gICAgICAgIHZhciBlbmRwb2ludCA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcbiAgICAgICAgdmFyIGZpbHRlciA9IGRhdGFRdWVyeS5maWx0ZXI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIGlmIGZpbHRlciBpcyBzdHJpbmcgdGhhbiB3aWxsIHVwZGF0ZSBhIHNpbmdsZSBpdGVtIHVzaW5nIHRoZSBmaWx0ZXIgYXMgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7IC8vIGVsc2UgaWYgaXQgaXMgYW4gb2JqZWN0IHRoYW4gd2Ugd2lsbCB1c2UgaXQncyBpZCBwcm9wZXJ0eVxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyW2lkRmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGVuZHBvaW50ICs9ICcvX2FjbCc7XG4gICAgICAgIHZhciBtZXRob2QsIGRhdGE7XG4gICAgICAgIGlmIChkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuYWNsID09PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5hY2w7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnNldE93bmVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xuICAgICAgICB2YXIgZmlsdGVyID0gZGF0YVF1ZXJ5LmZpbHRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIGlmIGZpbHRlciBpcyBzdHJpbmcgdGhhbiB3aWxsIHVwZGF0ZSBhIHNpbmdsZSBpdGVtIHVzaW5nIHRoZSBmaWx0ZXIgYXMgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7IC8vIGVsc2UgaWYgaXQgaXMgYW4gb2JqZWN0IHRoYW4gd2Ugd2lsbCB1c2UgaXQncyBpZCBwcm9wZXJ0eVxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyW2lkRmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGVuZHBvaW50ICs9ICcvX293bmVyJztcblxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBlbmRwb2ludDogZW5kcG9pbnRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5dID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgZW5kcG9pbnQ6ICdvYXV0aC90b2tlbicsXG4gICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dvdXRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBlbmRwb2ludDogJ29hdXRoL2xvZ291dCdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyQ2hhbmdlUGFzc3dvcmRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICB2YXIga2VlcFRva2VucyA9IGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5rZWVwVG9rZW5zO1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSAnVXNlcnMvY2hhbmdlcGFzc3dvcmQnO1xuICAgICAgICBpZiAoa2VlcFRva2Vucykge1xuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJz9rZWVwVG9rZW5zPXRydWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luV2l0aFByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMaW5rV2l0aFByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvbGluaydcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvdW5saW5rJ1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJSZXNldFBhc3N3b3JkXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvcmVzZXRwYXNzd29yZCdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5maWxlc1VwZGF0ZUNvbnRlbnRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSkgKyAnL0NvbnRlbnQnXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNHZXREb3dubG9hZFVybEJ5SWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXI7XG59KCkpOyIsInZhciBFeHByZXNzaW9uID0gcmVxdWlyZSgnLi4vRXhwcmVzc2lvbicpO1xudmFyIE9wZXJhdG9yVHlwZSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLk9wZXJhdG9yVHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjbGFzc2Rlc2MgQSBmbHVlbnQgQVBJIG9wZXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBmaWx0ZXIgZm9yIGEgcXVlcnkgYnkgY2hhaW5pbmcgZGlmZmVyZW50IHJ1bGVzLlxuICAgICAqIEBjbGFzcyBXaGVyZVF1ZXJ5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZXEgYXMgV2hlcmVRdWVyeSNlcXVhbFxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbmUgYXMgV2hlcmVRdWVyeSNub3RFcXVhbFxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZ3QgYXMgV2hlcmVRdWVyeSNncmVhdGVyVGhhblxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZ3RlIGFzIFdoZXJlUXVlcnkjZ3JlYXRlclRoYW5FcXVhbFxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbHQgYXMgV2hlcmVRdWVyeSNsZXNzVGhhblxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjbHRlIGFzIFdoZXJlUXVlcnkjbGVzc1RoYW5FcXVhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdoZXJlUXVlcnkocGFyZW50UXVlcnksIGV4cHJPcCwgc2luZ2xlT3BlcmFuZCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFF1ZXJ5O1xuICAgICAgICB0aGlzLnNpbmdsZSA9IHNpbmdsZU9wZXJhbmQ7XG4gICAgICAgIHRoaXMuZXhwciA9IG5ldyBFeHByZXNzaW9uKGV4cHJPcCB8fCBPcGVyYXRvclR5cGUud2hlcmUpO1xuICAgICAgICB0aGlzLnBhcmVudC5leHByLmFkZE9wZXJhbmQodGhpcy5leHByKTtcbiAgICB9XG5cbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYGFuZGAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBhbmRcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLmFuZCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGBvcmAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBvclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXaGVyZVF1ZXJ5KHRoaXMsIE9wZXJhdG9yVHlwZS5vcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgYG5vdGAgY2xhdXNlIHRvIHRoZSBjdXJyZW50IGNvbmRpdGlvbiBhbmQgcmV0dXJucyBpdCBmb3IgZnVydGhlciBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBub3RcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgbm90OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLm5vdCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB0aGlzLmV4cHIuYWRkT3BlcmFuZChuZXcgRXhwcmVzc2lvbihvcGVyYXRvciwgYXJncykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvbmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgZXF1YWwgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cbiAgICAgICAgICogQG1ldGhvZCBlcVxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodG8gd2hpY2ggdGhlIGZpZWxkcyBtdXN0IGJlIGVxdWFsKS5cbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBlcTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZXF1YWwsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0ICpub3QqIGJlIGVxdWFsIHRvIGEgc3BlY2lmaWMgdmFsdWUuXG4gICAgICAgICAqIEBtZXRob2QgbmVcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRvIHdoaWNoIHRoZSBmaWVsZCBtdXN0IG5vdCBiZSBlcXVhbCkuXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgbmU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm5vdF9lcXVhbCwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGdyZWF0ZXIgdGhhbmAgYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXG4gICAgICAgICAqIEBtZXRob2QgZ3RcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4pLlxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIGd0OiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ndCwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGdyZWF0ZXIgdGhhbiBvciBlcXVhbGAgdG8gYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXG4gICAgICAgICAqIEBtZXRob2QgZ3RlXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvKS5cbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBndGU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmd0ZSwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGxlc3MgdGhhbmAgYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXG4gICAgICAgICAqIEBtZXRob2QgbHRcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW4pLlxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIGx0OiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5sdCwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGxlc3MgdGhhbiBvciBlcXVhbGAgdG8gYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXG4gICAgICAgICAqIEBtZXRob2QgbHRlXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvKS5cbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBsdGU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmx0ZSwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgaW4gYSBzZXQgb2YgdmFsdWVzLlxuICAgICAgICAgKiBAbWV0aG9kIGlzaW5cbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBpbi5cbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBpc2luOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5pc2luLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCAqbm90KiBiZSBpbiBhIHNldCBvZiB2YWx1ZXMuXG4gICAgICAgICAqIEBtZXRob2Qgbm90aW5cbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgc2hvdWxkIG5vdCBiZSBpbi5cbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBub3RpbjogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUubm90aW4sIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGluY2x1ZGUgKmFsbCogb2YgdGhlIHNwZWNpZmllZCB2YWx1ZXMuIEFwcGxpY2FibGUgdG8gQXJyYXkgZmllbGRzLlxuICAgICAgICAgKiBAbWV0aG9kIGFsbFxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIEFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IHRoZSBmaWVsZCBtdXN0IGluY2x1ZGUuXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgYWxsOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5hbGwsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgd2hvc2UgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIGEgc3BlY2lmaWVkIHZhbHVlLiBBcHBsaWNhYmxlIHRvIEFycmF5IGZpZWxkcy5cbiAgICAgICAgICogQG1ldGhvZCBzaXplXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBzaXplIHRoYXQgdGhlIGFycmF5IG11c3QgYmUgYmlnZ2VyIHRoYW4uXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuc2l6ZSwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3Qgc2F0aXNmeSBhIHNwZWNpZmllZCByZWdleC5cbiAgICAgICAgICogQG1ldGhvZCByZWdleFxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWd1bGFyRXhwcmVzc2lvbiBSZWd1bGFyIGV4cHJlc3Npb24gaW4gUENSRSBmb3JtYXQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgcmVnZXg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5yZWdleCwgZmllbGQsIHZhbHVlLCBmbGFncyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCB2YWx1ZSBtdXN0ICpzdGFydCogd2l0aCBhIHNwZWNpZmllZCBzdHJpbmcuXG4gICAgICAgICAqIEBtZXRob2Qgc3RhcnRzV2l0aFxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3RyaW5nIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBzdGFydCB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnNdIEEgc3RyaW5nIG9mIHJlZ2V4IG9wdGlvbnMgdG8gdXNlLiBTZWUgW3NwZWNzXSh7aHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9yZWdleC8jb3AuX1Nfb3B0aW9uc30pIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5zdGFydHNXaXRoLCBmaWVsZCwgdmFsdWUsIGZsYWdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIHZhbHVlIG11c3QgKmVuZCogd2l0aCBhIHNwZWNpZmllZCBzdHJpbmcuXG4gICAgICAgICAqIEBtZXRob2QgZW5kc1dpdGhcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyB0aGF0IHRoZSBmaWVsZCBzaG91bGQgZW5kIHdpdGguXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgIHJlZ2V4IG9wdGlvbnMgdG8gdXNlLiBTZWUgW3NwZWNzXSh7aHR0cDovL2RvY3MubW9uZ29kYi5vcmcvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9yZWdleC8jb3AuX1Nfb3B0aW9uc30pIGZvciBhIGRlc2NyaXB0aW9uIG9mIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIGVuZHNXaXRoOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuZW5kc1dpdGgsIGZpZWxkLCB2YWx1ZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBjZXJ0YWluIGRpc3RhbmNlIGZyb20gYW5vdGhlciBnZW9wb2ludC4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cbiAgICAgICAgICogQG1ldGhvZCBuZWFyU3BoZXJlXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnQgQ29tcGFyaXNvbiBnZW9wb2ludCB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldHJpY3M9cmFkaWFuc10gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoYXQgdW5pdCBvZiBtZWFzdXJlbWVudCBpcyB1c2VkIGZvciBkaXN0YW5jZS4gUG9zc2libGUgdmFsdWVzOiByYWRpYW5zLCBrbSwgbWlsZXMuXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgbmVhclNwaGVyZTogZnVuY3Rpb24gKGZpZWxkLCBwb2ludCwgZGlzdGFuY2UsIG1ldHJpY3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm5lYXJTaHBlcmUsIGZpZWxkLCBwb2ludCwgZGlzdGFuY2UsIG1ldHJpY3MpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBzcGVjaWZpZWQgY29vcmRpbmF0ZSByZWN0YW5nbGUuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXG4gICAgICAgICAqIEBtZXRob2Qgd2l0aGluQm94XG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnRCb3R0b21MZWZ0IFZhbHVlIHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBib3guXG4gICAgICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuR2VvUG9pbnR9IHBvaW50VXBwZXJSaWdodCBWYWx1ZSByZXByZXNlbnRpbmcgdGhlIHVwcGVyIHJpZ2h0IGNvcm5lciBvZiB0aGUgYm94LlxuICAgICAgICAgKiBAZXhhbXBsZSBgYGBqc1xuICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IEV2ZXJsaXZlLlF1ZXJ5KCk7XG4gICAgICAgICBxdWVyeS53aGVyZSgpLndpdGhpbkJveCgnTG9jYXRpb24nLFxuICAgICAgICAgbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMxNzg3MSwgNDIuNjg3NzA5KSxcbiAgICAgICAgIG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMzEzNDYsIDQyLjcwNzA3NSkpO1xuICAgICAgICAgYGBgXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgd2l0aGluQm94OiBmdW5jdGlvbiAoZmllbGQsIHBvaW50Qm90dG9tTGVmdCwgcG9pbnRVcHBlclJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS53aXRoaW5Cb3gsIGZpZWxkLCBwb2ludEJvdHRvbUxlZnQsIHBvaW50VXBwZXJSaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIHNwZWNpZmllZCBjb29yZGluYXRlIHBvbHlnb24uIFRoZSBwb2x5Z29uIGlzIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBnZW9wb2ludHMuIFRoZSBsYXN0IHBvaW50IGluIHRoZSBhcnJheSBpcyBpbXBsaWNpdGx5IGNvbm5lY3RlZCB0byB0aGUgZmlyc3QgcG9pbnQgdGh1cyBjbG9zaW5nIHRoZSBzaGFwZS4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5Qb2x5Z29uXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludFtdfSBwb2ludHMgQ29tcGFyaXNvbiB2YWx1ZSBpbiB0aGUgZm9ybSBvZiBhbiBhcnJheSBvZiBnZW9wb2ludHMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqIEBleGFtcGxlIGBgYGpzXG4gICAgICAgICB2YXIgcG9pbnQxID0gbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMxNzg3MSwgNDIuNjg3NzA5KTtcbiAgICAgICAgIHZhciBwb2ludDIgPSBuZXcgRXZlcmxpdmUuR2VvUG9pbnQoNDIuNjk4NzQ5LCA0Mi42OTg3NDkpO1xuICAgICAgICAgdmFyIHBvaW50MyA9IG5ldyBFdmVybGl2ZS5HZW9Qb2ludCgyMy4zMzEzNDYsIDQyLjcwMjI4Mik7XG5cbiAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBFdmVybGl2ZS5RdWVyeSgpO1xuICAgICAgICAgcXVlcnkud2hlcmUoKS53aXRoaW5Qb2x5Z29uKFwibG9jYXRpb25cIiwgW3BvaW50MSwgcG9pbnQyLCBwb2ludDNdKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgd2l0aGluUG9seWdvbjogZnVuY3Rpb24gKGZpZWxkLCBwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLndpdGhpblBvbHlnb24sIGZpZWxkLCBwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBjb29yZGluYXRlIGNpcmNsZS4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5DZW50ZXJTcGhlcmVcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lIGNvbnRhaW5pbmcgYSB7R2VvUG9pbnR9IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgKGRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSxkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKWAsIHdoZXJlICpkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUqIHJhbmdlcyBmcm9tIC05MCB0byA5MCBhbmQgKmRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUqIHJhbmdlcyBmcm9tIC0xODAgdG8gMTgwLiBFeGFtcGxlOiBgKDQyLjY5NTQzMjIsMTIzLjMyMzk0NjcpYFxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50fSBjZW50ZXIgQ29tcGFyaXNvbiB2YWx1ZSBzcGVjaWZ5aW5nIHRoZSBjZW50ZXIgb2YgdGhlIGNvb3JkaW5hdGUgY2lyY2xlLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFZhbHVlIHNwZWNpZnlpbmcgdGhlIHJhZGl1cyBsZW5ndGguXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0cmljcz1yYWRpYW5zXSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hhdCB1bml0IG9mIG1lYXN1cmVtZW50IGlzIHVzZWQgZm9yIHJhZGl1cyBsZW5ndGguIFBvc3NpYmxlIHZhbHVlczogcmFkaWFucywga20sIG1pbGVzLlxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHdpdGhpbkNlbnRlclNwaGVyZTogZnVuY3Rpb24gKGZpZWxkLCBjZW50ZXIsIHJhZGl1cywgbWV0cmljcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUud2l0aGluU2hwZXJlLCBmaWVsZCwgY2VudGVyLCByYWRpdXMsIG1ldHJpY3MpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRW5kcyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgY3VycmVudCBXaGVyZVF1ZXJ5LiBZb3UgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGluIG9yZGVyIHRvIGNvbnRpbnVlIHdpdGggdGhlIGRlZmluaXRpb24gb2YgdGhlIHBhcmVudCBgUXVlcnlgLiBBbGwgb3RoZXIgYFdoZXJlUXVlcnlgIG1ldGhvZHMgcmV0dXJuIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIGBXaGVyZVF1ZXJ5YCB0byBhbGxvdyBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBkb25lXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBXaGVyZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Ll9kb25lKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2RvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUuZXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5lcTtcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ub3RFcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLm5lO1xuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3Q7XG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3JlYXRlclRoYW5FcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmd0ZTtcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sZXNzVGhhbiA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmx0O1xuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmxlc3NUaGFuRXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sdGU7XG5cbiAgICByZXR1cm4gV2hlcmVRdWVyeTtcbn0oKSk7IiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gcmVxd2VzdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBodHRwUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIGh0dHBSZXF1ZXN0T3B0aW9ucy5jb250ZW50ID0gb3B0aW9ucy5kYXRhOyAvLyBOT1RFOiBJZiB3ZSBwYXNzIG51bGwvdW5kZWZpbmVkLCBpdCB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbiBpbiB0aGUgaHR0cCBtb2R1bGUuXG4gICAgICAgIH1cblxuICAgICAgICBodHRwUmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIGh0dHBSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcblxuICAgICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgfHwgbm9vcDtcbiAgICAgICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvciB8fCBub29wO1xuXG4gICAgICAgIHZhciByZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFN0cmluZyA9IHJlc3BvbnNlLmNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBjYWxsYmFjayBjYWxscyBhIGN1c3RvbSBwYXJzZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY29udGVudFN0cmluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGNhbGxiYWNrIHJlbGllcyBvbiBhIEpTT04gT2JqZWN0IHdpdGggUmVzcG9uc2VUZXh0IGluc2lkZVxuICAgICAgICAgICAgICAgIGVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiBjb250ZW50U3RyaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcXVlc3RFcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gZXJyb3I6IGZ1bmN0aW9uKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bilcbiAgICAgICAgICAgIC8vIHdoZW4gdGltZW91dGluZyBmb3IgZXhhbXBsZSAoaS5lLiBubyBpbnRlcm5ldCBjb25uZWN0aXZpdHkpLCB3ZSBnZXQgYW4gZXJyIHdpdGggY29udGVudCB7IG1lc3NhZ2U6IFwidGltZW91dC4uLlwiLCBzdGFjazogbnVsbCB9XG4gICAgICAgICAgICBlcnJvcih7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGh0dHAucmVxdWVzdChodHRwUmVxdWVzdE9wdGlvbnMpLnRoZW4ocmVxdWVzdFN1Y2Nlc3NDYWxsYmFjaywgcmVxdWVzdEVycm9yQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiByZXF3ZXN0O1xufSgpKTsiLCJ2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgcnN2cCA9IHJlcXVpcmUoJ3JzdnAnKTtcbnZhciB6bGliID0gcmVxdWlyZSgnemxpYicpO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiByZXF3ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybFBhcnRzID0gdXJsLnBhcnNlKG9wdGlvbnMudXJsKTtcbiAgICAgICAgdmFyIHJlcXVlc3Q7XG4gICAgICAgIGlmICh1cmxQYXJ0cy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IF8ubm9vcDtcbiAgICAgICAgb3B0aW9ucy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgfHwgXy5ub29wO1xuXG4gICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICAgICAgdmFyIHJlcSA9IHJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJ0cy5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHVybFBhcnRzLnBvcnQsXG4gICAgICAgICAgICBwYXRoOiB1cmxQYXJ0cy5wYXRoLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9ICcnO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRFbmNvZGluZyA9IHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm94eTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29udGVudEVuY29kaW5nKXtcbiAgICAgICAgICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm94eSA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5waXBlKHJlc3BvbnNlUHJveHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb3h5ID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb3h5LnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZVByb3h5Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBqc29uICs9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXNwb25zZVByb3h5Lm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gMXh4IEluZm9ybWF0aW9uYWwsIDJ4eCBTdWNjZXNzLCAzeHggUmVkaXJlY3Rpb24sIDR4eCBDbGllbnQgRXJyb3IsIDV4eCBTZXJ2ZXIgRXJyb3JcbiAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlcy5zdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2Vzcyhqc29uLCByZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yKHsgcmVzcG9uc2VUZXh0OiBqc29uIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBlbXB0eSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSZXNwb25zZSBlcnJvci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoeyByZXNwb25zZVRleHQ6IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5lcnJvcih7IHJlc3BvbnNlVGV4dDogZSB9KTsgLy8gVE9ET1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudEVuY29kaW5nID0gaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICAgICAgc3dpdGNoIChjb250ZW50RW5jb2Rpbmcpe1xuICAgICAgICAgICAgICAgIGNhc2UgJ2d6aXAnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihvcHRpb25zLmRhdGEsICd1dGYtOCcpO1xuICAgICAgICAgICAgICAgICAgICB6bGliLmd6aXAoYnVmLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5lbmQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlcS5lbmQob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXEuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVxd2VzdDtcbn0oKSk7IiwidmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKTtcbnZhciBXZWJGaWxlU3RvcmUgPSByZXF1aXJlKCcuL1dlYkZpbGVTdG9yZScpO1xudmFyIE5hdGl2ZVNjcmlwdEZpbGVTdG9yZSA9IHJlcXVpcmUoJy4vTmF0aXZlU2NyaXB0RmlsZVN0b3JlJyk7XG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHBsYXRmb3JtLmlzTmF0aXZlU2NyaXB0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOYXRpdmVTY3JpcHRGaWxlU3RvcmU7XG59IGVsc2UgaWYgKHBsYXRmb3JtLmlzQ29yZG92YSB8fCBwbGF0Zm9ybS5pc0Rlc2t0b3ApIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFdlYkZpbGVTdG9yZTtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfLm5vb3A7XG59IiwidmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi8uLi9ldmVybGl2ZS5wbGF0Zm9ybS5qcycpO1xudmFyIGlzTmF0aXZlU2NyaXB0ID0gcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQ7XG52YXIgaXNOb2RlanMgPSBwbGF0Zm9ybS5pc05vZGVqcztcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLy4uL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaW5pdExvY2FsU3RvcmFnZShvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc05hdGl2ZVNjcmlwdCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsU2V0dGluZ3M7XG5cbiAgICAgICAgICAgIC8vd29ya291bmQgZm9yIG9sZGVyIG5hdGl2ZXNjcmlwdCB2ZXJzaW9uc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2NhbFNldHRpbmdzID0gcmVxdWlyZSgnYXBwbGljYXRpb24tc2V0dGluZ3MnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFNldHRpbmdzID0gcmVxdWlyZSgnbG9jYWwtc2V0dGluZ3MnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNldHRpbmdzLmdldFN0cmluZyhrZXkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNldHRpbmdzLnJlbW92ZShrZXkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTZXR0aW5ncy5zZXRTdHJpbmcoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICBpZiAoaXNOb2RlanMpIHtcbiAgICAgICAgICAgICAgICB2YXIgTG9jYWxTdG9yYWdlID0gcmVxdWlyZSgnbm9kZS1sb2NhbHN0b3JhZ2UnKS5Mb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZShvcHRpb25zLnN0b3JhZ2Uuc3RvcmFnZVBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxTdG9yZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RvcmFnZSA9IGluaXRMb2NhbFN0b3JhZ2UodGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBMb2NhbFN0b3JlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0SXRlbTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gTG9jYWxTdG9yZTtcbn0oKSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xuXG5mdW5jdGlvbiBOYXRpdmVTY3JpcHRGaWxlU3RvcmUoc3RvcmFnZVBhdGgsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZnMgPSByZXF1aXJlKCdmaWxlLXN5c3RlbScpO1xuICAgIHRoaXMuZGF0YURpcmVjdG9yeVBhdGggPSB0aGlzLmZzLmtub3duRm9sZGVycy5kb2N1bWVudHMoKS5wYXRoO1xuICAgIHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoID0gc3RvcmFnZVBhdGg7XG59XG5cbk5hdGl2ZVNjcmlwdEZpbGVTdG9yZS5wcm90b3R5cGUgPSB7XG4gICAgZ2V0RXJyb3JIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVGaWxlc0RpcmVjdG9yeTogZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5KSB7XG4gICAgICAgIHZhciBmaWxlc0RpcmVjdG9yeVBhdGggPSB0aGlzLmZzLnBhdGguam9pbihkaXJlY3RvcnlFbnRyeS5wYXRoLCB0aGlzLmZpbGVzRGlyZWN0b3J5UGF0aCk7XG4gICAgICAgIHZhciBmaWxlc0RpcmVjdG9yeSA9IHRoaXMuZnMuRm9sZGVyLmZyb21QYXRoKGZpbGVzRGlyZWN0b3J5UGF0aCk7XG4gICAgICAgIHJldHVybiBmaWxlc0RpcmVjdG9yeS5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRmlsZTogZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICByZXR1cm4gZmlsZUVudHJ5LnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICByZWFkRmlsZUFzVGV4dDogZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICByZXR1cm4gZmlsZUVudHJ5LnJlYWRUZXh0KCk7XG4gICAgfSxcblxuICAgIHdyaXRlVGV4dFRvRmlsZTogZnVuY3Rpb24gKGZpbGVFbnRyeSwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gZmlsZUVudHJ5LndyaXRlVGV4dChjb250ZW50KTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmVEYXRhRGlyZWN0b3J5KGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBmdWxsRmlsZVBhdGggPSBzZWxmLmZzLnBhdGguam9pbihkaXJlY3RvcnlFbnRyeS5wYXRoLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHNlbGYuZnMuRmlsZS5mcm9tUGF0aChmdWxsRmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZURhdGFEaXJlY3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YURpcmVjdG9yeSA9IHNlbGYuZnMuRm9sZGVyLmZyb21QYXRoKHNlbGYuZGF0YURpcmVjdG9yeVBhdGgpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhRGlyZWN0b3J5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGVuc3VyZUZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmVEYXRhRGlyZWN0b3J5KGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlRGlyZWN0b3J5UGF0aCA9IHNlbGYuZnMucGF0aC5qb2luKGRpcmVjdG9yeUVudHJ5LnBhdGgsIHNlbGYuZmlsZXNEaXJlY3RvcnlQYXRoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZzLkZvbGRlci5mcm9tUGF0aChmaWxlRGlyZWN0b3J5UGF0aCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRGaWxlc0RpcmVjdG9yeVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNEaXJlY3RvcnlQYXRoO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBbb2ZmbGluZV0gSW1wbGVtZW50XG4gICAgd3JpdGVUZXh0OiBmdW5jdGlvbiAoZmlsZU5hbWUsIHRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogW29mZmxpbmVdIEltcGxlbWVudFxuICAgIGNyZWF0ZURpcmVjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBbb2ZmbGluZV0gSW1wbGVtZW50XG4gICAgZ2V0RmlsZVNpemU6IGZ1bmN0aW9uIChmaWxlLCBnZXRGaWxlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBbb2ZmbGluZV0gSW1wbGVtZW50XG4gICAgZ2V0RmlsZUJ5QWJzb2x1dGVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0sXG5cbiAgICByZWFkRmlsZUFzQmFzZTY0OiBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0sXG5cbiAgICByZW5hbWVGaWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTmF0aXZlU2NyaXB0RmlsZVN0b3JlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciByc3ZwID0gY29tbW9uLnJzdnA7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5mdW5jdGlvbiBXZWJGaWxlU3RvcmUoc3RvcmFnZVBhdGgsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdmFyIGZpbGVzRGlyZWN0b3J5UGF0aDtcbiAgICBpZiAocGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUpIHtcbiAgICAgICAgZmlsZXNEaXJlY3RvcnlQYXRoID0gJy8nICsgc3RvcmFnZVBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZXNEaXJlY3RvcnlQYXRoID0gc3RvcmFnZVBhdGggKyAnLyc7XG4gICAgfVxuXG4gICAgdGhpcy5maWxlc0RpcmVjdG9yeVBhdGggPSBmaWxlc0RpcmVjdG9yeVBhdGg7XG4gICAgdGhpcy5fcmVxdWVzdEZpbGVTeXN0ZW0gPSB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gfHwgd2luZG93LndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtO1xuICAgIHRoaXMuX3Jlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkwgPSB3aW5kb3cucmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTCB8fCB3aW5kb3cud2Via2l0UmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTDtcbiAgICB0aGlzLl9QRVJTSVNURU5UX0ZJTEVfU1lTVEVNID0gd2luZG93LkxvY2FsRmlsZVN5c3RlbSA/IHdpbmRvdy5Mb2NhbEZpbGVTeXN0ZW0uUEVSU0lTVEVOVCA6IHdpbmRvdy5QRVJTSVNURU5UO1xufVxuXG5XZWJGaWxlU3RvcmUucHJvdG90eXBlID0ge1xuICAgIGdldEVycm9ySGFuZGxlcjogZnVuY3Rpb24gZ2V0RXJyb3JIYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlcnJvcnNNYXAgPSB7XG4gICAgICAgICAgICAnMTAwMCc6ICdOT1RfRk9VTkQnXG4gICAgICAgIH07XG5cbiAgICAgICAgXy5lYWNoKE9iamVjdC5rZXlzKEZpbGVFcnJvciksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3JzTWFwW0ZpbGVFcnJvcltlcnJvcl1dID0gZXJyb3I7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCFlLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBlcnJvcnNNYXBbZS5jb2RlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RGF0YURpcmVjdG9yeTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbGVTeXN0ZW1Sb290O1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXREYXRhRGlyZWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RGaWxlU3lzdGVtID0gZnVuY3Rpb24gKGJ5dGVzLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGYuX3JlcXVlc3RGaWxlU3lzdGVtLmNhbGwod2luZG93LCBzZWxmLl9QRVJTSVNURU5UX0ZJTEVfU1lTVEVNLCBieXRlcywgZnVuY3Rpb24gKGZpbGVTeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVN5c3RlbVJvb3QgPSBmaWxlU3lzdGVtLnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVTeXN0ZW1Sb290Lm5hdGl2ZVVSTCA9IGZpbGVTeXN0ZW1Sb290Lm5hdGl2ZVVSTCB8fCBmaWxlU3lzdGVtUm9vdC50b1VSTCgpO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGZpbGVTeXN0ZW1Sb290KTtcbiAgICAgICAgICAgICAgICB9LCBlcnJvcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVTeXN0ZW1Sb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZpbGVTeXN0ZW1Sb290KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGxhdGZvcm0uaXNEZXNrdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IgJiYgIW5hdmlnYXRvci53ZWJraXRQZXJzaXN0ZW50U3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignRmlsZVN5c3RlbVN0b3JhZ2UgY2FuIGJlIHVzZWQgb25seSB3aXRoIGJyb3dzZXJzIHN1cHBvcnRpbmcgaXQuIENvbnNpZGVyIHVzaW5nIGxvY2FsU3RvcmFnZS4nKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci53ZWJraXRQZXJzaXN0ZW50U3RvcmFnZS5yZXF1ZXN0UXVvdGEoc2VsZi5vcHRpb25zLnN0b3JhZ2UucmVxdWVzdGVkUXVvdGEsIGZ1bmN0aW9uIChncmFudGVkQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RGaWxlU3lzdGVtKGdyYW50ZWRCeXRlcywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RmlsZVN5c3RlbSgwLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSgpKSxcblxuICAgIGdldEZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiBnZXRGaWxlc0RpcmVjdG9yeSgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLmdldERhdGFEaXJlY3RvcnkoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFEaXJlY3RvcnkuZ2V0RGlyZWN0b3J5KHNlbGYuZmlsZXNEaXJlY3RvcnlQYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNsdXNpdmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbW92ZUZpbGVzRGlyZWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWxlc0RpcmVjdG9yeSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVtb3ZlRm9sZGVyV3JhcChmaWxlc0RpcmVjdG9yeSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRmlsZTogZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkucmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVhZEZpbGVBc1RleHQ6IGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHNlbGYuZ2V0RmlsZXNEaXJlY3RvcnkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy93aW5kb3dzIHBob25lIHJldHVybnMgYW4gb2JqZWN0Li4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgd3JpdGVUZXh0VG9GaWxlOiBmdW5jdGlvbiAoZmlsZUVudHJ5LCBjb250ZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gc2VsZi5nZXRGaWxlc0RpcmVjdG9yeSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldFdyaXRlcldyYXAoZmlsZUVudHJ5LCBjb250ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRGaWxlU2l6ZTogZnVuY3Rpb24gKGZpbGVuYW1lLCBmb2xkZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBmaWxlTG9jYXRpb24gPSB1dGlscy5qb2luUGF0aChmb2xkZXIsIGZpbGVuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RmlsZShmaWxlTG9jYXRpb24pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRGaWxlOiBmdW5jdGlvbiAoZmlsZU5hbWUsIGRpckVudHJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzRGlyZWN0b3J5KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlRGlyZWN0b3J5O1xuICAgICAgICAgICAgICAgIGlmIChkaXJFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlRGlyZWN0b3J5ID0gZGlyRW50cnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZURpcmVjdG9yeSA9IGRpcmVjdG9yeUVudHJ5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZURpcmVjdG9yeS5nZXRGaWxlKGZpbGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNsdXNpdmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsZUJ5QWJzb2x1dGVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHBhdGggPSB1dGlscy50cmFuc2Zvcm1QbGF0Zm9ybVBhdGgocGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2VsZi5fcmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTC5jYWxsKHdpbmRvdywgcGF0aCwgcmVzb2x2ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09IEZpbGVFcnJvci5OT1RfRk9VTkRfRVJSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjcmVhdGVEaXJlY3Rvcnk6IGZ1bmN0aW9uIChkaXJlY3RvcnkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzRGlyZWN0b3J5KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXREaXJlY3RvcnlXcmFwKGRpcmVjdG9yeSwgZGlyZWN0b3J5RW50cnksIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGNsdXNpdmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuYW1lRmlsZTogZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5LCBmaWxlRW50cnksIGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZpbGVFbnRyeS5tb3ZlVG8oZGlyZWN0b3J5RW50cnksIGZpbGVuYW1lLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldERpcmVjdG9yeVdyYXA6IGZ1bmN0aW9uIChkaXJlY3RvcnksIGRpcmVjdG9yeUVudHJ5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRpcmVjdG9yeUVudHJ5LmdldERpcmVjdG9yeShkaXJlY3RvcnksIG9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRm9sZGVyV3JhcDogZnVuY3Rpb24gKGZpbGVzRGlyRW50cnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZmlsZXNEaXJFbnRyeS5yZW1vdmVSZWN1cnNpdmVseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRXcml0ZXJXcmFwOiBmdW5jdGlvbiAoZmlsZUVudHJ5LCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGZpbGVFbnRyeS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24gKGZpbGVXcml0ZXIpIHtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLm9ud3JpdGVlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci5vbmVycm9yID0gcmVqZWN0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGJiID0gbmV3IEJsb2IoW2NvbnRlbnRdKTtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLndyaXRlKGJiKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB3cml0ZVRleHQ6IGZ1bmN0aW9uIChmaWxlTmFtZSwgdGV4dCwgcGF0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBmaWxlSGFuZGxlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzRGlyZWN0b3J5KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZURpcmVjdG9yeShwYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0b3J5RW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkaXJlY3RvcnlFbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldEZpbGUoZmlsZU5hbWUsIGRpcmVjdG9yeUVudHJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZmlsZUhhbmRsZSA9IGZpbGVFbnRyeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi53cml0ZVRleHRUb0ZpbGUoZmlsZUVudHJ5LCB0ZXh0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgIGlzIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb3Jkb3ZhIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3RhbmRhcmQgRmlsZVRyYW5zZmVyIGZpbGVFbnRyeVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlSGFuZGxlLm5hdGl2ZVVSTCB8fCBmaWxlSGFuZGxlLnRvVVJMKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NTgzMzYzL2dldC1iYXNlNjQtZnJvbS1pbWFnZXVyaS13aXRoLXBob25lZ2FwXG4gICAgcmVhZEZpbGVBc0Jhc2U2NDogZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodXRpbHMuYXJyYXlCdWZmZXJUb0Jhc2U2NChldnQudGFyZ2V0LnJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkZpbGVTdG9yZTsiLCJ2YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XG52YXIgUmVxdWVzdE9wdGlvbnNCdWlsZGVyID0gcmVxdWlyZSgnLi4vcXVlcnkvUmVxdWVzdE9wdGlvbnNCdWlsZGVyJyk7XG52YXIgcnN2cCA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLnJzdnA7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcbnZhciBpZEZpZWxkID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuaWRGaWVsZDtcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlJyk7XG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xudmFyIEV2ZXJsaXZlRXJyb3JzID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3JzO1xudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gbWVyZ2VSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXMsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3Iga2VuZG8gb2JzZXJ2YWJsZSBhcnJheVxuICAgICAgICAgICAgaWYgKF8uaXNBcnJheShkYXRhKSB8fCB0eXBlb2YgZGF0YS5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBfLmV4dGVuZChpdGVtLCBhdHRyc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgXy5leHRlbmQoZGF0YSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWNjZXNzKHJlcywgcmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlVXBkYXRlUmVzdWx0RGF0YShkYXRhLCBzdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRBdCA9IHJlcy5Nb2RpZmllZEF0O1xuICAgICAgICAgICAgZGF0YS5Nb2RpZmllZEF0ID0gbW9kaWZpZWRBdDtcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRGF0YVxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyB0aGF0IHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFsbCBDUlVEIG9wZXJhdGlvbnMgdG8gYSBnaXZlbiB7e3NpdGUuYnN9fSBkYXRhIHR5cGUuIENvdmVycyBhZHZhbmNlZCBzY2VuYXJpb3Mgd2l0aCBjdXN0b20gaGVhZGVycyBhbmQgc3BlY2lhbCBzZXJ2ZXItc2lkZSBmdW5jdGlvbmFsaXR5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR1cFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhKHNldHVwLCBjb2xsZWN0aW9uTmFtZSwgb2ZmbGluZVN0b3JhZ2UsIGV2ZXJsaXZlKSB7XG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbGxlY3Rpb25OYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlID0gb2ZmbGluZVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuZXZlcmxpdmUgPSBldmVybGl2ZTtcbiAgICB9XG5cblxuICAgIERhdGEucHJvdG90eXBlID0ge1xuICAgICAgICBfaXNPbmxpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlID8gdGhpcy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZSgpIDogdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0T2ZmbGluZUNyZWF0ZURhdGE6IGZ1bmN0aW9uIChxdWVyeSwgcmVxdWVzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgY3JlYXRlRGF0YTtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocXVlcnkuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RUb0NyZWF0ZSA9IF8uZXh0ZW5kKHF1ZXJ5LmRhdGFbaV0sIHJlcXVlc3RSZXNwb25zZS5yZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYXRhLnB1c2gob2JqZWN0VG9DcmVhdGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gXy5leHRlbmQocXVlcnkuZGF0YSwgcmVxdWVzdFJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEYXRhO1xuICAgICAgICB9LFxuICAgICAgICBfYXBwbHlPZmZsaW5lOiBmdW5jdGlvbiAocXVlcnksIHJlcXVlc3RSZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGF1dG9TeW5jRW5hYmxlZCA9IHRoaXMub2ZmbGluZVN0b3JhZ2UgJiYgdGhpcy5vZmZsaW5lU3RvcmFnZS5zZXR1cC5hdXRvU3luYztcbiAgICAgICAgICAgIGlmIChhdXRvU3luY0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHF1ZXJ5Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZEJ5SWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3luY1JlYWRRdWVyeSA9IG5ldyBEYXRhUXVlcnkoXy5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdFJlc3BvbnNlLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkoc3luY1JlYWRRdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZURhdGEgPSB0aGlzLl9nZXRPZmZsaW5lQ3JlYXRlRGF0YShxdWVyeSwgcmVxdWVzdFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVRdWVyeSA9IG5ldyBEYXRhUXVlcnkoXy5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3JlYXRlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkoY3JlYXRlUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5pc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkuTW9kaWZpZWRBdCA9IHJlcXVlc3RSZXNwb25zZS5Nb2RpZmllZEF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LmlzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkocXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBfLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBNb2RpZmllcyB3aGV0aGVyIHRoZSBxdWVyeSBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLlxuICAgICAgICAgKiBEZWZhdWx0IGlzIHRydWUuXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBvZmZsaW5lU3RvcmFnZSBpcyBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0gd29ya09mZmxpbmVcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XG4gICAgICAgICAqICovXG4gICAgICAgIHVzZU9mZmxpbmU6IGZ1bmN0aW9uICh1c2VPZmZsaW5lKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaW5nbGUgdmFsdWUgaXMgZXhwZWN0ZWQgaW4gdXNlT2ZmbGluZSgpIHF1ZXJ5IG1vZGlmaWVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCd1c2VPZmZsaW5lJywgdXNlT2ZmbGluZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTeW5jOiBmdW5jdGlvbiAoaXNTeW5jKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaW5nbGUgdmFsdWUgaXMgZXhwZWN0ZWQgaW4gaXNTeW5jKCkgcXVlcnkgbW9kaWZpZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ2lzU3luYycsIGlzU3luYyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBpbnZva2UgdGhlIHt7QGxpbmsgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmhhc0F1dGhlbnRpY2F0aW9uUmVxdWlyZW1lbnR9fS5cbiAgICAgICAgICogRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgICAgICogT25seSB2YWxpZCB3aGVuIGF1dGhlbnRpY2F0aW9uIG1vZHVsZSBoYXMgYW4gb25BdXRoZW50aWNhdGlvblJlcXVpcmVkIGZ1bmN0aW9uIC5cbiAgICAgICAgICogQHBhcmFtIHNraXBBdXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhfVxuICAgICAgICAgKiAqL1xuICAgICAgICBza2lwQXV0aDogZnVuY3Rpb24gKHNraXBBdXRoKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaW5nbGUgdmFsdWUgaXMgZXhwZWN0ZWQgaW4gc2tpcEF1dGgoKSBxdWVyeSBtb2RpZmllcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbignc2tpcEF1dGgnLCBza2lwQXV0aCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBiZSBhcHBsaWVkIG9mZmxpbmUsIGlmIHRoZSBzZGsgaXMgY3VycmVudHkgd29ya2luZyBvbmxpbmUuXG4gICAgICAgICAqIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICAgICAgICogT25seSB2YWxpZCB3aGVuIG9mZmxpbmVTdG9yYWdlIGlzIGVuYWJsZWQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSBhcHBseU9mZmxpbmVcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XG4gICAgICAgICAqICovXG4gICAgICAgIGFwcGx5T2ZmbGluZTogZnVuY3Rpb24gKGFwcGx5T2ZmbGluZSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2luZ2xlIHZhbHVlIGlzIGV4cGVjdGVkIGluIGFwcGx5T2ZmbGluZSgpIHF1ZXJ5IG1vZGlmaWVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdhcHBseU9mZmxpbmUnLCBhcHBseU9mZmxpbmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGFkZGl0aW9uYWwgbm9uLXN0YW5kYXJkIEhUVFAgaGVhZGVycyBpbiB0aGUgY3VycmVudCBkYXRhIHJlcXVlc3QuIFNlZSBbTGlzdCBvZiBOb24tU3RhbmRhcmQgSFRUUCBIZWFkZXJzXXt7JSBzbHVnIHJlc3QtYXBpLWhlYWRlcnN9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnMgQWRkaXRpb25hbCBoZWFkZXJzIHRvIGJlIHNlbnQgd2l0aCB0aGUgZGF0YSByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIHdpdGhIZWFkZXJzOiBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbignaGVhZGVycycsIGhlYWRlcnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhbiBleHBhbmQgZXhwcmVzc2lvbiB0byBiZSB1c2VkIGluIHRoZSBkYXRhIHJlcXVlc3QuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBjb21wbGV4IGRhdGEgc2V0cyB1c2luZyBhIHNpbmdsZSBxdWVyeSBiYXNlZCBvbiByZWxhdGlvbnMgYmV0d2VlbiBkYXRhIHR5cGVzLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZXhwYW5kRXhwcmVzc2lvbiBBbiBbZXhwYW5kIGV4cHJlc3Npb25dKHslIHNsdWcgZmVhdHVyZXMtZGF0YS1yZWxhdGlvbnMtZGVmaW5pbmctZXhwYW5kICV9KSBkZWZpbml0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHZhciBleHBhbmRIZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRXhwYW5kJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kRXhwcmVzc2lvbilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSGVhZGVycyhleHBhbmRIZWFkZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzZXMgYSBxdWVyeSB3aXRoIGFsbCBvZiBpdHMgb3B0aW9ucy4gQXBwbGllcyB0aGUgb3BlcmF0aW9uIG9ubGluZS9vZmZsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVF1ZXJ5fSBxdWVyeSBUaGUgcXVlcnkgdG8gcHJvY2Vzc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFRdWVyeX0gcXVlcnlcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzRGF0YVF1ZXJ5OiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIG9mZmxpbmVTdG9yYWdlRW5hYmxlZCA9IHRoaXMuZXZlcmxpdmUuX2lzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKCk7XG4gICAgICAgICAgICBxdWVyeS51c2VPZmZsaW5lID0gb2ZmbGluZVN0b3JhZ2VFbmFibGVkID8gIXRoaXMuZXZlcmxpdmUuaXNPbmxpbmUoKSA6IGZhbHNlO1xuICAgICAgICAgICAgcXVlcnkuYXBwbHlPZmZsaW5lID0gb2ZmbGluZVN0b3JhZ2VFbmFibGVkO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfLmRlZmF1bHRzKHRoaXMub3B0aW9ucywgcXVlcnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFxdWVyeS5za2lwQXV0aCAmJiB0aGlzLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uICYmIHRoaXMuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uRXJyb3IgPSBfLndyYXAocXVlcnkub25FcnJvciwgZnVuY3Rpb24gKGVycm9yRnVuYywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZFRva2VuLmNvZGUgfHwgZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmV4cGlyZWRUb2tlbi5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2hlbkF1dGhlbnRpY2F0ZWRQcm9taXNlID0gc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5fZW5zdXJlQXV0aGVudGljYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVlcnkubm9SZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckZ1bmMuY2FsbChzZWxmLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHdlIGFyZSBjdXJyZW50bHkgYXV0aGVudGljYXRpbmcsIHF1ZXVlIHRoZSBkYXRhIHF1ZXJ5IGFmdGVyIHdlIGhhdmUgbG9nZ2VkIGluXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aGVuQXV0aGVudGljYXRlZFByb21pc2UgPSBzZWxmLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLl9lbnN1cmVBdXRoZW50aWNhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5Lm5vUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuQXV0aGVudGljYXRlZFByb21pc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoIXF1ZXJ5LmlzU3luYyAmJiB0aGlzLm9mZmxpbmVTdG9yYWdlICYmIHRoaXMub2ZmbGluZVN0b3JhZ2UuaXNTeW5jaHJvbml6aW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIEV2ZXJsaXZlRXJyb3JzLnN5bmNJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXF1ZXJ5LnVzZU9mZmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxTdWNjZXNzID0gcXVlcnkub25TdWNjZXNzO1xuICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwcGx5T2ZmbGluZShxdWVyeSwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3VjY2Vzcy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFN1Y2Nlc3MuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5ID0gUmVxdWVzdE9wdGlvbnNCdWlsZGVyW3F1ZXJ5Lm9wZXJhdGlvbl07XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gZ2V0UmVxdWVzdE9wdGlvbnNGcm9tUXVlcnkocXVlcnkpO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5zZXR1cCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgYXBwbHlPZmZsaW5lIG11c3QgYmUgZmFsc2Ugd2hlbiB3b3JraW5nIG9mZmxpbmUuJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYub2ZmbGluZVN0b3JhZ2UucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkub25TdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVyci5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXZlcmxpdmVFcnJvcihlcnIubWVzc2FnZSwgRXZlcmxpdmVFcnJvcnMuZ2VuZXJhbERhdGFiYXNlRXJyb3IuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXVlcnkub25FcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IG9wdGlvbnM6IHsgcmVxdWVzdFNldHRpbmdzOiB7IGV4ZWN1dGVTZXJ2ZXJDb2RlOiBmYWxzZSB9IH0uIHBvd2VyIGZpZWxkcyBxdWVyaWVzIGNvdWxkIGJlIGFkZGVkIHRvIHRoYXQgb3B0aW9ucyBhcmd1bWVudFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhbGwgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiB0aGUgaXRlbXMgYmFzZWQgb24gdmFyaW91cyBmaWx0ZXJpbmcgY3JpdGVyaWEuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIGdldFxuICAgICAgICAgKiBAbmFtZSBnZXRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFsbCBkYXRhIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGEgc3Vic2V0IG9mIHRoZSBpdGVtcyBiYXNlZCBvbiB2YXJpb3VzIGZpbHRlcmluZyBjcml0ZXJpYS5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICAgICAqIEBuYW1lIGdldFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NDYixcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JDYlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPIGhhbmRsZSBvcHRpb25zXG4gICAgICAgIC8vIFRPRE8gdGhpbmsgdG8gcGFzcyB0aGUgaWQgYXMgYSBmaWx0ZXJcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIGRhdGEgaXRlbSBieSBJRC5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QnlJZFxuICAgICAgICAgKiBAbmFtZSBnZXRCeUlkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgaXRlbS5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFuIGl0ZW0gYnkgSUQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIGdldEJ5SWRcbiAgICAgICAgICogQG5hbWUgZ2V0QnlJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqICovXG4gICAgICAgIGdldEJ5SWQ6IGZ1bmN0aW9uIChpZCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkLFxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzQ2IsXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiB0aGUgZGF0YSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICAgICAqIEBuYW1lIGNvdW50XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY291bnQgb2YgdGhlIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlci5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgY291bnRcbiAgICAgICAgICogQG5hbWUgY291bnRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGNvdW50OiBmdW5jdGlvbiAoZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNlc3NDYiwgZXJyb3JDYikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jb3VudCxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNlc3NDYixcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JDYlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGRhdGEgaXRlbS5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICAgICAqIEBuYW1lIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSBJdGVtIG9yIGl0ZW1zIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaXRlbS5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICAgICAqIEBuYW1lIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gZGF0YSBUaGUgaXRlbSBvciBpdGVtcyB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IG1lcmdlUmVzdWx0RGF0YShkYXRhLCBzdWNjZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhbGwgb2JqZWN0cyB0aGF0IG1hdGNoIGEgZmlsdGVyIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggYSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBleHByZXNzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcbiAgICAgICAgICogQG5hbWUgcmF3VXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVPYmplY3QgVXBkYXRlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYW4gb2JqZWN0IGJ5IElEIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlZE9iamVjdCBVcGRhdGVkIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBpdGVtLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYW4gb2JqZWN0IGJ5IElEIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgcmF3VXBkYXRlXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZWQgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICByYXdVcGRhdGU6IGZ1bmN0aW9uIChhdHRycywgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgY2FzZSBpbiB3aGljaCByZXBsYWNlID0gdHJ1ZSBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc2luZ2xlLCByZXBsYWNlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgZGF0YVtyZXBsYWNlID8gJyRyZXBsYWNlJyA6ICckc2V0J10gPSBhdHRycztcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB1cGRhdGUgaXMgZm9yIGEgc2luZ2xlIGl0ZW0gLSBtZXJnZSB0aGUgdXBkYXRlIHJlc3VsdCBhbmQgYWRkIHRoZSBNb2RpZmllZEF0IGZpZWxkIHRvIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICB2YXIgb25TdWNjZXNzID0gc2luZ2xlID8gbWVyZ2VVcGRhdGVSZXN1bHREYXRhKGF0dHJzLCBzdWNjZXNzKSA6IHN1Y2Nlc3M7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy51cGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNpbmdsZSA/IGF0dHJzW2lkRmllbGRdIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHRha2VzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBib3RoIHRoZSBkYXRhIGl0ZW0gdG8gYmUgdXBkYXRlZCBhbmQgdGhlIHVwZGF0ZWQgdmFsdWVzLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTaW5nbGVcbiAgICAgICAgICogQG5hbWUgdXBkYXRlU2luZ2xlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgd2lsbCBiZSB1cGRhdGVkLiBOb3RlOiB0aGUgSUQgcHJvcGVydHkgb2YgdGhlIGl0ZW0gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBpdGVtIHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTaW5nbGVcbiAgICAgICAgICogQG5hbWUgdXBkYXRlU2luZ2xlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBUaGUgaXRlbSB0aGF0IHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVTaW5nbGU6IGZ1bmN0aW9uIChtb2RlbCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobW9kZWwsIG51bGwsIHRydWUsIGZhbHNlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIGl0ZW1zIHRoYXQgbWF0Y2ggYSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBvYmplY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHVwZGF0ZU9iamVjdCBUaGUgdXBkYXRlIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGFsbCBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHVwZGF0ZSBvYmplY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsIFRoZSB1cGRhdGUgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobW9kZWwsIGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobW9kZWwsIGZpbHRlciwgZmFsc2UsIGZhbHNlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiAoYXR0cnMsIGZpbHRlciwgc2luZ2xlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBzaW5nbGUgPyBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGUgOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzaW5nbGUgPyBhdHRyc1tpZEZpZWxkXSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIGEgc2luZ2xlIGRhdGEgaXRlbSBieSBJRC5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVNpbmdsZVxuICAgICAgICAgKiBAbmFtZSBkZXN0cm95U2luZ2xlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIE9iamVjdCBjb250YWluaW5nIHRoZSBpdGVtIElEIHRvIGJlIGRlbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0gYnkgSUQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIGRlc3Ryb3lTaW5nbGVcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVNpbmdsZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9kZWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGl0ZW0gSUQgdG8gYmUgZGVsZXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3lTaW5nbGU6IGZ1bmN0aW9uIChtb2RlbCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KG1vZGVsLCBudWxsLCB0cnVlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgYWxsIGRhdGEgaXRlbXMgdGhhdCBtYXRjaCBhIGZpbHRlci5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAgICAgKiBAbmFtZSBkZXN0cm95XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhbGwgaXRlbXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICAgICAqIEBuYW1lIGRlc3Ryb3lcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveShudWxsLCBmaWx0ZXIsIGZhbHNlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIEFjY2VzcyBDb250cm9sIExpc3QgKEFDTCkgb2YgYSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcbiAgICAgICAgICogQG5hbWUgc2V0QWNsXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2wgVGhlIGFjbCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIEFjY2VzcyBDb250cm9sIExpc3QgKEFDTCkgb2YgYSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcbiAgICAgICAgICogQG5hbWUgc2V0QWNsXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2wgVGhlIGFjbCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIEFDTCB3aWxsIGJlIHVwZGF0ZWQuIE5vdGU6IHRoZSBJRCBwcm9wZXJ0eSBvZiB0aGUgaXRlbSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGl0ZW0gd2lsbCBiZSBkZWxldGVkLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uUGFyYW1ldGVycyBBbiBvYmplY3Qgd2hpY2ggYWNjZXB0cyBvcGVyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIEFjY2VzcyBDb250cm9sIExpc3QgKEFDTCkgb2YgYSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcbiAgICAgICAgICogQG5hbWUgc2V0QWNsXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2wgVGhlIGFjbCBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhbiBpdGVtIHdpdGggYSBzcGVjaWZpZWQgSUQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNldEFjbFxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGFjbCBUaGUgYWNsIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIHNldEFjbDogZnVuY3Rpb24gKGFjbCwgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRBY2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZTogUmVxdWVzdC5wYXJzZXJzLnNpbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2w6IGFjbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRPd25lclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNsIFRoZSBuZXcgb3duZXIgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIG93bmVyIHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgb2YgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXG4gICAgICAgICAqIEBuYW1lIHNldE93bmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2wgVGhlIG5ldyBvd25lciBJRC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gd2hvc2Ugb3duZXIgd2lsbCBiZSB1cGRhdGVkLiBOb3RlOiB0aGUgSUQgcHJvcGVydHkgb2YgdGhlIGl0ZW0gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBpdGVtIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wZXJhdGlvblBhcmFtZXRlcnMuc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wZXJhdGlvblBhcmFtZXRlcnMudXNlT2ZmbGluZV0gV2hldGhlciB0byBpbnZva2UgdGhlIG9wZXJhdGlvbiBvbiB0aGUgb2ZmbGluZSBzdG9yYWdlLiBEZWZhdWx0IGlzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIEV2ZXJsaXZlIGluc3RhbmNlLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcGVyYXRpb25QYXJhbWV0ZXJzLmFwcGx5T2ZmbGluZT10cnVlXSBJZiB3b3JraW5nIG9ubGluZSwgd2hldGhlciB0byBhbHNvIGFwcGx5IHRoZSBvcGVyYXRpb24gb24gdGhlIGxvY2FsIHN0b3JhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgb2YgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXG4gICAgICAgICAqIEBuYW1lIHNldE93bmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lcklkIFRoZSBuZXcgb3duZXIgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgb2YgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXG4gICAgICAgICAqIEBuYW1lIHNldE93bmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lcklkIFRoZSBuZXcgb3duZXIgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICAgICAqL1xuICAgICAgICBzZXRPd25lcjogZnVuY3Rpb24gKG93bmVySWQsIGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0T3duZXIsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgT3duZXI6IG93bmVySWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHdpbGwgY3JlYXRlIG9yIHVwZGF0ZSB0aGUgaXRlbSBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBuZXcgb3IgZXhpc3RpbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVcbiAgICAgICAgICogQG5hbWUgc2F2ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIHNhdmVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmVzIHRoZSBwcm92aWRlZCBkYXRhIGl0ZW0uIFRoaXMgb3BlcmF0aW9uIHdpbGwgY3JlYXRlIG9yIHVwZGF0ZSB0aGUgaXRlbSBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBuZXcgb3IgZXhpc3RpbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVcbiAgICAgICAgICogQG5hbWUgc2F2ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbW9kZWwgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBzYXZlZC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uIChtb2RlbCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpc05ldyA9IHRoaXMuaXNOZXcobW9kZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNhdmVTdWNjZXNzKHJlcykge1xuICAgICAgICAgICAgICAgICAgICByZXMudHlwZSA9IGlzTmV3ID8gJ2NyZWF0ZScgOiAndXBkYXRlJztcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhyZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNhdmVFcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnR5cGUgPSBpc05ldyA/ICdjcmVhdGUnIDogJ3VwZGF0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNyZWF0ZShtb2RlbCwgc2F2ZVN1Y2Nlc3MsIHNhdmVFcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlU2luZ2xlKG1vZGVsLCBzYXZlU3VjY2Vzcywgc2F2ZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0gaXMgbmV3IG9yIG5vdC5cbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIG1vZGVsIEl0ZW0gdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNOZXc6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBtb2RlbFtpZEZpZWxkXSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIERhdGE7XG59KCkpO1xuIiwiLyoqXG4gKiBAY2xhc3MgRmlsZXNcbiAqIEBwcm90ZWN0ZWRcbiAqIEBleHRlbmRzIERhdGFcbiAqL1xuXG52YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzLmFkZEZpbGVzRnVuY3Rpb25zID0gZnVuY3Rpb24gYWRkRmlsZXNGdW5jdGlvbnMobnMpIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBlbmRwb2ludCBmb3IgdXBsb2FkaW5nIGEgZmlsZS4gSXQgaXMgc3BlY2lmaWMgdG8gZWFjaCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGFwcC5cbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBnZXRVcGxvYWRVcmxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5zLmdldFVwbG9hZFVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApICsgdGhpcy5jb2xsZWN0aW9uTmFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkb3dubG9hZCBVUkwgZm9yIGEgZmlsZS5cbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBnZXREb3dubG9hZFVybFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSB7QGxpbmsgRmlsZXMuZ2V0RG93bmxvYWRVcmxCeUlkfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHVybCBUaGUgZG93bmxvYWQgVVJMLlxuICAgICAqL1xuICAgIG5zLmdldERvd25sb2FkVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRVcmwodGhpcy5zZXR1cCkgKyB0aGlzLmNvbGxlY3Rpb25OYW1lICsgJy8nICsgZmlsZUlkICsgJy9Eb3dubG9hZCc7XG4gICAgfTtcblxuICAgIG5zLl9nZXRVcGRhdGVVcmwgPSBmdW5jdGlvbiAoZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb25OYW1lICsgJy8nICsgZmlsZUlkICsgJy9Db250ZW50JztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gZW5kcG9pbnQgZm9yIHVwZGF0aW5nIGEgZmlsZS4gSXQgaXMgc3BlY2lmaWMgdG8gZWFjaCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGFwcC5cbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBnZXRVcGRhdGVVcmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB1cmwgVGhlIHVwZGF0ZSBVUkwuXG4gICAgICovXG4gICAgbnMuZ2V0VXBkYXRlVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRVcmwodGhpcy5zZXR1cCkgKyB0aGlzLl9nZXRVcGRhdGVVcmwoZmlsZUlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIGZpbGUncyBjb250ZW50XG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgdXBkYXRlQ29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgRmlsZSBJRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZSBUaGUgZmlsZSBtZXRhZGF0YSBhbmQgdGhlIGJhc2U2NCBlbmNvZGVkIGZpbGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIG5zLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoZmlsZUlkLCBmaWxlLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmZpbGVzVXBkYXRlQ29udGVudCxcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFzc2VkIGZpbGUgY29udGVudCBpcyBiYXNlNjQgZW5jb2RlZFxuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGUsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZG93bmxvYWQgVVJMIGZvciBhIGZpbGUgYnkgSUQuXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgZ2V0RG93bmxvYWRVcmxCeUlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBGaWxlIElELlxuICAgICAqIEBwYXJhbSBvcGVyYXRpb25QYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIG5zLmdldERvd25sb2FkVXJsQnlJZCA9IGZ1bmN0aW9uIChmaWxlSWQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNHZXREb3dubG9hZFVybEJ5SWQsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGRhdGEucmVzdWx0LlVyaSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcbn07IiwiLyoqXG4gKiBAY2xhc3MgVXNlcnNcbiAqIEBleHRlbmRzIERhdGFcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcbnZhciBndWFyZFVuc2V0ID0gdXRpbHMuZ3VhcmRVbnNldDtcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcblxubW9kdWxlLmV4cG9ydHMuYWRkVXNlcnNGdW5jdGlvbnMgPSBmdW5jdGlvbiBhZGRVc2Vyc0Z1bmN0aW9ucyhucywgZXZlcmxpdmUpIHtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyB1c2VyIHdpdGggdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXG4gICAgICogQG5hbWUgcmVnaXN0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIG5ldyB1c2VyJ3MgdXNlcm5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBuZXcgdXNlcidzIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1c2VySW5mbyBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciB0aGUgdXNlciAoZXguIERpc3BsYXlOYW1lLCBFbWFpbCwgZXRjLilcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQuXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcbiAgICAgKiBAbmFtZSByZWdpc3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgbmV3IHVzZXIncyB1c2VybmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIG5ldyB1c2VyJ3MgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIGF0dHJzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgYXR0cnMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIGd1YXJkVW5zZXQodXNlcm5hbWUsICd1c2VybmFtZScpO1xuICAgICAgICBndWFyZFVuc2V0KHBhc3N3b3JkLCAncGFzc3dvcmQnKTtcbiAgICAgICAgdmFyIHVzZXIgPSB7XG4gICAgICAgICAgICBVc2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICBQYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgfTtcbiAgICAgICAgXy5leHRlbmQodXNlciwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodXNlciwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHRoYXQgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdG8gdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLLiBUaGUgc3VjY2VzcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB7QGxpbmsgVXNlcnMuUmVzdWx0VHlwZXMuY3VyZW50VXNlclJlc3VsdH0uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgY3VycmVudFVzZXJcbiAgICAgKiBAbmFtZSBjdXJyZW50VXNlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB0aGF0IGlzIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHRvIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy4gVGhlIHN1Y2Nlc3MgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGgge0BsaW5rIFVzZXJzLlJlc3VsdFR5cGVzLmN1cmVudFVzZXJSZXN1bHR9LlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRVc2VyXG4gICAgICogQG5hbWUgY3VycmVudFVzZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgbnMuY3VycmVudFVzZXIgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSBzZWxmLmV2ZXJsaXZlLl9pc09mZmxpbmVTdG9yYWdlRW5hYmxlZCgpICYmIHNlbGYuZXZlcmxpdmUuaXNPZmZsaW5lKCkgPyBzZWxmLmV2ZXJsaXZlLnNldHVwLnByaW5jaXBhbElkIDogJ21lJztcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ21lJyAmJiAhc2VsZi5ldmVybGl2ZS5zZXR1cC50b2tlbiAmJiAhc2VsZi5ldmVybGl2ZS5zZXR1cC5tYXN0ZXJLZXkgfHwgIWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmdldEJ5SWQoaWQpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5yZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHtyZXN1bHQ6IHJlcy5yZXN1bHR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uICYmIHNlbGYuZXZlcmxpdmUuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyLmNvZGUgPT09IDYwMSkgeyAvLyBpbnZhbGlkIHJlcXVlc3QsIGkuZS4gdGhlIGFjY2VzcyB0b2tlbiBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHtyZXN1bHQ6IG51bGx9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gODAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihFdmVybGl2ZUVycm9ycy5pbnZhbGlkVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcGFzc3dvcmQgb2YgYSB1c2VyLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhc3N3b3JkXG4gICAgICogQG5hbWUgY2hhbmdlUGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFzc3dvcmQgVGhlIHVzZXIncyBuZXcgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwVG9rZW5zIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciB0b2tlbnMgd2lsbCBiZSBwcmVzZXJ2ZWQgZXZlbiBhZnRlciB0aGUgcGFzc3dvcmQgY2hhbmdlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcGFzc3dvcmQgb2YgYSB1c2VyLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhc3N3b3JkXG4gICAgICogQG5hbWUgY2hhbmdlUGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFzc3dvcmQgVGhlIHVzZXIncyBuZXcgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwVG9rZW5zIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciB0b2tlbnMgd2lsbCBiZSBwcmVzZXJ2ZWQgZXZlbiBhZnRlciB0aGUgcGFzc3dvcmQgY2hhbmdlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy5jaGFuZ2VQYXNzd29yZCA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIG5ld1Bhc3N3b3JkLCBrZWVwVG9rZW5zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gXy53cmFwKHN1Y2Nlc3MsIGZ1bmN0aW9uIChzdWNjZXNzLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBucy5jbGVhckF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcyhkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyQ2hhbmdlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBVc2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIFBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgTmV3UGFzc3dvcmQ6IG5ld1Bhc3N3b3JkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBrZWVwVG9rZW5zOiBrZWVwVG9rZW5zXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSlcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpblxuICAgICAqIEBuYW1lIGxvZ2luXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW59XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMb2dzIGluIGEgdXNlciB1c2luZyBhIHVzZXJuYW1lIGFuZCBhIHBhc3N3b3JkIHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLiBBbGwgcmVxdWVzdHMgaW5pdGlhdGVkIGJ5IHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlIHdpbGwgYmUgYXV0aGVudGljYXRlZCB3aXRoIHRoYXQgdXNlcidzIGNyZWRlbnRpYWxzLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luXG4gICAgICogQG5hbWUgbG9naW5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dpbn1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgbnMubG9naW4gPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW4odXNlcm5hbWUsIHBhc3N3b3JkLCBzdWNjZXNzLCBlcnJvcik7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9nIG91dCB0aGUgdXNlciB3aG8gaXMgY3VycmVudGx5IGxvZ2dlZCBpbi5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dvdXRcbiAgICAgKiBAbmFtZSBsb2dvdXRcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dvdXR9XG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMb2cgb3V0IHRoZSB1c2VyIHdobyBpcyBjdXJyZW50bHkgbG9nZ2VkIGluLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxuICAgICAqIEBuYW1lIGxvZ291dFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ291dH1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgbnMubG9nb3V0ID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dvdXQoc3VjY2VzcywgZXJyb3IpO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEZhY2Vib29rXG4gICAgICogQG5hbWUgbG9naW5XaXRoRmFjZWJvb2tcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhGYWNlYm9va31cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhGYWNlYm9va1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aEZhY2Vib29rfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLmxvZ2luV2l0aEZhY2Vib29rID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoRmFjZWJvb2soYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEZhY2Vib29rXG4gICAgICogQG5hbWUgbGlua1dpdGhGYWNlYm9va1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEZhY2Vib29rIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMaW5rcyBhIEJhY2tlbmQgU2VydmljZXMgdXNlciB3aXRoIGEgRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoRmFjZWJvb2tcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEZhY2Vib29rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgRmFjZWJvb2sgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBhIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLmxpbmtXaXRoRmFjZWJvb2sgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xuICAgICAgICAgICAgUHJvdmlkZXI6ICdGYWNlYm9vaycsXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEZhY2Vib29rIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21GYWNlYm9va1xuICAgICAqIEBuYW1lIHVubGlua0Zyb21GYWNlYm9va1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBGYWNlYm9vayB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tRmFjZWJvb2tcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tRmFjZWJvb2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLnVubGlua0Zyb21GYWNlYm9vayA9IGZ1bmN0aW9uICh1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdGYWNlYm9vaycsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEFERlMgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhBREZTXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoQURGU31cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEFERlMgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhBREZTXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoQURGU31cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLmxvZ2luV2l0aEFERlMgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhBREZTKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYW4gQURGUyBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbGlua1dpdGhBREZTXG4gICAgICogQG5hbWUgbGlua1dpdGhBREZTXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgQURGUyBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhbiBBREZTIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEFERlNcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEFERlNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBBREZTIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLmxpbmtXaXRoQURGUyA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XG4gICAgICAgICAgICBQcm92aWRlcjogJ0FERlMnLFxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBucy5fbGlua1dpdGhQcm92aWRlcihpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBBREZTIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21BREZTXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUFERlNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgQURGUyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tQURGU1xuICAgICAqIEBuYW1lIHVubGlua0Zyb21BREZTXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy51bmxpbmtGcm9tQURGUyA9IGZ1bmN0aW9uICh1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdBREZTJywgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoTGl2ZUlEXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoTGl2ZUlEfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgTWljcm9zb2Z0IEFjY291bnQgYWNjZXNzIHRva2VuLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxuICAgICAqIEBuYW1lIGxvZ2luV2l0aExpdmVJRFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aExpdmVJRH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gTWljcm9zb2Z0IEFjY291bnQgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy5sb2dpbldpdGhMaXZlSUQgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhMaXZlSUQoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIE1pY3Jvc29mdCBBY2NvdW50IGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aExpdmVJRFxuICAgICAqIEBuYW1lIGxpbmtXaXRoTGl2ZUlEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgTWljcm9zb2Z0IEFjY291bnQgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBNaWNyb3NvZnQgQWNjb3VudCBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbGlua1dpdGhMaXZlSURcbiAgICAgKiBAbmFtZSBsaW5rV2l0aExpdmVJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIE1pY3Jvc29mdCBBY2NvdW50IGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLmxpbmtXaXRoTGl2ZUlEID0gZnVuY3Rpb24gKHVzZXJJZCwgYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnTGl2ZUlEJyxcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgTWljcm9zb2Z0IEFjY291bnQgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21MaXZlSURcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tTGl2ZUlEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIE1pY3Jvc29mdCBBY2NvdW50IGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tTGl2ZUlEXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUxpdmVJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXG4gICAgICovXG4gICAgbnMudW5saW5rRnJvbUxpdmVJRCA9IGZ1bmN0aW9uICh1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdMaXZlSUQnLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoR29vZ2xlfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBHb29nbGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXG4gICAgICogQG5hbWUgbG9naW5XaXRoR29vZ2xlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAc2VlIFthdXRoZW50aWNhdGlvbi5sb2dpbl17QGxpbmsgLi4vQXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24ubG9naW5XaXRoR29vZ2xlfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBHb29nbGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy5sb2dpbldpdGhHb29nbGUgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhHb29nbGUoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbGlua1dpdGhHb29nbGVcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEdvb2dsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbGlua1dpdGhHb29nbGVcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEdvb2dsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEdvb2dsZSBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy5saW5rV2l0aEdvb2dsZSA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XG4gICAgICAgICAgICBQcm92aWRlcjogJ0dvb2dsZScsXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tR29vZ2xlXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUdvb2dsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBHb29nbGUgYWNjZXNzIHRva2VuIHRoYXQgaXQgaXMgbGlua2VkIHRvLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Hb29nbGVcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tR29vZ2xlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy51bmxpbmtGcm9tR29vZ2xlID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5zLl91bmxpbmtGcm9tUHJvdmlkZXIoJ0dvb2dsZScsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUd2l0dGVyIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aFR3aXR0ZXJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy5sb2dpbldpdGhUd2l0dGVyID0gZnVuY3Rpb24gKHRva2VuLCB0b2tlblNlY3JldCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aFR3aXR0ZXIodG9rZW4sIHRva2VuU2VjcmV0LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIHRvIGEgVHdpdHRlciB0b2tlbi4gQSBzZWNyZXQgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgbGlua1dpdGhUd2l0dGVyXG4gICAgICogQG5hbWUgbGlua1dpdGhUd2l0dGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUaGUgVHdpdHRlciBzZWNyZXQgdG9rZW4uXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciB0byBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLiAgICAgICAgICogTGlua3MgYSBCYWNrZW5kIFNlcnZpY2VzIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoVHdpdHRlclxuICAgICAqIEBuYW1lIGxpbmtXaXRoVHdpdHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIFR3aXR0ZXIgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVGhlIFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy5saW5rV2l0aFR3aXR0ZXIgPSBmdW5jdGlvbiAodXNlcklkLCB0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnVHdpdHRlcicsXG4gICAgICAgICAgICBUb2tlbjogdG9rZW4sXG4gICAgICAgICAgICBUb2tlblNlY3JldDogdG9rZW5TZWNyZXRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbnMuX2xpbmtXaXRoUHJvdmlkZXIoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbVR3aXR0ZXJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tVHdpdHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBUd2l0dGVyIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXG4gICAgICogQG1ldGhvZCB1bmxpbmtGcm9tVHdpdHRlclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21Ud2l0dGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBucy51bmxpbmtGcm9tVHdpdHRlciA9IGZ1bmN0aW9uICh1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdUd2l0dGVyJywgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIHRoYXQgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgd2lsbCB1c2UgZm9yIGF1dGhvcml6YXRpb24uXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqIEBtZXRob2Qgc2V0QXV0aG9yaXphdGlvblxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSBbYXV0aGVudGljYXRpb24ubG9naW5de0BsaW5rIC4uL0F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uLnNldEF1dGhvcml6YXRpb259XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhdXRob3JpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7RXZlcmxpdmUuVG9rZW5UeXBlfSB0b2tlblR5cGUgVG9rZW4gdHlwZS4gQ3VycmVudGx5IG9ubHkgJ2JlYXJlcicgdG9rZW4gaXMgc3VwcG9ydGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmluY2lwYWxJZCBUaGUgaWQgb2YgdGhlIHVzZXIgdGhhdCBpcyBsb2dnZWQgaW4uXG4gICAgICovXG4gICAgbnMuc2V0QXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIHNldEF1dGhvcml6YXRpb24odG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpIHtcbiAgICAgICAgZXZlcmxpdmUuYXV0aGVudGljYXRpb24uc2V0QXV0aG9yaXphdGlvbih0b2tlbiwgdG9rZW5UeXBlLCBwcmluY2lwYWxJZClcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0aGF0IHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBjdXJyZW50bHkgdXNlcy4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IHRoYW4gbG9nZ2luZyBvdXQsIGJlY2F1c2UgdGhlIGN1cnJlbnQgYXV0aG9yaXphdGlvbiB0b2tlbiBpcyBub3QgaW52YWxpZGF0ZWQuXG4gICAgICogQG1ldGhvZCBjbGVhckF1dGhvcml6YXRpb25cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzZWUgW2F1dGhlbnRpY2F0aW9uLmxvZ2luXXtAbGluayAuLi9BdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5jbGVhckF1dGhvcml6YXRpb259XG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG5zLmNsZWFyQXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQXV0aG9yaXphdGlvbigpIHtcbiAgICAgICAgZXZlcmxpdmUuYXV0aGVudGljYXRpb24uc2V0QXV0aG9yaXphdGlvbihudWxsLCBudWxsLCBudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHJlc2V0UGFzc3dvcmRcbiAgICAgKiBAbmFtZSByZXNldFBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcbiAgICAgKiBAbWV0aG9kIHJlc2V0UGFzc3dvcmRcbiAgICAgKiBAbmFtZSByZXNldFBhc3N3b3JkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG5zLnJlc2V0UGFzc3dvcmQgPSBmdW5jdGlvbiAoZW1haWwsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJSZXNldFBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgRW1haWw6IGVtYWlsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NDYixcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvckNiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIG5zLl9saW5rV2l0aFByb3ZpZGVyID0gZnVuY3Rpb24gKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB1c2VySWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YTogaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXG4gICAgICAgICAgICAgICAgc2tpcEF1dGg6IHRydWUsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgbnMuX3VubGlua0Zyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlck5hbWUsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xuICAgICAgICAgICAgUHJvdmlkZXI6IHByb3ZpZGVyTmFtZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHVzZXJJZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlkZW50aXR5LFxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XG4gICAgfTtcbn07IiwidmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgXyA9IGNvbW1vbi5fO1xudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4vRXZlcmxpdmUnKTtcbnZhciBwbGF0Zm9ybSA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgdXRpbHMgPSB7fTtcblxudXRpbHMuZ3VhcmRVbnNldCA9IGZ1bmN0aW9uIGd1YXJkVW5zZXQodmFsdWUsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9ICdUaGUgJyArIG5hbWUgKyAnIGlzIHJlcXVpcmVkJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcblxudXRpbHMucGFyc2VVdGlsaXRpZXMgPSB7XG4gICAgZ2V0UmV2aXZlcjogZnVuY3Rpb24gKHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcpIHtcbiAgICAgICAgdmFyIGRhdGVQYXJzZXI7XG4gICAgICAgIGlmIChwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nKSB7XG4gICAgICAgICAgICBkYXRlUGFyc2VyID0gdXRpbHMucGFyc2VVdGlsaXRpZXMucGFyc2VJc29EYXRlU3RyaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZVBhcnNlciA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlUGFyc2VyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlSXNvRGF0ZVN0cmluZzogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXihcXGR7NH0pKC0oXFxkezJ9KSgtKFxcZHsyfSkoVChcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KShcXC4oXFxkKykpPyk/KFp8KChcXCt8LSkoXFxkezJ9KTooXFxkezJ9KSkpKT8pKSQvKSkge1xuICAgICAgICAgICAgLy8gRGF0ZVRpbWVcbiAgICAgICAgICAgIHZhciBzZWNvbmRQYXJ0cyA9IG1hdGNoWzEyXTtcbiAgICAgICAgICAgIGlmIChzZWNvbmRQYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChzZWNvbmRQYXJ0cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFBhcnRzID0gTWF0aC5yb3VuZChOdW1iZXIoc2Vjb25kUGFydHMuc3Vic3RyKDAsIDMpICsgJy4nICsgc2Vjb25kUGFydHMuc3Vic3RyKDMpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFBhcnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNlY29uZFBhcnRzIGFyZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgdGhlbiB0d28gb3Igb25lIHplcm9zIHNob3VsZCBiZSBhcHBlbmRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBmb3IgbWlsbGlzZWNvbmRzICgnLjY3JyBtZWFucyA2NzBtcyBub3QgNjdtcylcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUGFydHMgKz0gc2Vjb25kUGFydHMubGVuZ3RoID09PSAyID8gJzAnIDogJzAwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgIERhdGUuVVRDKFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobWF0Y2hbMV0pLCAvLyB5ZWFyXG4gICAgICAgICAgICAgICAgICAgIChOdW1iZXIobWF0Y2hbM10pIC0gMSkgfHwgMCwgLy8gbW9udGhcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzVdKSB8fCAwLCAvLyBkYXlcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzddKSB8fCAwLCAvLyBob3VyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs4XSkgfHwgMCwgLy8gbWludXRlXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFsxMF0pIHx8IDAsIC8vIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIoc2Vjb25kUGFydHMpIHx8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMTNdICYmIG1hdGNoWzEzXSAhPT0gXCJaXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IE51bWJlcihtYXRjaFsxNl0pIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIG0gPSBOdW1iZXIobWF0Y2hbMTddKSB8fCAwO1xuXG4gICAgICAgICAgICAgICAgaCAqPSAzNjAwMDAwO1xuICAgICAgICAgICAgICAgIG0gKj0gNjAwMDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaCArIG07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzE1XSA9PT0gXCIrXCIpXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmc6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgICAgIC8vIERhdGVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eKFxcZHsyfSk6KFxcZHsyfSkoOihcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFxcK3wtKShcXGR7Mn0pOihcXGR7Mn0pKSk/JC8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBUaW1lXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5wYXJzZUlzb0RhdGVTdHJpbmcoc3RyaW5nKTtcbiAgICB9LFxuXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChvYmosIGZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsdWUsIG5ld1ZhbHVlO1xuICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBmdW5jKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlKHZhbHVlLCBmdW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgdHJhdmVyc2VBbmRSZXZpdmU6IGZ1bmN0aW9uIChkYXRhLCByZXZpdmVyKSB7XG4gICAgICAgIGlmICghcmV2aXZlcikge1xuICAgICAgICAgICAgcmV2aXZlciA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLmdldFJldml2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy50cmF2ZXJzZShkYXRhLCByZXZpdmVyKTtcbiAgICB9LFxuXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gKHJldml2ZXIsIGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnICYmIGVycm9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge21lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIGNvZGU6IGVycm9yLmVycm9yQ29kZX07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wYXJzZUludGVybmFsOiBmdW5jdGlvbiAocmV2aXZlciwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1dGlscy5wYXJzZVV0aWxpdGllcy50cmF2ZXJzZUFuZFJldml2ZShkYXRhLCByZXZpdmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtUmVzdWx0OiBmdW5jdGlvbiAoZGF0YSwgYWRkaXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7cmVzdWx0OiBkYXRhLlJlc3VsdH07XG4gICAgICAgICAgICBfLmV4dGVuZChyZXN1bHQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEsIHtjb3VudDogZGF0YS5Db3VudH0pO1xuICAgIH0sXG5cbiAgICBwYXJzZVNpbmdsZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEpO1xuICAgIH0sXG5cbiAgICBwYXJzZVVwZGF0ZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEsIHtNb2RpZmllZEF0OiBkYXRhLk1vZGlmaWVkQXR9KTtcbiAgICB9LFxuXG4gICAgcGFyc2VKU09OOiBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uLCB1dGlscy5wYXJzZVV0aWxpdGllcy5nZXRSZXZpdmVyKCkpO1xuICAgIH1cbn07XG5cbnV0aWxzLmJ1aWxkUHJvbWlzZSA9IGZ1bmN0aW9uIGJ1aWxkUHJvbWlzZShvcGVyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHV0aWxzLmdldENhbGxiYWNrcyhzdWNjZXNzLCBlcnJvcik7XG4gICAgb3BlcmF0aW9uKGNhbGxiYWNrcy5zdWNjZXNzLCBjYWxsYmFja3MuZXJyb3IpO1xuICAgIHJldHVybiBjYWxsYmFja3MucHJvbWlzZTtcbn07XG5cbnV0aWxzLmdldENhbGxiYWNrcyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciBjcmVhdGVQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAocGxhdGZvcm0uaXNOb2RlanMpIHtcbiAgICAgICAgLy8gbm9kZSBqcyBzdHlsZSBjb250aW51YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gc3VjY2VzcztcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IGNyZWF0ZVByb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBjcmVhdGVQcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2UsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGVycm9yOiBlcnJvcn07XG59O1xuXG51dGlscy5idWlsZEF1dGhIZWFkZXIgPSBmdW5jdGlvbiBidWlsZEF1dGhIZWFkZXIoc2V0dXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXV0aEhlYWRlclZhbHVlID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmF1dGhIZWFkZXJzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXV0aEhlYWRlclZhbHVlO1xuICAgIH1cbiAgICBpZiAoc2V0dXAudG9rZW4pIHtcbiAgICAgICAgYXV0aEhlYWRlclZhbHVlID0gKHNldHVwLnRva2VuVHlwZSB8fCAnYmVhcmVyJykgKyAnICcgKyBzZXR1cC50b2tlbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2V0dXAubWFzdGVyS2V5KSB7XG4gICAgICAgIGF1dGhIZWFkZXJWYWx1ZSA9ICdtYXN0ZXJrZXkgJyArIHNldHVwLm1hc3RlcktleTtcbiAgICB9XG4gICAgaWYgKGF1dGhIZWFkZXJWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge0F1dGhvcml6YXRpb246IGF1dGhIZWFkZXJWYWx1ZX07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxudXRpbHMuRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0ID0gZnVuY3Rpb24gRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0KHRva2VuKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xufTtcblxudXRpbHMuY2xvbmVEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG59O1xuXG51dGlscy5idWlsZFVybCA9IGZ1bmN0aW9uIChzZXR1cCkge1xuICAgIHZhciB1cmwgPSAnJztcbiAgICBpZiAodHlwZW9mIHNldHVwLnNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdXJsICs9IHNldHVwLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgdXJsICs9IHNldHVwLnVybDtcbiAgICBpZiAoc2V0dXAuYXBpS2V5KSB7XG4gICAgICAgIHVybCArPSBzZXR1cC5hcGlLZXkgKyAnLyc7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuXG51dGlscy5nZXREYk9wZXJhdG9ycyA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBzaGFsbG93KSB7XG4gICAgdmFyIGRiT3BlcmF0b3JzID0gW107XG5cbiAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkYk9wZXJhdG9ycztcbiAgICB9XG5cbiAgICB2YXIgbW9kaWZpZXJLZXlzID0gT2JqZWN0LmtleXMoZXhwcmVzc2lvbik7XG4gICAgXy5lYWNoKG1vZGlmaWVyS2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJyQnKSA9PT0gMCkge1xuICAgICAgICAgICAgZGJPcGVyYXRvcnMucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByZXNzaW9uW2tleV0gPT09ICdvYmplY3QnICYmICFzaGFsbG93KSB7XG4gICAgICAgICAgICBkYk9wZXJhdG9ycyA9IGRiT3BlcmF0b3JzLmNvbmNhdCh1dGlscy5nZXREYk9wZXJhdG9ycyhleHByZXNzaW9uW2tleV0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRiT3BlcmF0b3JzO1xufTtcblxudXRpbHMuZGlzYWJsZVJlcXVlc3RDYWNoZSA9IGZ1bmN0aW9uICh1cmwsIG1ldGhvZCkge1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gdXJsLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nO1xuICAgICAgICB1cmwgKz0gc2VwYXJhdG9yICsgJ19lbD0nICsgdGltZXN0YW1wO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG59O1xuXG52YXIgdW5zdXBwb3J0ZWREYk9wZXJhdG9ycyA9IFtcbiAgICAnJGdlb1dpdGhpbicsXG4gICAgJyRnZW9JbnRlcnNlY3RzJyxcbiAgICAnJG5lYXInLFxuICAgICckd2l0aGluJyxcbiAgICAnJG5lYXJTcGhlcmUnXG5dO1xuXG51dGlscy5nZXRVbnN1cHBvcnRlZE9wZXJhdG9ycyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICB2YXIgZGJPcGVyYXRvcnMgPSB1dGlscy5nZXREYk9wZXJhdG9ycyhmaWx0ZXIpO1xuICAgIHJldHVybiBfLmludGVyc2VjdGlvbihkYk9wZXJhdG9ycywgdW5zdXBwb3J0ZWREYk9wZXJhdG9ycyk7XG59O1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc5MDU5MjkvaG93LXRvLXRlc3QtdmFsaWQtdXVpZC1ndWlkXG51dGlscy5pc0d1aWQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIC9eWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2kudGVzdChzdHIpO1xufTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjI0NTc2Ny9jcmVhdGluZy1hLWJsb2ItZnJvbS1hLWJhc2U2NC1zdHJpbmctaW4tamF2YXNjcmlwdC8xNjI0NTc2OCMxNjI0NTc2OFxudXRpbHMuYjY0dG9CbG9iID0gZnVuY3Rpb24gKGI2NERhdGEsIGNvbnRlbnRUeXBlLCBzbGljZVNpemUpIHtcbiAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8ICcnO1xuICAgIHNsaWNlU2l6ZSA9IHNsaWNlU2l6ZSB8fCA1MTI7XG5cbiAgICB2YXIgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGI2NERhdGEpO1xuICAgIHZhciBieXRlQXJyYXlzID0gW107XG5cbiAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IG9mZnNldCArPSBzbGljZVNpemUpIHtcbiAgICAgICAgdmFyIHNsaWNlID0gYnl0ZUNoYXJhY3RlcnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzbGljZVNpemUpO1xuXG4gICAgICAgIHZhciBieXRlTnVtYmVycyA9IG5ldyBBcnJheShzbGljZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xuXG4gICAgICAgIGJ5dGVBcnJheXMucHVzaChieXRlQXJyYXkpO1xuICAgIH1cblxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoYnl0ZUFycmF5cywge3R5cGU6IGNvbnRlbnRUeXBlfSk7XG4gICAgcmV0dXJuIGJsb2I7XG59O1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzkyNjc4OTkvYXJyYXlidWZmZXItdG8tYmFzZTY0LWVuY29kZWQtc3RyaW5nXG51dGlscy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHZhciBiaW5hcnkgPSAnJztcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHZhciBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBidG9hKGJpbmFyeSk7XG59O1xuXG51dGlscy5zdWNjZXNzZnVsUHJvbWlzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbn07XG5cbnV0aWxzLnJlamVjdGVkUHJvbWlzZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xufTtcblxudXRpbHMudHJhbnNmb3JtUGxhdGZvcm1QYXRoID0gZnVuY3Rpb24gdHJhbnNmb3JtUGxhdGZvcm1QYXRoKHBsYXRmb3JtUGF0aCkge1xuICAgIGlmICghcGxhdGZvcm1QYXRoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtUGF0aC5jaGFyQXQoMCkgPT09ICcvJyAmJiBwbGF0Zm9ybVBhdGguY2hhckF0KDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHBsYXRmb3JtUGF0aCA9ICcvJyArIHBsYXRmb3JtUGF0aDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7IC8vVE9ETzogcHJvYmFibHkgZGVza3RvcCB0b29cbiAgICAgICAgaWYgKHBsYXRmb3JtUGF0aC5pbmRleE9mKCdmaWxlOi8nKSAhPT0gLTEgJiYgcGxhdGZvcm1QYXRoLmluZGV4T2YoJ2ZpbGU6Ly8vJykgPT09IC0xKSB7XG4gICAgICAgICAgICBwbGF0Zm9ybVBhdGggPSBwbGF0Zm9ybVBhdGgucmVwbGFjZSgnZmlsZTovJywgJ2ZpbGU6Ly8vJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGxhdGZvcm1QYXRoO1xufTtcblxudXRpbHMuX3N0cmluZ0NvbXBhcmUgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGVjaykge1xuICAgIHJldHVybiBzdHJpbmcudG9Mb3dlckNhc2UoKSA9PT0gY2hlY2s7XG59O1xuXG51dGlscy5pc0NvbnRlbnRUeXBlID0ge1xuICAgIGZpbGVzOiBmdW5jdGlvbiAoY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLl9zdHJpbmdDb21wYXJlKGNvbGxlY3Rpb25OYW1lLCAnZmlsZXMnKTtcbiAgICB9LFxuICAgIHVzZXJzOiBmdW5jdGlvbiAoY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLl9zdHJpbmdDb21wYXJlKGNvbGxlY3Rpb25OYW1lLCAndXNlcnMnKTtcbiAgICB9XG59O1xuXG51dGlscy5pc0VsZW1lbnQgPSB7XG4gICAgX2lzRWxlbWVudDogZnVuY3Rpb24gKGVsLCBjaGVjaykge1xuICAgICAgICB2YXIgdGFnID0gZWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0YWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbHMuX3N0cmluZ0NvbXBhcmUodGFnLCBjaGVjayk7XG4gICAgfSxcbiAgICBpbWFnZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5pc0VsZW1lbnQuX2lzRWxlbWVudChlbCwgJ2ltZycpO1xuICAgIH0sXG4gICAgYW5jaG9yOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmlzRWxlbWVudC5faXNFbGVtZW50KGVsLCAnYScpO1xuICAgIH1cbn07XG5cbnV0aWxzLmpvaW5QYXRoID0gZnVuY3Rpb24gam9pblBhdGgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcgfHwgJyc7XG4gICAgfSk7XG5cbiAgICB2YXIgam9pbmVkUGF0aCA9IHBhdGguam9pbi5hcHBseShwYXRoLCBhcmdzKTtcbiAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtUGxhdGZvcm1QYXRoKGpvaW5lZFBhdGgpO1xufTtcblxudXRpbHMudXVpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkqMTYpJTE2IHwgMDtcbiAgICAgICAgZCA9IE1hdGguZmxvb3IoZC8xNik7XG4gICAgICAgIHJldHVybiAoYz09J3gnID8gciA6IChyJjB4M3wweDgpKS50b1N0cmluZygxNik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXVpZDtcbn07XG5cbnV0aWxzLmdldElkID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouSWQgfHwgb2JqLl9pZCB8fCBvYmouaWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzO1xuIl19
}())